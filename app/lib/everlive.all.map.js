if (typeof define !== "undefined" && define.amd) { define(function () { return Everlive; }); }(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding) {
  var self = this
  if (!(self instanceof Buffer)) return new Buffer(subject, encoding)

  var type = typeof subject
  var length

  if (type === 'number') {
    length = +subject
  } else if (type === 'string') {
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) {
    // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data)) subject = subject.data
    length = +subject.length
  } else {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (length > kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' +
      kMaxLength.toString(16) + ' bytes')
  }

  if (length < 0) length = 0
  else length >>>= 0 // coerce to uint32

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    self = Buffer._augment(new Uint8Array(length)) // eslint-disable-line consistent-this
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    self.length = length
    self._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    self._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++) {
        self[i] = subject.readUInt8(i)
      }
    } else {
      for (i = 0; i < length; i++) {
        self[i] = ((subject[i] % 256) + 256) % 256
      }
    }
  } else if (type === 'string') {
    self.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < length; i++) {
      self[i] = 0
    }
  }

  if (length > 0 && length <= Buffer.poolSize) self.parent = rootParent

  return self
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, totalLength) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function byteLength (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0

  if (length < 0 || offset < 0 || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) >>> 0 & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) >>> 0 & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(
      this, value, offset, byteLength,
      Math.pow(2, 8 * byteLength - 1) - 1,
      -Math.pow(2, 8 * byteLength - 1)
    )
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(
      this, value, offset, byteLength,
      Math.pow(2, 8 * byteLength - 1) - 1,
      -Math.pow(2, 8 * byteLength - 1)
    )
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, target_start, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (target_start >= target.length) target_start = target.length
  if (!target_start) target_start = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (target_start < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - target_start < end - start) {
    end = target.length - target_start + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":3,"ieee754":4,"is-array":5}],3:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
  'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

  var PLUS   = '+'.charCodeAt(0)
  var SLASH  = '/'.charCodeAt(0)
  var NUMBER = '0'.charCodeAt(0)
  var LOWER  = 'a'.charCodeAt(0)
  var UPPER  = 'A'.charCodeAt(0)
  var PLUS_URL_SAFE = '-'.charCodeAt(0)
  var SLASH_URL_SAFE = '_'.charCodeAt(0)

  function decode (elt) {
    var code = elt.charCodeAt(0)
    if (code === PLUS ||
        code === PLUS_URL_SAFE)
      return 62 // '+'
    if (code === SLASH ||
        code === SLASH_URL_SAFE)
      return 63 // '/'
    if (code < NUMBER)
      return -1 //no match
    if (code < NUMBER + 10)
      return code - NUMBER + 26 + 26
    if (code < UPPER + 26)
      return code - UPPER
    if (code < LOWER + 26)
      return code - LOWER + 26
  }

  function b64ToByteArray (b64) {
    var i, j, l, tmp, placeHolders, arr

    if (b64.length % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    var len = b64.length
    placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(b64.length * 3 / 4 - placeHolders)

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? b64.length - 4 : b64.length

    var L = 0

    function push (v) {
      arr[L++] = v
    }

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
      push((tmp & 0xFF0000) >> 16)
      push((tmp & 0xFF00) >> 8)
      push(tmp & 0xFF)
    }

    if (placeHolders === 2) {
      tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
      push(tmp & 0xFF)
    } else if (placeHolders === 1) {
      tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
      push((tmp >> 8) & 0xFF)
      push(tmp & 0xFF)
    }

    return arr
  }

  function uint8ToBase64 (uint8) {
    var i,
      extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
      output = "",
      temp, length

    function encode (num) {
      return lookup.charAt(num)
    }

    function tripletToBase64 (num) {
      return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
    }

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
      output += tripletToBase64(temp)
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    switch (extraBytes) {
      case 1:
        temp = uint8[uint8.length - 1]
        output += encode(temp >> 2)
        output += encode((temp << 4) & 0x3F)
        output += '=='
        break
      case 2:
        temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
        output += encode(temp >> 10)
        output += encode((temp >> 4) & 0x3F)
        output += encode((temp << 2) & 0x3F)
        output += '='
        break
    }

    return output
  }

  exports.toByteArray = b64ToByteArray
  exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],4:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],5:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],7:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],8:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],10:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":11}],11:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))

},{"./_stream_readable":13,"./_stream_writable":15,"_process":9,"core-util-is":16,"inherits":7}],12:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":14,"core-util-is":16,"inherits":7}],13:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":11,"_process":9,"buffer":2,"core-util-is":16,"events":6,"inherits":7,"isarray":8,"stream":21,"string_decoder/":22,"util":1}],14:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":11,"core-util-is":16,"inherits":7}],15:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))

},{"./_stream_duplex":11,"_process":9,"buffer":2,"core-util-is":16,"inherits":7,"stream":21}],16:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)

},{"buffer":2}],17:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":12}],18:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":11,"./lib/_stream_passthrough.js":12,"./lib/_stream_readable.js":13,"./lib/_stream_transform.js":14,"./lib/_stream_writable.js":15,"stream":21}],19:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":14}],20:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":15}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":7,"readable-stream/duplex.js":10,"readable-stream/passthrough.js":17,"readable-stream/readable.js":18,"readable-stream/transform.js":19,"readable-stream/writable.js":20}],22:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":2}],23:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],24:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":23,"_process":9,"inherits":7}],25:[function(require,module,exports){
/**
 * This script gives you the zone info key representing your device's time zone setting.
 *
 * @name jsTimezoneDetect
 * @version 1.0.5
 * @author Jon Nylander
 * @license MIT License - http://www.opensource.org/licenses/mit-license.php
 *
 * For usage and examples, visit:
 * http://pellepim.bitbucket.org/jstz/
 *
 * Copyright (c) Jon Nylander
 */

/*jslint undef: true */
/*global console, exports*/

(function(root) {
  /**
   * Namespace to hold all the code for timezone detection.
   */
  var jstz = (function () {
      'use strict';
      var HEMISPHERE_SOUTH = 's',
          
          /**
           * Gets the offset in minutes from UTC for a certain date.
           * @param {Date} date
           * @returns {Number}
           */
          get_date_offset = function (date) {
              var offset = -date.getTimezoneOffset();
              return (offset !== null ? offset : 0);
          },

          get_date = function (year, month, date) {
              var d = new Date();
              if (year !== undefined) {
                d.setFullYear(year);
              }
              d.setMonth(month);
              d.setDate(date);
              return d;
          },

          get_january_offset = function (year) {
              return get_date_offset(get_date(year, 0 ,2));
          },

          get_june_offset = function (year) {
              return get_date_offset(get_date(year, 5, 2));
          },

          /**
           * Private method.
           * Checks whether a given date is in daylight saving time.
           * If the date supplied is after august, we assume that we're checking
           * for southern hemisphere DST.
           * @param {Date} date
           * @returns {Boolean}
           */
          date_is_dst = function (date) {
              var is_southern = date.getMonth() > 7,
                  base_offset = is_southern ? get_june_offset(date.getFullYear()) : 
                                              get_january_offset(date.getFullYear()),
                  date_offset = get_date_offset(date),
                  is_west = base_offset < 0,
                  dst_offset = base_offset - date_offset;
                  
              if (!is_west && !is_southern) {
                  return dst_offset < 0;
              }

              return dst_offset !== 0;
          },

          /**
           * This function does some basic calculations to create information about
           * the user's timezone. It uses REFERENCE_YEAR as a solid year for which
           * the script has been tested rather than depend on the year set by the
           * client device.
           *
           * Returns a key that can be used to do lookups in jstz.olson.timezones.
           * eg: "720,1,2". 
           *
           * @returns {String}
           */

          lookup_key = function () {
              var january_offset = get_january_offset(),
                  june_offset = get_june_offset(),
                  diff = january_offset - june_offset;

              if (diff < 0) {
                  return january_offset + ",1";
              } else if (diff > 0) {
                  return june_offset + ",1," + HEMISPHERE_SOUTH;
              }

              return january_offset + ",0";
          },

          /**
           * Uses get_timezone_info() to formulate a key to use in the olson.timezones dictionary.
           *
           * Returns a primitive object on the format:
           * {'timezone': TimeZone, 'key' : 'the key used to find the TimeZone object'}
           *
           * @returns Object
           */
          determine = function () {
              var key = lookup_key();
              return new jstz.TimeZone(jstz.olson.timezones[key]);
          },

          /**
           * This object contains information on when daylight savings starts for
           * different timezones.
           *
           * The list is short for a reason. Often we do not have to be very specific
           * to single out the correct timezone. But when we do, this list comes in
           * handy.
           *
           * Each value is a date denoting when daylight savings starts for that timezone.
           */
          dst_start_for = function (tz_name) {

            var ru_pre_dst_change = new Date(2010, 6, 15, 1, 0, 0, 0), // In 2010 Russia had DST, this allows us to detect Russia :)
                dst_starts = {
                    'America/Denver': new Date(2011, 2, 13, 3, 0, 0, 0),
                    'America/Mazatlan': new Date(2011, 3, 3, 3, 0, 0, 0),
                    'America/Chicago': new Date(2011, 2, 13, 3, 0, 0, 0),
                    'America/Mexico_City': new Date(2011, 3, 3, 3, 0, 0, 0),
                    'America/Asuncion': new Date(2012, 9, 7, 3, 0, 0, 0),
                    'America/Santiago': new Date(2012, 9, 3, 3, 0, 0, 0),
                    'America/Campo_Grande': new Date(2012, 9, 21, 5, 0, 0, 0),
                    'America/Montevideo': new Date(2011, 9, 2, 3, 0, 0, 0),
                    'America/Sao_Paulo': new Date(2011, 9, 16, 5, 0, 0, 0),
                    'America/Los_Angeles': new Date(2011, 2, 13, 8, 0, 0, 0),
                    'America/Santa_Isabel': new Date(2011, 3, 5, 8, 0, 0, 0),
                    'America/Havana': new Date(2012, 2, 10, 2, 0, 0, 0),
                    'America/New_York': new Date(2012, 2, 10, 7, 0, 0, 0),
                    'Europe/Helsinki': new Date(2013, 2, 31, 5, 0, 0, 0),
                    'Pacific/Auckland': new Date(2011, 8, 26, 7, 0, 0, 0),
                    'America/Halifax': new Date(2011, 2, 13, 6, 0, 0, 0),
                    'America/Goose_Bay': new Date(2011, 2, 13, 2, 1, 0, 0),
                    'America/Miquelon': new Date(2011, 2, 13, 5, 0, 0, 0),
                    'America/Godthab': new Date(2011, 2, 27, 1, 0, 0, 0),
                    'Europe/Moscow': ru_pre_dst_change,
                    'Asia/Amman': new Date(2013, 2, 29, 1, 0, 0, 0),
                    'Asia/Beirut': new Date(2013, 2, 31, 2, 0, 0, 0),
                    'Asia/Damascus': new Date(2013, 3, 6, 2, 0, 0, 0),
                    'Asia/Jerusalem': new Date(2013, 2, 29, 5, 0, 0, 0),
                    'Asia/Yekaterinburg': ru_pre_dst_change,
                    'Asia/Omsk': ru_pre_dst_change,
                    'Asia/Krasnoyarsk': ru_pre_dst_change,
                    'Asia/Irkutsk': ru_pre_dst_change,
                    'Asia/Yakutsk': ru_pre_dst_change,
                    'Asia/Vladivostok': ru_pre_dst_change,
                    'Asia/Baku': new Date(2013, 2, 31, 4, 0, 0),
                    'Asia/Yerevan': new Date(2013, 2, 31, 3, 0, 0),
                    'Asia/Kamchatka': ru_pre_dst_change,
                    'Asia/Gaza': new Date(2010, 2, 27, 4, 0, 0),
                    'Africa/Cairo': new Date(2010, 4, 1, 3, 0, 0),
                    'Europe/Minsk': ru_pre_dst_change,
                    'Pacific/Apia': new Date(2010, 10, 1, 1, 0, 0, 0),
                    'Pacific/Fiji': new Date(2010, 11, 1, 0, 0, 0),
                    'Australia/Perth': new Date(2008, 10, 1, 1, 0, 0, 0)
                };

              return dst_starts[tz_name];
          };

      return {
          determine: determine,
          date_is_dst: date_is_dst,
          dst_start_for: dst_start_for 
      };
  }());

  /**
   * Simple object to perform ambiguity check and to return name of time zone.
   */
  jstz.TimeZone = function (tz_name) {
      'use strict';
        /**
         * The keys in this object are timezones that we know may be ambiguous after
         * a preliminary scan through the olson_tz object.
         *
         * The array of timezones to compare must be in the order that daylight savings
         * starts for the regions.
         */
      var AMBIGUITIES = {
              'America/Denver':       ['America/Denver', 'America/Mazatlan'],
              'America/Chicago':      ['America/Chicago', 'America/Mexico_City'],
              'America/Santiago':     ['America/Santiago', 'America/Asuncion', 'America/Campo_Grande'],
              'America/Montevideo':   ['America/Montevideo', 'America/Sao_Paulo'],
              'Asia/Beirut':          ['Asia/Amman', 'Asia/Jerusalem', 'Asia/Beirut', 'Europe/Helsinki','Asia/Damascus'],
              'Pacific/Auckland':     ['Pacific/Auckland', 'Pacific/Fiji'],
              'America/Los_Angeles':  ['America/Los_Angeles', 'America/Santa_Isabel'],
              'America/New_York':     ['America/Havana', 'America/New_York'],
              'America/Halifax':      ['America/Goose_Bay', 'America/Halifax'],
              'America/Godthab':      ['America/Miquelon', 'America/Godthab'],
              'Asia/Dubai':           ['Europe/Moscow'],
              'Asia/Dhaka':           ['Asia/Yekaterinburg'],
              'Asia/Jakarta':         ['Asia/Omsk'],
              'Asia/Shanghai':        ['Asia/Krasnoyarsk', 'Australia/Perth'],
              'Asia/Tokyo':           ['Asia/Irkutsk'],
              'Australia/Brisbane':   ['Asia/Yakutsk'],
              'Pacific/Noumea':       ['Asia/Vladivostok'],
              'Pacific/Tarawa':       ['Asia/Kamchatka', 'Pacific/Fiji'],
              'Pacific/Tongatapu':    ['Pacific/Apia'],
              'Asia/Baghdad':         ['Europe/Minsk'],
              'Asia/Baku':            ['Asia/Yerevan','Asia/Baku'],
              'Africa/Johannesburg':  ['Asia/Gaza', 'Africa/Cairo']
          },

          timezone_name = tz_name,
          
          /**
           * Checks if a timezone has possible ambiguities. I.e timezones that are similar.
           *
           * For example, if the preliminary scan determines that we're in America/Denver.
           * We double check here that we're really there and not in America/Mazatlan.
           *
           * This is done by checking known dates for when daylight savings start for different
           * timezones during 2010 and 2011.
           */
          ambiguity_check = function () {
              var ambiguity_list = AMBIGUITIES[timezone_name],
                  length = ambiguity_list.length,
                  i = 0,
                  tz = ambiguity_list[0];

              for (; i < length; i += 1) {
                  tz = ambiguity_list[i];

                  if (jstz.date_is_dst(jstz.dst_start_for(tz))) {
                      timezone_name = tz;
                      return;
                  }
              }
          },

          /**
           * Checks if it is possible that the timezone is ambiguous.
           */
          is_ambiguous = function () {
              return typeof (AMBIGUITIES[timezone_name]) !== 'undefined';
          };

      if (is_ambiguous()) {
          ambiguity_check();
      }

      return {
          name: function () {
              return timezone_name;
          }
      };
  };

  jstz.olson = {};

  /*
   * The keys in this dictionary are comma separated as such:
   *
   * First the offset compared to UTC time in minutes.
   *
   * Then a flag which is 0 if the timezone does not take daylight savings into account and 1 if it
   * does.
   *
   * Thirdly an optional 's' signifies that the timezone is in the southern hemisphere,
   * only interesting for timezones with DST.
   *
   * The mapped arrays is used for constructing the jstz.TimeZone object from within
   * jstz.determine_timezone();
   */
  jstz.olson.timezones = {
      '-720,0'   : 'Pacific/Majuro',
      '-660,0'   : 'Pacific/Pago_Pago',
      '-600,1'   : 'America/Adak',
      '-600,0'   : 'Pacific/Honolulu',
      '-570,0'   : 'Pacific/Marquesas',
      '-540,0'   : 'Pacific/Gambier',
      '-540,1'   : 'America/Anchorage',
      '-480,1'   : 'America/Los_Angeles',
      '-480,0'   : 'Pacific/Pitcairn',
      '-420,0'   : 'America/Phoenix',
      '-420,1'   : 'America/Denver',
      '-360,0'   : 'America/Guatemala',
      '-360,1'   : 'America/Chicago',
      '-360,1,s' : 'Pacific/Easter',
      '-300,0'   : 'America/Bogota',
      '-300,1'   : 'America/New_York',
      '-270,0'   : 'America/Caracas',
      '-240,1'   : 'America/Halifax',
      '-240,0'   : 'America/Santo_Domingo',
      '-240,1,s' : 'America/Santiago',
      '-210,1'   : 'America/St_Johns',
      '-180,1'   : 'America/Godthab',
      '-180,0'   : 'America/Argentina/Buenos_Aires',
      '-180,1,s' : 'America/Montevideo',
      '-120,0'   : 'America/Noronha',
      '-120,1'   : 'America/Noronha',
      '-60,1'    : 'Atlantic/Azores',
      '-60,0'    : 'Atlantic/Cape_Verde',
      '0,0'      : 'UTC',
      '0,1'      : 'Europe/London',
      '60,1'     : 'Europe/Berlin',
      '60,0'     : 'Africa/Lagos',
      '60,1,s'   : 'Africa/Windhoek',
      '120,1'    : 'Asia/Beirut',
      '120,0'    : 'Africa/Johannesburg',
      '180,0'    : 'Asia/Baghdad',
      '180,1'    : 'Europe/Moscow',
      '210,1'    : 'Asia/Tehran',
      '240,0'    : 'Asia/Dubai',
      '240,1'    : 'Asia/Baku',
      '270,0'    : 'Asia/Kabul',
      '300,1'    : 'Asia/Yekaterinburg',
      '300,0'    : 'Asia/Karachi',
      '330,0'    : 'Asia/Kolkata',
      '345,0'    : 'Asia/Kathmandu',
      '360,0'    : 'Asia/Dhaka',
      '360,1'    : 'Asia/Omsk',
      '390,0'    : 'Asia/Rangoon',
      '420,1'    : 'Asia/Krasnoyarsk',
      '420,0'    : 'Asia/Jakarta',
      '480,0'    : 'Asia/Shanghai',
      '480,1'    : 'Asia/Irkutsk',
      '525,0'    : 'Australia/Eucla',
      '525,1,s'  : 'Australia/Eucla',
      '540,1'    : 'Asia/Yakutsk',
      '540,0'    : 'Asia/Tokyo',
      '570,0'    : 'Australia/Darwin',
      '570,1,s'  : 'Australia/Adelaide',
      '600,0'    : 'Australia/Brisbane',
      '600,1'    : 'Asia/Vladivostok',
      '600,1,s'  : 'Australia/Sydney',
      '630,1,s'  : 'Australia/Lord_Howe',
      '660,1'    : 'Asia/Kamchatka',
      '660,0'    : 'Pacific/Noumea',
      '690,0'    : 'Pacific/Norfolk',
      '720,1,s'  : 'Pacific/Auckland',
      '720,0'    : 'Pacific/Tarawa',
      '765,1,s'  : 'Pacific/Chatham',
      '780,0'    : 'Pacific/Tongatapu',
      '780,1,s'  : 'Pacific/Apia',
      '840,0'    : 'Pacific/Kiritimati'
  };

  if (typeof exports !== 'undefined') {
    exports.jstz = jstz;
  } else {
    root.jstz = jstz;
  }
})(this);


},{}],26:[function(require,module,exports){
// Mingo.js 0.4.0
// Copyright (c) 2015 Francis Asante <kofrasa@gmail.com>
// MIT

(function (root, undefined) {

  "use strict";

  // global on the server, window in the browser
  var Mingo = {}, previousMingo;
  var _;

  // backup previous Mingo
  if (root != null) {
    previousMingo = root.Mingo;
  }

  Mingo.noConflict = function () {
    root.Mingo = previousMingo;
    return Mingo;
  };

  var nativeScriptEnabled = Boolean(((typeof android !== 'undefined' && android && android.widget && android.widget.Button)
    || (typeof UIButton !== 'undefined' && UIButton)));

  var nodeEnabled = ('undefined' !== typeof exports && 'undefined' !== typeof require && !nativeScriptEnabled);


  // Export the Mingo object for Node.js
  if (nodeEnabled || nativeScriptEnabled) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Mingo;
    } else {
      exports = Mingo;
    }
    _ = require("underscore"); // get a reference to underscore
  } else {
    root.Mingo = Mingo;
    _ = root._; // get a reference to underscore
  }

  // quick reference for
  var primitives = [
    _.isString, _.isBoolean, _.isNumber, _.isDate, _.isNull, _.isRegExp
  ];

  function normalize(expr) {
    // normalized primitives
    for (var i = 0; i < primitives.length; i++) {
      if (primitives[i](expr)) {
        if (_.isRegExp(expr)) {
          return {"$regex": expr};
        } else {
          return {"$eq": expr};
        }
      }
    }
    // normalize object expression
    if (_.isObject(expr)) {
      var keys = _.keys(expr);
      var notQuery = _.intersection(Ops.queryOperators, keys).length === 0;

      // no valid query operator found, so we do simple comparison
      if (notQuery) {
        return {"$eq": expr};
      }

      // ensure valid regex
      if (_.contains(keys, "$regex")) {
        var regex = expr['$regex'];
        var options = expr['$options'] || "";
        var modifiers = "";
        if (_.isString(regex)) {
          modifiers += (regex.ignoreCase || options.indexOf("i") >= 0) ? "i" : "";
          modifiers += (regex.multiline || options.indexOf("m") >= 0) ? "m" : "";
          modifiers += (regex.global || options.indexOf("g") >= 0) ? "g" : "";
          regex = new RegExp(regex, modifiers);
        }
        expr['$regex'] = regex;
        delete expr['$options'];
      }
    }

    return expr;
  }

  // Settings used by Mingo internally
  var settings = {
    key: "_id"
  };

  /**
   * Setup default settings for Mingo
   * @param options
   */
  Mingo.setup = function (options) {
    _.extend(settings, options || {});
  };


  /**
   * Query object to test collection elements with
   * @param criteria the pass criteria for the query
   * @param projection optional projection specifiers
   * @constructor
   */
  Mingo.Query = function (criteria, projection) {
    if (!(this instanceof Mingo.Query))
      return new Mingo.Query(criteria, projection);

    this._criteria = criteria;
    this._projection = projection;
    this._compiled = [];
    this._compile();
  };

  Mingo.Query.prototype = {

    _compile: function () {

      if (_.isEmpty(this._criteria)) return;

      if (_.isArray(this._criteria) || _.isFunction(this._criteria) || !_.isObject(this._criteria)) {
        throw new Error("Invalid type for criteria");
      }

      for (var field in this._criteria) {
        if (this._criteria.hasOwnProperty(field)) {
          var expr = this._criteria[field];
          if (_.contains(['$and', '$or', '$nor', '$where'], field)) {
            this._processOperator(field, field, expr);
          } else {
            // normalize expression
            expr = normalize(expr);
            for (var op in expr) {
              if (expr.hasOwnProperty(op)) {
                this._processOperator(field, op, expr[op]);
              }
            }
          }
        }
      }
    },

    _processOperator: function (field, operator, value) {
      var compiledSelector;
      if (_.contains(Ops.simpleOperators, operator)) {
        compiledSelector = {
          test: function (obj) {
            var actualValue = resolve(obj, field);
            // value of operator must already be fully resolved.
            return simpleOperators[operator](actualValue, value);
          }
        };
      } else if (_.contains(Ops.compoundOperators, operator)) {
        compiledSelector = compoundOperators[operator](field, value);
      } else {
        throw new Error("Invalid query operator '" + operator + "' detected");
      }
      this._compiled.push(compiledSelector);
    },

    /**
     * Checks if the object passes the query criteria. Returns true if so, false otherwise.
     * @param obj
     * @returns {boolean}
     */
    test: function (obj) {
      for (var i = 0; i < this._compiled.length; i++) {
        if (!this._compiled[i].test(obj)) {
          return false;
        }
      }
      return true;
    },

    /**
     * Performs a query on a collection and returns a cursor object.
     * @param collection
     * @param projection
     * @returns {Mingo.Cursor}
     */
    find: function (collection, projection) {
      return new Mingo.Cursor(collection, this, projection);
    },

    /**
     * Remove matched documents from the collection returning the remainder
     * @param collection
     * @returns {Array}
     */
    remove: function (collection) {
      var arr = [];
      for (var i = 0; i < collection.length; i++) {
        if (!this.test(collection[i])) {
          arr.push(collection[i]);
        }
      }
      return arr;
    }
  };

  if (nodeEnabled) {

    var Transform = require('stream').Transform;
    var util = require('util');

    Mingo.Query.prototype.stream = function (options) {
      return new Mingo.Stream(this, options);
    };

    /**
     * Create a Transform class
     * @param query
     * @param options
     * @returns {Mingo.Stream}
     * @constructor
     */
    Mingo.Stream = function (query, options) {

      if (!(this instanceof Mingo.Stream))
        return new Mingo.Stream(query, options);

      options = options || {};
      _.extend(options, {objectMode: true});
      Transform.call(this, options);
      // query for this stream
      this._query = query;
    };
    // extend Transform
    util.inherits(Mingo.Stream, Transform);

    Mingo.Stream.prototype._transform = function (chunk, encoding, done) {
      if (_.isObject(chunk) && this._query.test(chunk)) {
        if (_.isEmpty(this._query._projection)) {
          this.push(chunk);
        } else {
          var cursor = new Mingo.Cursor([chunk], this._query);
          if (cursor.hasNext()) {
            this.push(cursor.next());
          }
        }
      }
      done();
    };
  }

  /**
   * Cursor to iterate and perform filtering on matched objects
   * @param collection
   * @param query
   * @param projection
   * @constructor
   */
  Mingo.Cursor = function (collection, query, projection) {

    if (!(this instanceof Mingo.Cursor))
      return new Mingo.Cursor(collection, query, projection);

    this._query = query;
    this._collection = collection;
    this._projection = projection || query._projection;
    this._operators = {};
    this._result = false;
    this._position = 0;
  };

  Mingo.Cursor.prototype = {

    _fetch: function () {
      var self = this;

      if (this._result !== false) {
        return this._result;
      }

      // inject projection operator
      if (_.isObject(this._projection)) {
        _.extend(this._operators, {"$project": this._projection});
      }

      if (!_.isArray(this._collection) && !_.isObject(this._collection)) {
        throw new Error("Input collection is not of valid type. Must be an Array.");
      }

      // filter collection
      this._result = _.filter(this._collection, this._query.test, this._query);
      var pipeline = [];

      _.each(['$sort', '$skip', '$limit', '$project'], function (op) {
        if (_.has(self._operators, op)) {
          pipeline.push(_.pick(self._operators, op));
        }
      });

      if (pipeline.length > 0) {
        var aggregator = new Mingo.Aggregator(pipeline);
        this._result = aggregator.run(this._result, this._query);
      }
      return this._result;
    },

    /**
     * Fetch and return all matched results
     * @returns {Array}
     */
    all: function () {
      return this._fetch();
    },

    /**
     * Fetch and return the first matching result
     * @returns {Object}
     */
    first: function () {
      return this.count() > 0 ? this._fetch()[0] : null;
    },

    /**
     * Fetch and return the last matching object from the result
     * @returns {Object}
     */
    last: function () {
      return this.count() > 0 ? this._fetch()[this.count() - 1] : null;
    },

    /**
     * Counts the number of matched objects found
     * @returns {Number}
     */
    count: function () {
      return this._fetch().length;
    },

    /**
     * Returns a cursor that begins returning results only after passing or skipping a number of documents.
     * @param {Number} n the number of results to skip.
     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
     */
    skip: function (n) {
      _.extend(this._operators, {"$skip": n});
      return this;
    },

    /**
     * Constrains the size of a cursor's result set.
     * @param {Number} n the number of results to limit to.
     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
     */
    limit: function (n) {
      _.extend(this._operators, {"$limit": n});
      return this;
    },

    /**
     * Returns results ordered according to a sort specification.
     * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
     */
    sort: function (modifier) {
      _.extend(this._operators, {"$sort": modifier});
      return this;
    },

    /**
     * Returns the next document in a cursor.
     * @returns {Object | Boolean}
     */
    next: function () {
      if (this.hasNext()) {
        return this._fetch()[this._position++];
      }
      return null;
    },

    /**
     * Returns true if the cursor has documents and can be iterated.
     * @returns {boolean}
     */
    hasNext: function () {
      return this.count() > this._position;
    },

    /**
     * Specifies the exclusive upper bound for a specific field
     * @param expr
     * @returns {Number}
     */
    max: function (expr) {
      return groupOperators.$max(this._fetch(), expr);
    },

    /**
     * Specifies the inclusive lower bound for a specific field
     * @param expr
     * @returns {Number}
     */
    min: function (expr) {
      return groupOperators.$min(this._fetch(), expr);
    },

    /**
     * Applies a function to each document in a cursor and collects the return values in an array.
     * @param callback
     * @returns {Array}
     */
    map: function (callback) {
      return _.map(this._fetch(), callback);
    },

    /**
     * Applies a JavaScript function for every document in a cursor.
     * @param callback
     */
    forEach: function (callback) {
      _.each(this._fetch(), callback);
    }

  };

  /**
   * Aggregator for defining filter using mongoDB aggregation pipeline syntax
   * @param operators an Array of pipeline operators
   * @constructor
   */
  Mingo.Aggregator = function (operators) {
    if (!(this instanceof Mingo.Aggregator))
      return new Mingo.Aggregator(operators);

    this._operators = operators;
  };

  Mingo.Aggregator.prototype = {

    /**
     * Apply the pipeline operations over the collection by order of the sequence added
     * @param collection an array of objects to process
     * @param query the `Mingo.Query` object to use as context
     * @returns {Array}
     */
    run: function (collection, query) {
      if (!_.isEmpty(this._operators)) {
        // run aggregation pipeline
        for (var i = 0; i < this._operators.length; i++) {
          var operator = this._operators[i];
          for (var key in operator) {
            if (operator.hasOwnProperty(key)) {
              if (query instanceof Mingo.Query) {
                collection = pipelineOperators[key].call(query, collection, operator[key]);
              } else {
                collection = pipelineOperators[key](collection, operator[key]);
              }
            }
          }
        }
      }
      return collection;
    }
  };

  /**
   * Retrieve the value of a given key on an object
   * @param obj
   * @param field
   * @returns {*}
   * @private
   */
  function getValue(obj, field) {
    return _.result(obj, field);
  }

  /**
   * Resolve the value of the field (dot separated) on the given object
   * @param obj
   * @param field
   * @returns {*}
   */
  function resolve(obj, field) {
    if (!field) {
      return undefined;
    }
    var names = field.split(".");
    var value = obj;
    var isText;

    for (var i = 0; i < names.length; i++) {
      isText = names[i].match(/^\d+$/) === null;

      if (isText && _.isArray(value)) {
        var res = [];
        _.each(value, function (item) {
          if (_.isObject(item)) {
            res.push(resolve(item, names[i]));
          }
        });
        value = res;
      } else {
        value = getValue(value, names[i]);
      }

      if (value === undefined) {
        break;
      }
    }

    return value;
  }

  /**
   * Performs a query on a collection and returns a cursor object.
   * @param collection
   * @param criteria
   * @param projection
   * @returns {Mingo.Cursor}
   */
  Mingo.find = function (collection, criteria, projection) {
    return (new Mingo.Query(criteria)).find(collection, projection);
  };

  /**
   * Returns a new array without objects which match the criteria
   * @param collection
   * @param criteria
   * @returns {Array}
   */
  Mingo.remove = function (collection, criteria) {
    return (new Mingo.Query(criteria)).remove(collection);
  };

  /**
   * Return the result collection after running the aggregation pipeline for the given collection
   * @param collection
   * @param pipeline
   * @returns {Array}
   */
  Mingo.aggregate = function (collection, pipeline) {
    if (!_.isArray(pipeline)) {
      throw new Error("Aggregation pipeline must be an array")
    }
    return (new Mingo.Aggregator(pipeline)).run(collection);
  };

  /**
   * Mixin for Backbone.Collection objects
   */
  Mingo.CollectionMixin = {
    /**
     * Runs a query and returns a cursor to the result
     * @param criteria
     * @param projection
     * @returns {Mingo.Cursor}
     */
    query: function (criteria, projection) {
      return Mingo.find(this.toJSON(), criteria, projection);
    },

    /**
     * Runs the given aggregation operators on this collection
     * @params pipeline
     * @returns {Array}
     */
    aggregate: function (pipeline) {
      var args = [this.toJSON(), pipeline];
      return Mingo.aggregate.apply(null, args);
    }
  };

  var pipelineOperators = {

    /**
     * Groups documents together for the purpose of calculating aggregate values based on a collection of documents.
     *
     * @param collection
     * @param expr
     * @returns {Array}
     */
    $group: function (collection, expr) {
      // lookup key for grouping
      var idKey = expr[settings.key];
      var indexes = [];
      // group collection by key
      var groups = _.groupBy(collection, function (obj) {
        var key = computeValue(obj, idKey, idKey);
        indexes.push(key);
        return key;
      });

      // group indexes
      indexes = _.uniq(indexes);

      // remove the group key
      expr = _.omit(expr, settings.key);

      var result = [];
      _.each(indexes, function (index) {
        var obj = {};
        obj[settings.key] = index;
        // compute remaining keys in expression
        for (var key in expr) {
          if (expr.hasOwnProperty(key)) {
            obj[key] = accumulate(groups[index], key, expr[key]);
          }
        }
        result.push(obj);
      });

      return result;
    },

    /**
     * Filters the document stream, and only allows matching documents to pass into the next pipeline stage.
     * $match uses standard MongoDB queries.
     *
     * @param collection
     * @param expr
     * @returns {Array|*}
     */
    $match: function (collection, expr) {
      return (new Mingo.Query(expr)).find(collection).all();
    },

    /**
     * Reshapes a document stream.
     * $project can rename, add, or remove fields as well as create computed values and sub-documents.
     *
     * @param collection
     * @param expr
     * @returns {Array}
     */
    $project: function (collection, expr) {

      if (_.isEmpty(expr)) {
        return collection;
      }

      // result collection
      var projected = [];
      var objKeys = _.keys(expr);

      if (_.contains(objKeys, settings.key)) {
        var id = expr[settings.key];
        if (id === 0 || id === false) {
          objKeys = _.without(objKeys, settings.key);
        }
      } else {
        // if not specified the add the ID field
        objKeys.push(settings.key);
      }

      for (var i = 0; i < collection.length; i++) {
        var obj = collection[i];
        var cloneObj = {};
        var foundSlice = false;
        var dropKeys = [];

        _.each(objKeys, function (key) {

          var subExpr = expr[key];
          var newValue;

          // tiny optimization here to skip over id
          if (key === settings.key && _.isEmpty(subExpr)) {
            newValue = obj[key];
          } else if (_.isString(subExpr)) {
            newValue = computeValue(obj, subExpr, key);
          } else if (subExpr === 1 || subExpr === true) {
            newValue = _.result(obj, key);
          } else if (_.isObject(subExpr)) {
            var operator = _.keys(subExpr);
            operator = operator.length > 1 ? false : operator[0];
            if (operator !== false && _.contains(Ops.projectionOperators, operator)) {
              // apply the projection operator on the operator expression for the key
              var temp = projectionOperators[operator](obj, subExpr[operator], key);
              if (!_.isUndefined(temp)) {
                newValue = temp;
              }
              if (operator == '$slice') {
                foundSlice = true;
              }
            } else {
              // compute the value for the sub expression for the key
              newValue = computeValue(obj, subExpr, key);
            }
          } else {
            dropKeys.push(key);
          }

          if (newValue !== undefined) {
            cloneObj[key] = _.isObject(newValue) ? _.clone(newValue) : newValue;
          }

        });
        // if projection included $slice operator
        // include keys that were not explicitly excluded
        if (foundSlice) {
          cloneObj = _.defaults(cloneObj, _.omit(obj, dropKeys));
        }
        projected.push(cloneObj);
      }

      return projected;
    },

    /**
     * Restricts the number of documents in an aggregation pipeline.
     *
     * @param collection
     * @param value
     * @returns {Object|*}
     */
    $limit: function (collection, value) {
      return _.first(collection, value);
    },

    /**
     * Skips over a specified number of documents from the pipeline and returns the rest.
     *
     * @param collection
     * @param value
     * @returns {*}
     */
    $skip: function (collection, value) {
      return _.rest(collection, value);
    },

    /**
     * Takes an array of documents and returns them as a stream of documents.
     *
     * @param collection
     * @param expr
     * @returns {Array}
     */
    $unwind: function (collection, expr) {
      var result = [];
      var field = expr.substr(1);
      for (var i = 0; i < collection.length; i++) {
        var obj = collection[i];
        // must throw an error if value is not an array
        var value = getValue(obj, field);
        if (_.isArray(value)) {
          _.each(value, function (item) {
            var tmp = _.clone(obj);
            tmp[field] = item;
            result.push(tmp);
          });
        } else {
          throw new Error("Target field '" + field + "' is not of type Array.");
        }
      }
      return result;
    },

    /**
     * Takes all input documents and returns them in a stream of sorted documents.
     *
     * @param collection
     * @param sortKeys
     * @returns {*}
     */
    $sort: function (collection, sortKeys) {
      if (!_.isEmpty(sortKeys) && _.isObject(sortKeys)) {
        var modifiers = _.keys(sortKeys);
        modifiers.reverse().forEach(function (key) {
          var indexes = [];
          var grouped = _.groupBy(collection, function (obj) {
            var value = resolve(obj, key);
            indexes.push(value);
            return value;
          });
          indexes = _.sortBy(_.uniq(indexes), function (item) {
            return item;
          });
          if (sortKeys[key] === -1) {
            indexes.reverse();
          }
          collection = [];
          _.each(indexes, function (item) {
            Array.prototype.push.apply(collection, grouped[item]);
          });
        });
      }
      return collection;
    }
  };

  var compoundOperators = {

    /**
     * Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $and: function (selector, value) {
      if (!_.isArray(value)) {
        throw new Error("Invalid expression for $and criteria");
      }
      var queries = [];
      _.each(value, function (expr) {
        queries.push(new Mingo.Query(expr));
      });

      return {
        test: function (obj) {
          for (var i = 0; i < queries.length; i++) {
            if (!queries[i].test(obj)) {
              return false;
            }
          }
          return true;
        }
      };
    },

    /**
     * Joins query clauses with a logical OR returns all documents that match the conditions of either clause.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $or: function (selector, value) {
      if (!_.isArray(value)) {
        throw new Error("Invalid expression for $or criteria");
      }
      var queries = [];
      _.each(value, function (expr) {
        queries.push(new Mingo.Query(expr));
      });

      return {
        test: function (obj) {
          for (var i = 0; i < queries.length; i++) {
            if (queries[i].test(obj)) {
              return true;
            }
          }
          return false;
        }
      };
    },

    /**
     * Joins query clauses with a logical NOR returns all documents that fail to match both clauses.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $nor: function (selector, value) {
      if (!_.isArray(value)) {
        throw new Error("Invalid expression for $nor criteria");
      }
      var query = this.$or("$or", value);
      return {
        test: function (obj) {
          return !query.test(obj);
        }
      };
    },

    /**
     * Inverts the effect of a query expression and returns documents that do not match the query expression.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $not: function (selector, value) {
      var criteria = {};
      criteria[selector] = normalize(value);
      var query = new Mingo.Query(criteria);
      return {
        test: function (obj) {
          return !query.test(obj);
        }
      };
    },

    /**
     * Matches documents that satisfy a JavaScript expression.
     *
     * @param selector
     * @param value
     * @returns {{test: test}}
     */
    $where: function (selector, value) {
      if (!_.isFunction(value)) {
        value = new Function("return " + value + ";");
      }
      return {
        test: function (obj) {
          return value.call(obj) === true;
        }
      };
    }

  };

  var simpleOperators = {

    /**
     * Checks that two values are equal. Pseudo operator introduced for convenience and consistency
     *
     * @param a
     * @param b
     * @returns {*}
     */
    $eq: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return _.isEqual(val, b);
      });
      return a !== undefined;
    },

    /**
     * Matches all values that are not equal to the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $ne: function (a, b) {
      return !this.$eq(a, b);
    },

    /**
     * Matches any of the values that exist in an array specified in the query.
     *
     * @param a
     * @param b
     * @returns {*}
     */
    $in: function (a, b) {
      a = _.isArray(a) ? a : [a];
      return _.intersection(a, b).length > 0;
    },

    /**
     * Matches values that do not exist in an array specified to the query.
     *
     * @param a
     * @param b
     * @returns {*|boolean}
     */
    $nin: function (a, b) {
      return _.isUndefined(a) || !this.$in(a, b);
    },

    /**
     * Matches values that are less than the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $lt: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val < b
      });
      return a !== undefined;
    },

    /**
     * Matches values that are less than or equal to the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $lte: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val <= b
      });
      return a !== undefined;
    },

    /**
     * Matches values that are greater than the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $gt: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val > b
      });
      return a !== undefined;
    },

    /**
     * Matches values that are greater than or equal to the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $gte: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val >= b
      });
      return a !== undefined;
    },

    /**
     * Performs a modulo operation on the value of a field and selects documents with a specified result.
     *
     * @param a
     * @param b
     * @returns {*|boolean|boolean}
     */
    $mod: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return _.isNumber(val) && _.isArray(b) && b.length === 2 && (val % b[0]) === b[1];
      });
      return a !== undefined;
    },

    /**
     * Selects documents where values match a specified regular expression.
     *
     * @param a
     * @param b
     * @returns {*|boolean}
     */
    $regex: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return _.isString(val) && _.isRegExp(b) && (!!val.match(b));
      });
      return a !== undefined;
    },

    /**
     * Matches documents that have the specified field.
     *
     * @param a
     * @param b
     * @returns {boolean|*|boolean}
     */
    $exists: function (a, b) {
      return (b === false && _.isUndefined(a)) || (b === true && !_.isUndefined(a));
    },

    /**
     * Matches arrays that contain all elements specified in the query.
     *
     * @param a
     * @param b
     * @returns boolean
     */
    $all: function (a, b) {
      var self = this;
      var matched = false;
      if (_.isArray(a) && _.isArray(b)) {
        for (var i = 0; i < b.length; i++) {
          if (_.isObject(b[i]) && _.contains(_.keys(b[i]), "$elemMatch")) {
            matched = matched || self.$elemMatch(a, b[i].$elemMatch);
          } else {
            // order of arguments matter. underscore maintains order after intersection
            return _.intersection(b, a).length === b.length;
          }
        }
      }
      return matched;
    },

    /**
     * Selects documents if the array field is a specified size.
     *
     * @param a
     * @param b
     * @returns {*|boolean}
     */
    $size: function (a, b) {
      return _.isArray(a) && _.isNumber(b) && (a.length === b);
    },

    /**
     * Selects documents if element in the array field matches all the specified $elemMatch condition.
     *
     * @param a
     * @param b
     */
    $elemMatch: function (a, b) {
      if (_.isArray(a) && !_.isEmpty(a)) {
        var query = new Mingo.Query(b);
        for (var i = 0; i < a.length; i++) {
          if (query.test(a[i])) {
            return true;
          }
        }
      }
      return false;
    },

    /**
     * Selects documents if a field is of the specified type.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $type: function (a, b) {
      switch (b) {
        case 1:
          return _.isNumeric(a) && (a + "").indexOf(".") !== -1;
        case 2:
        case 5:
          return _.isString(a);
        case 3:
          return _.isObject(a);
        case 4:
          return _.isArray(a);
        case 8:
          return _.isBoolean(a);
        case 9:
          return _.isDate(a);
        case 10:
          return _.isNull(a);
        case 11:
          return _.isRegExp(a);
        case 16:
          return _.isNumeric(a) && a <= 2147483647 && (a + "").indexOf(".") === -1;
        case 18:
          return _.isNumeric(a) && a > 2147483647 && a <= 9223372036854775807 && (a + "").indexOf(".") === -1;
        default:
          return false;
      }
    }

  };

  var projectionOperators = {

    /**
     * Projects the first element in an array that matches the query condition.
     *
     * @param obj
     * @param field
     * @param expr
     */
    $: function (obj, expr, field) {
      throw new Error("$ not implemented");
    },

    /**
     * Projects only the first element from an array that matches the specified $elemMatch condition.
     *
     * @param obj
     * @param field
     * @param expr
     * @returns {*}
     */
    $elemMatch: function (obj, expr, field) {
      var array = resolve(obj, field);
      var query = new Mingo.Query(expr);

      if (_.isUndefined(array) || !_.isArray(array)) {
        return undefined;
      }

      for (var i = 0; i < array.length; i++) {
        if (query.test(array[i])) {
          return [array[i]];
        }
      }

      return undefined;
    },

    /**
     * Limits the number of elements projected from an array. Supports skip and limit slices.
     *
     * @param obj
     * @param field
     * @param expr
     */
    $slice: function (obj, expr, field) {
      var array = resolve(obj, field);

      if (!_.isArray(array)) {
        return array;
      }
      if (!_.isArray(expr)) {
        if (!_.isNumber(expr)) {
          throw new Error("Invalid type for $slice operator");
      }
        expr = expr < 0 ? [expr] : [0, expr];
      } else {
        // MongoDB $slice works a bit differently from Array.slice
        // Uses single argument for 'limit' and array argument [skip, limit]
        var skip = (expr[0] < 0) ? array.length + expr[0] : expr;
        var limit = skip + expr[1];
        expr = [skip, limit];
      }

      return Array.prototype.slice.apply(array, expr);
    }
  };

  var groupOperators = {

    /**
     * Returns an array of all the unique values for the selected field among for each document in that group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $addToSet: function (collection, expr) {
      var result = _.map(collection, function (obj) {
        return computeValue(obj, expr);
      });
      return _.uniq(result);
    },

    /**
     * Returns the sum of all the values in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $sum: function (collection, expr) {
      if (_.isNumber(expr)) {
        // take a short cut if expr is number literal
        return collection.length * expr;
      }
      return _.reduce(collection, function (acc, obj) {
        // pass empty field to avoid naming conflicts with fields on documents
        return acc + computeValue(obj, expr);
      }, 0);
    },

    /**
     * Returns the highest value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $max: function (collection, expr) {
      var obj = _.max(collection, function (obj) {
        return computeValue(obj, expr);
      });
      return computeValue(obj, expr);
    },

    /**
     * Returns the lowest value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $min: function (collection, expr) {
      var obj = _.min(collection, function (obj) {
        return computeValue(obj, expr);
      });
      return computeValue(obj, expr);
    },

    /**
     * Returns an average of all the values in a group.
     *
     * @param collection
     * @param expr
     * @returns {number}
     */
    $avg: function (collection, expr) {
      return this.$sum(collection, expr) / (collection.length || 1);
    },

    /**
     * Returns an array of all values for the selected field among for each document in that group.
     *
     * @param collection
     * @param expr
     * @returns {Array|*}
     */
    $push: function (collection, expr) {
      return _.map(collection, function (obj) {
        return computeValue(obj, expr);
      });
    },

    /**
     * Returns the first value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $first: function (collection, expr) {
      return (collection.length > 0) ? computeValue(collection[0], expr) : undefined;
    },

    /**
     * Returns the last value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $last: function (collection, expr) {
      return (collection.length > 0) ? computeValue(collection[collection.length - 1], expr) : undefined;
    }
  };


  /////////// Common Aggregation Operators ///////////

  var arithmeticOperators = {

    /**
     * Computes the sum of an array of numbers.
     *
     * @param obj
     * @param expr
     * @returns {Object}
     */
    $add: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.reduce(args, function (memo, num) {
        return memo + num;
      }, 0);
    },

    /**
     * Takes an array that contains two numbers or two dates and subtracts the second value from the first.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $subtract: function (obj, expr) {
      var args = computeValue(obj, expr);
      return args[0] - args[1];
    },

    /**
     * Takes two numbers and divides the first number by the second.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $divide: function (obj, expr) {
      var args = computeValue(obj, expr);
      return args[0] / args[1];
    },

    /**
     * Computes the product of an array of numbers.
     *
     * @param obj
     * @param expr
     * @returns {Object}
     */
    $multiply: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.reduce(args, function (memo, num) {
        return memo * num;
      }, 1);
    },

    /**
     * Takes two numbers and calculates the modulo of the first number divided by the second.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $mod: function (obj, expr) {
      var args = computeValue(obj, expr);
      return args[0] % args[1];
    }
  };

  var stringOperators = {

    /**
     * Concatenates two strings.
     *
     * @param obj
     * @param expr
     * @returns {string|*}
     */
    $concat: function (obj, expr) {
      var args = computeValue(obj, expr);
      // does not allow concatenation with nulls
      if (_.contains(args, null) || _.contains(args, undefined)) {
        return null;
      }
      return args.join("");
    },

    /**
     * Compares two strings and returns an integer that reflects the comparison.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $strcasecmp: function (obj, expr) {
      var args = computeValue(obj, expr);
      args[0] = _.isEmpty(args[0]) ? "" : args[0].toUpperCase();
      args[1] = _.isEmpty(args[1]) ? "" : args[1].toUpperCase();
      if (args[0] > args[1]) {
        return 1;
      }
      return (args[0] < args[1]) ? -1 : 0;
    },

    /**
     * Returns a substring of a string, starting at a specified index position and including the specified number of characters.
     * The index is zero-based.
     *
     * @param obj
     * @param expr
     * @returns {string}
     */
    $substr: function (obj, expr) {
      var args = computeValue(obj, expr);
      if (_.isString(args[0])) {
        if (args[1] < 0) {
          return "";
        } else if (args[2] < 0) {
          return args[0].substr(args[1]);
        } else {
          return args[0].substr(args[1], args[2]);
        }
      }
      return "";
    },

    /**
     * Converts a string to lowercase.
     *
     * @param obj
     * @param expr
     * @returns {string}
     */
    $toLower: function (obj, expr) {
      var value = computeValue(obj, expr);
      return _.isEmpty(value) ? "" : value.toLowerCase();
    },

    /**
     * Converts a string to uppercase.
     *
     * @param obj
     * @param expr
     * @returns {string}
     */
    $toUpper: function (obj, expr) {
      var value = computeValue(obj, expr);
      return _.isEmpty(value) ? "" : value.toUpperCase();
    }
  };

  var dateOperators = {
    /**
     * Returns the day of the year for a date as a number between 1 and 366 (leap year).
     * @param obj
     * @param expr
     */
    $dayOfYear: function (obj, expr) {
      var d = computeValue(obj, expr);
      if (_.isDate(value)) {
        var start = new Date(d.getFullYear(), 0, 0);
        var diff = d - start;
        var oneDay = 1000 * 60 * 60 * 24;
        return Math.round(diff / oneDay);
      }
      return undefined;
    },

    /**
     * Returns the day of the month for a date as a number between 1 and 31.
     * @param obj
     * @param expr
     */
    $dayOfMonth: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getDate() : undefined;
    },

    /**
     * Returns the day of the week for a date as a number between 1 (Sunday) and 7 (Saturday).
     * @param obj
     * @param expr
     */
    $dayOfWeek: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getDay() + 1 : undefined;
    },

    /**
     * Returns the year for a date as a number (e.g. 2014).
     * @param obj
     * @param expr
     */
    $year: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getFullYear() + 1 : undefined;
    },

    /**
     * Returns the month for a date as a number between 1 (January) and 12 (December).
     * @param obj
     * @param expr
     */
    $month: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getMonth() + 1 : undefined;
    },

    /**
     * Returns the week number for a date as a number between 0
     * (the partial week that precedes the first Sunday of the year) and 53 (leap year).
     * @param obj
     * @param expr
     */
    $week: function (obj, expr) {
      var d = computeValue(obj, expr);
      // TODO
      throw new Error("Not Implemented");
    },

    /**
     * Returns the hour for a date as a number between 0 and 23.
     * @param obj
     * @param expr
     */
    $hour: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getHours() : undefined;
    },

    /**
     * Returns the minute for a date as a number between 0 and 59.
     * @param obj
     * @param expr
     */
    $minute: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getMinutes() : undefined;
    },

    /**
     * Returns the seconds for a date as a number between 0 and 60 (leap seconds).
     * @param obj
     * @param expr
     */
    $second: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getSeconds() : undefined;
    },

    /**
     * Returns the milliseconds of a date as a number between 0 and 999.
     * @param obj
     * @param expr
     */
    $millisecond: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getMilliseconds() : undefined;
    },

    /**
     * Returns the date as a formatted string.
     * @param obj
     * @param expr
     */
    $dateToString: function (obj, expr) {
      var fmt = expr['format'];
      var date = computeValue(obj, expr['date']);
      // TODO: use python-style date formatting
      /*
       %Y Year (4 digits, zero padded)  0000-9999
       %m Month (2 digits, zero padded) 01-12
       %d Day of Month (2 digits, zero padded)  01-31
       %H Hour (2 digits, zero padded, 24-hour clock) 00-23
       %M Minute (2 digits, zero padded)  00-59
       %S Second (2 digits, zero padded)  00-60
       %L Millisecond (3 digits, zero padded) 000-999
       %j Day of year (3 digits, zero padded) 001-366
       %w Day of week (1-Sunday, 7-Saturday)  1-7
       %U Week of year (2 digits, zero padded)  00-53
       %% Percent Character as a Literal  %
       */
      throw new Error("Not Implemented");
    }
  };

  var setOperators = {
    /**
     * Returns true if two sets have the same elements.
     * @param obj
     * @param expr
     */
    $setEquals: function (obj, expr) {
      var args = computeValue(obj, expr);
      var first = _.uniq(args[0]);
      var second = _.uniq(args[1]);
      if (first.length !== second.length) {
        return false;
      }
      return _.difference(first, second).length == 0;
    },

    /**
     * Returns the common elements of the input sets.
     * @param obj
     * @param expr
     */
    $setIntersection: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.intersection(args[0], args[1]);
    },

    /**
     * Returns elements of a set that do not appear in a second set.
     * @param obj
     * @param expr
     */
    $setDifference: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.difference(args[0], args[1]);
    },

    /**
     * Returns a set that holds all elements of the input sets.
     * @param obj
     * @param expr
     */
    $setUnion: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.union(args[0], args[1]);
    },

    /**
     * Returns true if all elements of a set appear in a second set.
     * @param obj
     * @param expr
     */
    $setIsSubset: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.intersection(args[0], args[1]).length === args[0].length;
    },

    /**
     * Returns true if any elements of a set evaluate to true, and false otherwise.
     * @param obj
     * @param expr
     */
    $anyElementTrue: function (obj, expr) {
      // mongodb nests the array expression in another
      var args = computeValue(obj, expr)[0];
      for (var i = 0; i < args.length; i++) {
        if (!!args[i])
          return true;
      }
      return false;
    },

    /**
     * Returns true if all elements of a set evaluate to true, and false otherwise.
     * @param obj
     * @param expr
     */
    $allElementsTrue: function (obj, expr) {
      // mongodb nests the array expression in another
      var args = computeValue(obj, expr)[0];
      for (var i = 0; i < args.length; i++) {
        if (!args[i])
          return false;
      }
      return true;
    }
  };

  var conditionalOperators = {

    /**
     * A ternary operator that evaluates one expression,
     * and depending on the result returns the value of one following expressions.
     *
     * @param obj
     * @param expr
     */
    $cond: function (obj, expr) {
      var ifExpr, thenExpr, elseExpr;
      if (_.isArray(expr)) {
        if (expr.length != 3) {
          throw new Error("Invalid arguments for $cond operator");
        }
        ifExpr = expr[0];
        thenExpr = expr[1];
        elseExpr = expr[2];
      } else if (_.isObject(expr)) {
        ifExpr = expr['if'];
        thenExpr = expr['then'];
        elseExpr = expr['else'];
      }
      var condition = computeValue(obj, ifExpr);
      return condition ? computeValue(obj, thenExpr) : computeValue(obj, elseExpr);
    },

    /**
     * Evaluates an expression and returns the first expression if it evaluates to a non-null value.
     * Otherwise, $ifNull returns the second expression's value.
     *
     * @param obj
     * @param expr
     * @returns {*}
     */
    $ifNull: function (obj, expr) {
      if (!_.isArray(expr) || expr.length != 2) {
        throw new Error("Invalid arguments for $ifNull operator");
      }
      var args = computeValue(obj, expr);
      return (args[0] === null || args[0] === undefined) ? args[1] : args[0];
    }
  };

  var comparisonOperators = {
    /**
     * Compares two values and returns the result of the comparison as an integer.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $cmp: function (obj, expr) {
      var args = computeValue(obj, expr);
      if (args[0] > args[1]) {
        return 1;
      }
      return (args[0] < args[1]) ? -1 : 0;
    }
  };

  // combine aggregate operators
  var aggregateOperators = _.extend(
      {},
      arithmeticOperators,
      comparisonOperators,
      conditionalOperators,
      dateOperators,
      setOperators,
      stringOperators
    );

  // mixin comparison operators
  _.each(["$eq", "$ne", "$gt", "$gte", "$lt", "$lte"], function (op) {
    aggregateOperators[op] = function (obj, expr) {
      var args = computeValue(obj, expr);
      return simpleOperators[op](args[0], args[1]);
    };
  });

  var Ops = {
    simpleOperators: _.keys(simpleOperators),
    compoundOperators: _.keys(compoundOperators),
    aggregateOperators: _.keys(aggregateOperators),
    groupOperators: _.keys(groupOperators),
    pipelineOperators: _.keys(pipelineOperators),
    projectionOperators: _.keys(projectionOperators)
  };
  Ops.queryOperators = _.union(Ops.simpleOperators, Ops.compoundOperators);

  /**
   * Returns the result of evaluating a $group operation over a collection
   *
   * @param collection
   * @param field the name of the aggregate operator or field
   * @param expr the expression of the aggregate operator for the field
   * @returns {*}
   */
  function accumulate(collection, field, expr) {
    if (_.contains(Ops.groupOperators, field)) {
      return groupOperators[field](collection, expr);
    }

    if (_.isObject(expr)) {
      var result = {};
      for (var key in expr) {
        if (expr.hasOwnProperty(key)) {
          result[key] = accumulate(collection, key, expr[key]);
          // must run ONLY one group operator per expression
          // if so, return result of the computed value
          if (_.contains(Ops.groupOperators, key)) {
            result = result[key];
            // if there are more keys in expression this is bad
            if (_.keys(expr).length > 1) {
              throw new Error("Invalid $group expression '" + JSON.stringify(expr) + "'");
            }
            break;
          }
        }
      }
      return result;
    }

    return undefined;
  }

  /**
   * Computes the actual value of the expression using the given object as context
   *
   * @param obj the current object from the collection
   * @param expr the expression for the given field
   * @param field the field name (may also be an aggregate operator)
   * @returns {*}
   */
  function computeValue(obj, expr, field) {

    // if the field of the object is a valid operator
    if (_.contains(Ops.aggregateOperators, field)) {
      return aggregateOperators[field](obj, expr);
    }

    // if expr is a variable for an object field
    // field not used in this case
    if (_.isString(expr) && expr.length > 0 && expr[0] === "$") {
      return resolve(obj, expr.slice(1));
    }

    var result;

    if (_.isArray(expr)) {
      result = [];
      for (var i = 0; i < expr.length; i++) {
        result.push(computeValue(obj, expr[i], null));
      }
    } else if (_.isObject(expr)) {
      result = {};
      for (var key in expr) {
        if (expr.hasOwnProperty(key)) {
          result[key] = computeValue(obj, expr[key], key);

          // must run ONLY one aggregate operator per expression
          // if so, return result of the computed value
          if (_.contains(Ops.aggregateOperators, key)) {
            result = result[key];
            // if there are more keys in expression this is bad
            if (_.keys(expr).length > 1) {
              throw new Error("Invalid aggregation expression '" + JSON.stringify(expr) + "'");
            }
            break;
          }
        }
      }
    } else {
      // check and return value if already in a resolved state
      for (var i = 0; i < primitives.length; i++) {
        if (primitives[i](expr)) {
          return expr;
        }
      }
    }

    return result;
  }

}(this));
},{"stream":21,"underscore":41,"util":24}],27:[function(require,module,exports){

/**
 * Module dependencies.
 */

var ops = require('./ops');
var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = filter;
exports.ops = ops;

/**
 * Filters an `obj` by the given `query` for subdocuments.
 *
 * @return {Object|Boolean} false if no match, or matched subdocs
 * @api public
 */

function filter(obj, query){
  obj = obj || {};
  var ret = {};

  for (var key in query) {
    if (!query.hasOwnProperty(key)) continue;

    // search value
    var val = query[key];

    // split the key into prefix and suffix
    var keys = key.split('.');
    var target = obj;
    var prefix, search;
    var matches = [];

    walk_keys:
    for (var i = 0; i < keys.length; i++) {
      target = target[keys[i]];

      switch (type(target)) {
        case 'array':
          // if it's an array subdocument search we stop here
          prefix = keys.slice(0, i + 1).join('.');
          search = keys.slice(i + 1).join('.');

          debug('searching array "%s"', prefix);

          // we special case operators that don't walk the array
          if (val.$size && !search.length) {
            return compare(val, target);
          }

          // walk subdocs
          var subset = ret[prefix] || target;

          for (var ii = 0; ii < subset.length; ii++) {
            if (search.length) {
              var q = {};
              q[search] = val;
              if ('object' == type(subset[ii])) {
                debug('attempting subdoc search with query %j', q);
                if (filter(subset[ii], q)) {
                  // we ignore the ret value of filter
                  if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                    matches.push(subset[ii]);
                  }
                }
              }
            } else {
              debug('performing simple array item search');
              if (compare(val, subset[ii])) {
                if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                  matches.push(subset[ii]);
                }
              }
            }
          }

          if (matches.length) {
            ret[prefix] = ret[prefix] || [];
            ret[prefix].push.apply(ret[prefix], matches);
          }

          // we don't continue the key search
          break walk_keys;

        case 'undefined':
          // if we can't find the key
          return false;

        case 'object':
          if (null != keys[i + 1]) {
            continue;
          } else if (!compare(val, target)) {
            return false;
          }
          break;

        default:
          if (!compare(val, target)) return false;
      }
    }
  }

  return ret;
}

/**
 * Compares the given matcher with the document value.
 *
 * @param {Mixed} matcher
 * @param {Mixed} value
 * @api private
 */

function compare(matcher, val){
  if ('object' != type(matcher)) {
    return eql(matcher, val);
  }

  var keys = object.keys(matcher);
  if ('$' == keys[0][0]) {
    for (var i = 0; i < keys.length; i++) {
      // special case for sub-object matching
      if ('$elemMatch' == keys[i]) {
        return false !== filter(val, matcher.$elemMatch);
      } else {
        if (!ops[keys[i]](matcher[keys[i]], val)) return false;
      }
    }
    return true;
  } else {
    return eql(matcher, val);
  }
}

},{"./ops":38,"component-type":30,"debug":31,"dot-component":34,"mongo-eql":36,"object-component":37}],28:[function(require,module,exports){

/**
 * Module dependencies.
 */

var mods = require('./mods');
var filter = require('./filter');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = query;

/**
 * Export filter helper.
 */

exports.filter = filter;

/**
 * Export modifiers.
 */

exports.mods = mods;

/**
 * Execute a query.
 *
 * Options:
 *  - `strict` only modify if query matches
 *
 * @param {Object} object to alter
 * @param {Object} query to filter modifications by
 * @param {Object} update object
 * @param {Object} options
 */

function query(obj, query, update, opts){
  obj = obj || {};
  opts = opts || {};
  query = query || {};
  update = update || {};

  // strict mode
  var strict = !!opts.strict;

  var match;
  var log = [];

  if (object.length(query)) {
    match = filter(obj, query);
  }

  if (!strict || false !== match) {
    var keys = object.keys(update);
    var transactions = [];

    for (var i = 0, l = keys.length; i < l; i++) {
      if (mods[keys[i]]) {
        debug('found modifier "%s"', keys[i]);
        for (var key in update[keys[i]]) {
          var pos = key.indexOf('.$.');

          if (~pos) {
            var prefix = key.substr(0, pos);
            var suffix = key.substr(pos + 3);

            if (match[prefix]) {
              debug('executing "%s" %s on first match within "%s"', key, keys[i], prefix);
              var fn = mods[keys[i]](match[prefix][0], suffix, update[keys[i]][key]);
              if (fn) {
                // produce a key name replacing $ with the actual index
                // TODO: this is unnecessarily expensive
                var index = dot.get(obj, prefix).indexOf(match[prefix][0]);
                fn.key = prefix + '.' + index + '.' + suffix;
                fn.op = keys[i];
                transactions.push(fn);
              }
            } else {
              debug('ignoring "%s" %s - no matches within "%s"', key, keys[i], prefix);
            }
          } else {
            var fn = mods[keys[i]](obj, key, update[keys[i]][key]);
            if (fn) {
              fn.key = key;
              fn.op = keys[i];
              transactions.push(fn);
            }
          }
        }
      } else {
        debug('skipping unknown modifier "%s"', keys[i]);
      }
    }

    if (transactions.length) {
      // if we got here error free we process all transactions
      for (var i = 0; i < transactions.length; i++) {
        var fn = transactions[i];
        var val = fn();
        log.push({ op: fn.op, key: fn.key, value: val });
      }
    }
  } else {
    debug('no matches for query %j', query);
  }

  return log;
}

},{"./filter":27,"./mods":29,"component-type":30,"debug":31,"dot-component":34,"object-component":37}],29:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var keys = require('object-component').keys;
var debug = require('debug')('mongo-query');

/**
 * Performs a `$set`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$set = function $set(obj, path, val){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path, true);

  switch (type(obj)) {
    case 'object':
      if (!eql(obj[key], val)) {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (numeric(key)) {
        if (!eql(obj[key], val)) {
          return function(){
            obj[key] = val;
            return val;
          };
        }
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('$set only supports object not ' + type(obj));
  }
};

/**
 * Performs an `$unset`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$unset = function $unset(obj, path){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path);

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        return function(){
          // reminder: `delete arr[1]` === `delete arr['1']` [!]
          delete obj[key];
        };
      } else {
        // we fail silently
        debug('ignoring unset of inexisting key');
      }
  }
};

/**
 * Performs a `$rename`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$rename = function $rename(obj, path, newKey){
  // target = source
  if (path == newKey) {
    throw new Error('$rename source must differ from target');
  }

  // target is parent of source
  if (0 === path.indexOf(newKey + '.')) {
    throw new Error('$rename target may not be a parent of source');
  }

  var p = dot.parent(obj, path);
  var t = type(p);

  if ('object' == t) {
    var key = path.split('.').pop();

    if (p.hasOwnProperty(key)) {
      return function(){
        var val = p[key];
        delete p[key];

        // target does initialize the path
        var newp = dot.parent(obj, newKey, true);

        // and also fails silently upon type mismatch
        if ('object' == type(newp)) {
          newp[newKey.split('.').pop()] = val;
        } else {
          debug('invalid $rename target path type');
        }

        // returns the name of the new key
        return newKey;
      };
    } else {
      debug('ignoring rename from inexisting source');
    }
  } else if ('undefined' != t) {
    throw new Error('$rename source field invalid');
  }
};

/**
 * Performs an `$inc`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$inc = function $inc(obj, path, inc){
  if ('number' != type(inc)) {
    throw new Error('Modifier $inc allowed for numbers only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('number' != type(obj[key])) {
          throw new Error('Cannot apply $inc modifier to non-number');
        }

        return function(){
          obj[key] += inc;
          return inc;
        };
      } else if('object' == type(obj) || numeric(key)){
        return function(){
          obj[key] = inc;
          return inc;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('Cannot apply $inc modifier to non-number');
  }
};

/**
 * Performs an `$pop`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$pop = function $pop(obj, path, val){
  obj = dot.parent(obj, path);
  var key = path.split('.').pop();

  // we make sure the array is not just the parent of the main key
  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        switch (type(obj[key])) {
          case 'array':
            if (obj[key].length) {
              return function(){
                if (-1 == val) {
                  return obj[key].shift();
                } else {
                  // mongodb allows any value to pop
                  return obj[key].pop();
                }
              };
            }
            break;

          case 'undefined':
            debug('ignoring pop to inexisting key');
            break;

          default:
            throw new Error('Cannot apply $pop modifier to non-array');
        }
      } else {
        debug('ignoring pop to inexisting key');
      }
      break;

    case 'undefined':
      debug('ignoring pop to inexisting key');
      break;
  }
};

/**
 * Performs a `$push`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @return {Function} transaction (unless noop)
 */

exports.$push = function $push(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pushAll`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Array} values to push
 * @return {Function} transaction (unless noop)
 */

exports.$pushAll = function $pushAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = val;
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pull`.
 */

exports.$pull = function $pull(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$pullAll`.
 */

exports.$pullAll = function $pullAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$addToSet`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @param {Boolean} internal, true if recursing
 * @return {Function} transaction (unless noop)
 */

exports.$addToSet = function $addToSet(obj, path, val, recursing){
  if (!recursing && 'array' == type(val.$each)) {
    var fns = [];
    for (var i = 0, l = val.$each.length; i < l; i++) {
      var fn = $addToSet(obj, path, val.$each[i], true);
      if (fn) fns.push(fn);
    }
    if (fns.length) {
      return function(){
        var values = [];
        for (var i = 0; i < fns.length; i++) values.push(fns[i]());
        return values;
      };
    } else {
      return;
    }
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Helper for determining if an array has the given value.
 *
 * @param {Array} array
 * @param {Object} value to check
 * @return {Boolean}
 */

function has(array, val){
  for (var i = 0, l = array.length; i < l; i++) {
    if (eql(val, array[i])) return true;
  }
  return false;
}

/**
 * Array#filter function generator for `$pull`/`$pullAll` operations.
 *
 * @param {Array} array of values to match
 * @param {Array} array to populate with results
 * @return {Function} that splices the array
 */

function pull(arr, vals, pulled){
  var indexes = [];

  for (var a = 0; a < arr.length; a++) {
    var val = arr[a];

    for (var i = 0; i < vals.length; i++) {
      var matcher = vals[i];
      if ('object' == type(matcher)) {
        // we only are only interested in obj <-> obj comparisons
        if ('object' == type(val)) {
          var match = false;

          if (keys(matcher).length) {
            for (var i in matcher) {
              if (matcher.hasOwnProperty(i)) {
                // we need at least one matching key to pull
                if (eql(matcher[i], val[i])) {
                  match = true;
                } else {
                  // if a single key doesn't match we move on
                  match = false;
                  break;
                }
              }
            }
          } else if (!keys(val).length) {
            // pull `{}` matches [{}]
            match = true;
          }

          if (match) {
            indexes.push(a);
            pulled.push(val);
            continue;
          }
        } else {
          debug('ignoring pull match against object');
        }
      } else {
        if (eql(matcher, val)) {
          indexes.push(a);
          pulled.push(val);
          continue;
        }
      }
    }
  }

  return function(){
    for (var i = 0; i < indexes.length; i++) {
      var index = indexes[i];
      arr.splice(index - i, 1);
    }
  };
}

/**
 * Helper to determine if a value is numeric.
 *
 * @param {String|Number} value
 * @return {Boolean} true if numeric
 * @api private
 */

function numeric(val){
  return 'number' == type(val) || Number(val) == val;
}

},{"component-type":30,"debug":31,"dot-component":34,"mongo-eql":36,"object-component":37}],30:[function(require,module,exports){
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  val = val.valueOf
    ? val.valueOf()
    : Object.prototype.valueOf.apply(val)

  return typeof val;
};

},{}],31:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":32}],32:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":33}],33:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],34:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('type-component');

/**
 * Gets a certain `path` from the `obj`.
 *
 * @param {Object} target
 * @param {String} key
 * @return {Object} found object, or `undefined
 * @api public
 */

exports.get = function(obj, path){
  if (~path.indexOf('.')) {
    var par = parent(obj, path);
    var mainKey = path.split('.').pop();
    var t = type(par);
    if ('object' == t || 'array' == t) return par[mainKey];
  } else {
    return obj[path];
  }
};

/**
 * Sets the given `path` to `val` in `obj`.
 *
 * @param {Object} target
 * @Param {String} key
 * @param {Object} value
 * @api public
 */

exports.set = function(obj, path, val){
  if (~path.indexOf('.')) {
    var par = parent(obj, path, true);
    var mainKey = path.split('.').pop();
    if (par && 'object' == type(par)) par[mainKey] = val;
  } else {
    obj[path] = val;
  }
};

/**
 * Gets the parent object for a given key (dot notation aware).
 *
 * - If a parent object doesn't exist, it's initialized.
 * - Array index lookup is supported
 *
 * @param {Object} target object
 * @param {String} key
 * @param {Boolean} true if it should initialize the path
 * @api public
 */

exports.parent = parent;

function parent(obj, key, init){
  if (~key.indexOf('.')) {
    var pieces = key.split('.');
    var ret = obj;

    for (var i = 0; i < pieces.length - 1; i++) {
      // if the key is a number string and parent is an array
      if (Number(pieces[i]) == pieces[i] && 'array' == type(ret)) {
        ret = ret[pieces[i]];
      } else if ('object' == type(ret)) {
        if (init && !ret.hasOwnProperty(pieces[i])) {
          ret[pieces[i]] = {};
        }
        if (ret) ret = ret[pieces[i]];
      }
    }

    return ret;
  } else {
    return obj;
  }
}

},{"type-component":35}],35:[function(require,module,exports){

/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function';
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val === Object(val)) return 'object';

  return typeof val;
};

},{}],36:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('component-type');

/**
 * Module exports.
 */

module.exports = eql;

/**
 * MongoDB style value comparisons.
 *
 * @param {Object} matcher
 * @param {Object} value
 * @return {Boolean} true if they match
 */

function eql(matcher, val){
  switch (type(matcher)) {
    case 'null':
    case 'undefined':
      // we treat null as undefined
      return null == val;

    case 'regexp':
      return matcher.test(val);

    case 'array':
      if ('array' == type(val) && matcher.length == val.length) {
        for (var i = 0; i < matcher.length; i++) {
          if (!eql(val[i], matcher[i])) return false;
        }
        return true;
      } else {
        return false;
      }
      break;

    case 'object':
      // object can match keys in any order
      var keys = {};

      // we match all values of `matcher` in `val`
      for (var i in matcher) {
        if (matcher.hasOwnProperty(i)) {
          if (!val.hasOwnProperty(i) || !eql(matcher[i], val[i])) {
            return false;
          }
        }
        keys[i] = true;
      }

      // we make sure `val` doesn't have extra keys
      for (var i in val) {
        if (val.hasOwnProperty(i) && !keys.hasOwnProperty(i)) {
          return false;
        }
      }

      return true;

    default:
      return matcher === val;
  }
}

},{"component-type":30}],37:[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],38:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var type = require('component-type');

/**
 * $ne: not equal.
 */

exports.$ne = function $ne(matcher, val){
  return !eql(matcher, val);
};

/**
 * $gt: greater than.
 */

exports.$gt = function $gt(matcher, val){
  return type(matcher) === 'number' && val > matcher;
};

/**
 * $gte: greater than equal.
 */

exports.$gte = function $gte(matcher, val){
  return type(matcher) === 'number' && val >= matcher;
};

/**
 * $lt: less than.
 */

exports.$lt = function $lt(matcher, val){
  return type(matcher) === 'number' && val < matcher;
};

/**
 * $lte: less than equal.
 */

exports.$lte = function $lte(matcher, val){
  return type(matcher) === 'number' && val <= matcher;
};

/**
 * $regex: supply a regular expression as a string.
 */

exports.$regex = function $regex(matcher, val){
  // TODO: add $options support
  if ('regexp' != type('matcher')) matcher = new RegExp(matcher);
  return matcher.test(val);
};

/**
 * $exists: key exists.
 */

exports.$exists = function $exists(matcher, val){
  if (matcher) {
    return undefined !== val;
  } else {
    return undefined === val;
  }
};

/**
 * $in: value in array.
 */

exports.$in = function $in(matcher, val){
  if ('array' != type(matcher)) return false;
  for (var i = 0; i < matcher.length; i++) {
    if (eql(matcher[i], val)) return true;
  }
  return false;
};

/**
 * $nin: value not in array.
 */

exports.$nin = function $nin(matcher, val){
  return !exports.$in(matcher, val);
};

/**
 * @size: array length
 */

exports.$size = function(matcher, val){
  return Array.isArray(val) && matcher == val.length;
};

},{"component-type":30,"mongo-eql":36}],39:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2014
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var win = window
    , doc = document
    , httpsRe = /^http/
    , protocolRe = /(^\w+):\/\//
    , twoHundo = /^(20\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
    , byTag = 'getElementsByTagName'
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , head = doc[byTag]('head')[0]
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (win[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function succeed(r) {
    var protocol = protocolRe.exec(r.url);
    protocol = (protocol && protocol[1]) || window.location.protocol;
    return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response;
  }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r._timedOut) return error(r.request, 'Request is aborted: timeout')
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (succeed(r)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    var isAFormData = typeof FormData === 'function' && (o['data'] instanceof FormData);
    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType] && !isAFormData) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    win[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        timedOut()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || resp && setType(resp.getResponseHeader('Content-Type')) // resp can be undefined in IE
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function timedOut() {
      self._timedOut = true
      self.request.abort()      
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  , 'catch': function (fn) {
      return this.fail(fn)
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{}],40:[function(require,module,exports){
(function (process){
/*!
 * @overview RSVP - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
 * @version   3.0.18
 */

(function() {
    "use strict";
    function lib$rsvp$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$rsvp$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$rsvp$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$rsvp$utils$$_isArray;
    if (!Array.isArray) {
      lib$rsvp$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$rsvp$utils$$_isArray = Array.isArray;
    }

    var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;

    var lib$rsvp$utils$$now = Date.now || function() { return new Date().getTime(); };

    function lib$rsvp$utils$$F() { }

    var lib$rsvp$utils$$o_create = (Object.create || function (o) {
      if (arguments.length > 1) {
        throw new Error('Second argument not supported');
      }
      if (typeof o !== 'object') {
        throw new TypeError('Argument must be an object');
      }
      lib$rsvp$utils$$F.prototype = o;
      return new lib$rsvp$utils$$F();
    });
    function lib$rsvp$events$$indexOf(callbacks, callback) {
      for (var i=0, l=callbacks.length; i<l; i++) {
        if (callbacks[i] === callback) { return i; }
      }

      return -1;
    }

    function lib$rsvp$events$$callbacksFor(object) {
      var callbacks = object._promiseCallbacks;

      if (!callbacks) {
        callbacks = object._promiseCallbacks = {};
      }

      return callbacks;
    }

    var lib$rsvp$events$$default = {

      /**
        `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For
        Example:

        ```javascript
        var object = {};

        RSVP.EventTarget.mixin(object);

        object.on('finished', function(event) {
          // handle event
        });

        object.trigger('finished', { detail: value });
        ```

        `EventTarget.mixin` also works with prototypes:

        ```javascript
        var Person = function() {};
        RSVP.EventTarget.mixin(Person.prototype);

        var yehuda = new Person();
        var tom = new Person();

        yehuda.on('poke', function(event) {
          console.log('Yehuda says OW');
        });

        tom.on('poke', function(event) {
          console.log('Tom says OW');
        });

        yehuda.trigger('poke');
        tom.trigger('poke');
        ```

        @method mixin
        @for RSVP.EventTarget
        @private
        @param {Object} object object to extend with EventTarget methods
      */
      'mixin': function(object) {
        object['on']      = this['on'];
        object['off']     = this['off'];
        object['trigger'] = this['trigger'];
        object._promiseCallbacks = undefined;
        return object;
      },

      /**
        Registers a callback to be executed when `eventName` is triggered

        ```javascript
        object.on('event', function(eventInfo){
          // handle the event
        });

        object.trigger('event');
        ```

        @method on
        @for RSVP.EventTarget
        @private
        @param {String} eventName name of the event to listen for
        @param {Function} callback function to be called when the event is triggered.
      */
      'on': function(eventName, callback) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks;

        callbacks = allCallbacks[eventName];

        if (!callbacks) {
          callbacks = allCallbacks[eventName] = [];
        }

        if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {
          callbacks.push(callback);
        }
      },

      /**
        You can use `off` to stop firing a particular callback for an event:

        ```javascript
        function doStuff() { // do stuff! }
        object.on('stuff', doStuff);

        object.trigger('stuff'); // doStuff will be called

        // Unregister ONLY the doStuff callback
        object.off('stuff', doStuff);
        object.trigger('stuff'); // doStuff will NOT be called
        ```

        If you don't pass a `callback` argument to `off`, ALL callbacks for the
        event will not be executed when the event fires. For example:

        ```javascript
        var callback1 = function(){};
        var callback2 = function(){};

        object.on('stuff', callback1);
        object.on('stuff', callback2);

        object.trigger('stuff'); // callback1 and callback2 will be executed.

        object.off('stuff');
        object.trigger('stuff'); // callback1 and callback2 will not be executed!
        ```

        @method off
        @for RSVP.EventTarget
        @private
        @param {String} eventName event to stop listening to
        @param {Function} callback optional argument. If given, only the function
        given will be removed from the event's callback queue. If no `callback`
        argument is given, all callbacks will be removed from the event's callback
        queue.
      */
      'off': function(eventName, callback) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, index;

        if (!callback) {
          allCallbacks[eventName] = [];
          return;
        }

        callbacks = allCallbacks[eventName];

        index = lib$rsvp$events$$indexOf(callbacks, callback);

        if (index !== -1) { callbacks.splice(index, 1); }
      },

      /**
        Use `trigger` to fire custom events. For example:

        ```javascript
        object.on('foo', function(){
          console.log('foo event happened!');
        });
        object.trigger('foo');
        // 'foo event happened!' logged to the console
        ```

        You can also pass a value as a second argument to `trigger` that will be
        passed as an argument to all event listeners for the event:

        ```javascript
        object.on('foo', function(value){
          console.log(value.name);
        });

        object.trigger('foo', { name: 'bar' });
        // 'bar' logged to the console
        ```

        @method trigger
        @for RSVP.EventTarget
        @private
        @param {String} eventName name of the event to be triggered
        @param {Any} options optional value to be passed to any event handlers for
        the given `eventName`
      */
      'trigger': function(eventName, options) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, callback;

        if (callbacks = allCallbacks[eventName]) {
          // Don't cache the callbacks.length since it may grow
          for (var i=0; i<callbacks.length; i++) {
            callback = callbacks[i];

            callback(options);
          }
        }
      }
    };

    var lib$rsvp$config$$config = {
      instrument: false
    };

    lib$rsvp$events$$default['mixin'](lib$rsvp$config$$config);

    function lib$rsvp$config$$configure(name, value) {
      if (name === 'onerror') {
        // handle for legacy users that expect the actual
        // error to be passed to their function added via
        // `RSVP.configure('onerror', someFunctionHere);`
        lib$rsvp$config$$config['on']('error', value);
        return;
      }

      if (arguments.length === 2) {
        lib$rsvp$config$$config[name] = value;
      } else {
        return lib$rsvp$config$$config[name];
      }
    }

    var lib$rsvp$instrument$$queue = [];

    function lib$rsvp$instrument$$scheduleFlush() {
      setTimeout(function() {
        var entry;
        for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {
          entry = lib$rsvp$instrument$$queue[i];

          var payload = entry.payload;

          payload.guid = payload.key + payload.id;
          payload.childGuid = payload.key + payload.childId;
          if (payload.error) {
            payload.stack = payload.error.stack;
          }

          lib$rsvp$config$$config['trigger'](entry.name, entry.payload);
        }
        lib$rsvp$instrument$$queue.length = 0;
      }, 50);
    }

    function lib$rsvp$instrument$$instrument(eventName, promise, child) {
      if (1 === lib$rsvp$instrument$$queue.push({
          name: eventName,
          payload: {
            key: promise._guidKey,
            id:  promise._id,
            eventName: eventName,
            detail: promise._result,
            childId: child && child._id,
            label: promise._label,
            timeStamp: lib$rsvp$utils$$now(),
            error: lib$rsvp$config$$config["instrument-with-stack"] ? new Error(promise._label) : null
          }})) {
            lib$rsvp$instrument$$scheduleFlush();
          }
      }
    var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;

    function  lib$rsvp$$internal$$withOwnPromise() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$rsvp$$internal$$noop() {}

    var lib$rsvp$$internal$$PENDING   = void 0;
    var lib$rsvp$$internal$$FULFILLED = 1;
    var lib$rsvp$$internal$$REJECTED  = 2;

    var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();

    function lib$rsvp$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$rsvp$$internal$$GET_THEN_ERROR.error = error;
        return lib$rsvp$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {
      lib$rsvp$config$$config.async(function(promise) {
        var sealed = false;
        var error = lib$rsvp$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$rsvp$$internal$$resolve(promise, value);
          } else {
            lib$rsvp$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$rsvp$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$rsvp$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$rsvp$$internal$$FULFILLED) {
        lib$rsvp$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {
        thenable._onError = null;
        lib$rsvp$$internal$$reject(promise, thenable._result);
      } else {
        lib$rsvp$$internal$$subscribe(thenable, undefined, function(value) {
          if (thenable !== value) {
            lib$rsvp$$internal$$resolve(promise, value);
          } else {
            lib$rsvp$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          lib$rsvp$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$rsvp$$internal$$getThen(maybeThenable);

        if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {
          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$rsvp$utils$$isFunction(then)) {
          lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$rsvp$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$rsvp$$internal$$fulfill(promise, value);
      } else if (lib$rsvp$utils$$objectOrFunction(value)) {
        lib$rsvp$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$rsvp$$internal$$fulfill(promise, value);
      }
    }

    function lib$rsvp$$internal$$publishRejection(promise) {
      if (promise._onError) {
        promise._onError(promise._result);
      }

      lib$rsvp$$internal$$publish(promise);
    }

    function lib$rsvp$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$rsvp$$internal$$FULFILLED;

      if (promise._subscribers.length === 0) {
        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('fulfilled', promise);
        }
      } else {
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);
      }
    }

    function lib$rsvp$$internal$$reject(promise, reason) {
      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }
      promise._state = lib$rsvp$$internal$$REJECTED;
      promise._result = reason;
      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);
    }

    function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onError = null;

      subscribers[length] = child;
      subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$rsvp$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);
      }
    }

    function lib$rsvp$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (lib$rsvp$config$$config.instrument) {
        lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);
      }

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$rsvp$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();

    function lib$rsvp$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$rsvp$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$rsvp$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$rsvp$$internal$$tryCatch(callback, detail);

        if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$rsvp$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$rsvp$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$rsvp$$internal$$reject(promise, error);
      } else if (settled === lib$rsvp$$internal$$FULFILLED) {
        lib$rsvp$$internal$$fulfill(promise, value);
      } else if (settled === lib$rsvp$$internal$$REJECTED) {
        lib$rsvp$$internal$$reject(promise, value);
      }
    }

    function lib$rsvp$$internal$$initializePromise(promise, resolver) {
      var resolved = false;
      try {
        resolver(function resolvePromise(value){
          if (resolved) { return; }
          resolved = true;
          lib$rsvp$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          if (resolved) { return; }
          resolved = true;
          lib$rsvp$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$rsvp$$internal$$reject(promise, e);
      }
    }

    function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {
      if (state === lib$rsvp$$internal$$FULFILLED) {
        return {
          state: 'fulfilled',
          value: value
        };
      } else {
        return {
          state: 'rejected',
          reason: value
        };
      }
    }

    function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor(lib$rsvp$$internal$$noop, label);
      this._abortOnReject = abortOnReject;

      if (this._validateInput(input)) {
        this._input     = input;
        this.length     = input.length;
        this._remaining = input.length;

        this._init();

        if (this.length === 0) {
          lib$rsvp$$internal$$fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate();
          if (this._remaining === 0) {
            lib$rsvp$$internal$$fulfill(this.promise, this._result);
          }
        }
      } else {
        lib$rsvp$$internal$$reject(this.promise, this._validationError());
      }
    }

    var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;

    lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$rsvp$utils$$isArray(input);
    };

    lib$rsvp$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$rsvp$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function() {
      var length  = this.length;
      var promise = this.promise;
      var input   = this._input;

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        this._eachEntry(input[i], i);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var c = this._instanceConstructor;
      if (lib$rsvp$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$rsvp$$internal$$PENDING) {
          entry._onError = null;
          this._settledAt(entry._state, i, entry._result);
        } else {
          this._willSettleAt(c.resolve(entry), i);
        }
      } else {
        this._remaining--;
        this._result[i] = this._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var promise = this.promise;

      if (promise._state === lib$rsvp$$internal$$PENDING) {
        this._remaining--;

        if (this._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {
          lib$rsvp$$internal$$reject(promise, value);
        } else {
          this._result[i] = this._makeResult(state, i, value);
        }
      }

      if (this._remaining === 0) {
        lib$rsvp$$internal$$fulfill(promise, this._result);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
      return value;
    };

    lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$rsvp$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);
      });
    };
    function lib$rsvp$promise$all$$all(entries, label) {
      return new lib$rsvp$enumerator$$default(this, entries, true /* abort on reject */, label).promise;
    }
    var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;
    function lib$rsvp$promise$race$$race(entries, label) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$rsvp$$internal$$noop, label);

      if (!lib$rsvp$utils$$isArray(entries)) {
        lib$rsvp$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$rsvp$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$rsvp$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;
    function lib$rsvp$promise$resolve$$resolve(object, label) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
      lib$rsvp$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;
    function lib$rsvp$promise$reject$$reject(reason, label) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
      lib$rsvp$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;

    var lib$rsvp$promise$$guidKey = 'rsvp_' + lib$rsvp$utils$$now() + '-';
    var lib$rsvp$promise$$counter = 0;

    function lib$rsvp$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$rsvp$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise’s eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class RSVP.Promise
      @param {function} resolver
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @constructor
    */
    function lib$rsvp$promise$$Promise(resolver, label) {
      this._id = lib$rsvp$promise$$counter++;
      this._label = label;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$rsvp$config$$config.instrument) {
        lib$rsvp$instrument$$default('created', this);
      }

      if (lib$rsvp$$internal$$noop !== resolver) {
        if (!lib$rsvp$utils$$isFunction(resolver)) {
          lib$rsvp$promise$$needsResolver();
        }

        if (!(this instanceof lib$rsvp$promise$$Promise)) {
          lib$rsvp$promise$$needsNew();
        }

        lib$rsvp$$internal$$initializePromise(this, resolver);
      }
    }

    var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise;

    // deprecated
    lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;
    lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;
    lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;
    lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;
    lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;

    lib$rsvp$promise$$Promise.prototype = {
      constructor: lib$rsvp$promise$$Promise,

      _guidKey: lib$rsvp$promise$$guidKey,

      _onError: function (reason) {
        lib$rsvp$config$$config.async(function(promise) {
          setTimeout(function() {
            if (promise._onError) {
              lib$rsvp$config$$config['trigger']('error', reason);
            }
          }, 0);
        }, this);
      },

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection, label) {
        var parent = this;
        var state = parent._state;

        if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {
          if (lib$rsvp$config$$config.instrument) {
            lib$rsvp$instrument$$default('chained', this, this);
          }
          return this;
        }

        parent._onError = null;

        var child = new this.constructor(lib$rsvp$$internal$$noop, label);
        var result = parent._result;

        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('chained', parent, child);
        }

        if (state) {
          var callback = arguments[state - 1];
          lib$rsvp$config$$config.async(function(){
            lib$rsvp$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection, label) {
        return this.then(null, onRejection, label);
      },

    /**
      `finally` will be invoked regardless of the promise's fate just as native
      try/catch/finally behaves

      Synchronous example:

      ```js
      findAuthor() {
        if (Math.random() > 0.5) {
          throw new Error();
        }
        return new Author();
      }

      try {
        return findAuthor(); // succeed or fail
      } catch(error) {
        return findOtherAuther();
      } finally {
        // always runs
        // doesn't affect the return value
      }
      ```

      Asynchronous example:

      ```js
      findAuthor().catch(function(reason){
        return findOtherAuther();
      }).finally(function(){
        // author was either found, or not
      });
      ```

      @method finally
      @param {Function} callback
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      'finally': function(callback, label) {
        var constructor = this.constructor;

        return this.then(function(value) {
          return constructor.resolve(callback()).then(function(){
            return value;
          });
        }, function(reason) {
          return constructor.resolve(callback()).then(function(){
            throw reason;
          });
        }, label);
      }
    };

    function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {
      this._superConstructor(Constructor, entries, false /* don't abort on reject */, label);
    }

    lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
    lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;
    lib$rsvp$all$settled$$AllSettled.prototype._validationError = function() {
      return new Error('allSettled must be called with an array');
    };

    function lib$rsvp$all$settled$$allSettled(entries, label) {
      return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;
    }
    var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;
    function lib$rsvp$all$$all(array, label) {
      return lib$rsvp$promise$$default.all(array, label);
    }
    var lib$rsvp$all$$default = lib$rsvp$all$$all;
    var lib$rsvp$asap$$len = 0;
    var lib$rsvp$asap$$toString = {}.toString;
    var lib$rsvp$asap$$vertxNext;
    function lib$rsvp$asap$$asap(callback, arg) {
      lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;
      lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;
      lib$rsvp$asap$$len += 2;
      if (lib$rsvp$asap$$len === 2) {
        // If len is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        lib$rsvp$asap$$scheduleFlush();
      }
    }

    var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;

    var lib$rsvp$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};
    var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;
    var lib$rsvp$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$rsvp$asap$$useNextTick() {
      var nextTick = process.nextTick;
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // setImmediate should be used instead instead
      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
        nextTick = setImmediate;
      }
      return function() {
        nextTick(lib$rsvp$asap$$flush);
      };
    }

    // vertx
    function lib$rsvp$asap$$useVertxTimer() {
      return function() {
        lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);
      };
    }

    function lib$rsvp$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$rsvp$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$rsvp$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$rsvp$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$rsvp$asap$$flush, 1);
      };
    }

    var lib$rsvp$asap$$queue = new Array(1000);
    function lib$rsvp$asap$$flush() {
      for (var i = 0; i < lib$rsvp$asap$$len; i+=2) {
        var callback = lib$rsvp$asap$$queue[i];
        var arg = lib$rsvp$asap$$queue[i+1];

        callback(arg);

        lib$rsvp$asap$$queue[i] = undefined;
        lib$rsvp$asap$$queue[i+1] = undefined;
      }

      lib$rsvp$asap$$len = 0;
    }

    function lib$rsvp$asap$$attemptVertex() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$rsvp$asap$$useVertxTimer();
      } catch(e) {
        return lib$rsvp$asap$$useSetTimeout();
      }
    }

    var lib$rsvp$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$rsvp$asap$$isNode) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();
    } else if (lib$rsvp$asap$$BrowserMutationObserver) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();
    } else if (lib$rsvp$asap$$isWorker) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();
    } else if (lib$rsvp$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();
    } else {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();
    }
    function lib$rsvp$defer$$defer(label) {
      var deferred = { };

      deferred['promise'] = new lib$rsvp$promise$$default(function(resolve, reject) {
        deferred['resolve'] = resolve;
        deferred['reject'] = reject;
      }, label);

      return deferred;
    }
    var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;
    function lib$rsvp$filter$$filter(promises, filterFn, label) {
      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
        if (!lib$rsvp$utils$$isFunction(filterFn)) {
          throw new TypeError("You must pass a function as filter's second argument.");
        }

        var length = values.length;
        var filtered = new Array(length);

        for (var i = 0; i < length; i++) {
          filtered[i] = filterFn(values[i]);
        }

        return lib$rsvp$promise$$default.all(filtered, label).then(function(filtered) {
          var results = new Array(length);
          var newLength = 0;

          for (var i = 0; i < length; i++) {
            if (filtered[i]) {
              results[newLength] = values[i];
              newLength++;
            }
          }

          results.length = newLength;

          return results;
        });
      });
    }
    var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;

    function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {
      this._superConstructor(Constructor, object, true, label);
    }

    var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;

    lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
    lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$promise$hash$$PromiseHash.prototype._init = function() {
      this._result = {};
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function(input) {
      return input && typeof input === 'object';
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function() {
      return new Error('Promise.hash must be called with an object');
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function() {
      var promise = this.promise;
      var input   = this._input;
      var results = [];

      for (var key in input) {
        if (promise._state === lib$rsvp$$internal$$PENDING && Object.prototype.hasOwnProperty.call(input, key)) {
          results.push({
            position: key,
            entry: input[key]
          });
        }
      }

      var length = results.length;
      this._remaining = length;
      var result;

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        result = results[i];
        this._eachEntry(result.entry, result.position);
      }
    };

    function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {
      this._superConstructor(Constructor, object, false, label);
    }

    lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);
    lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;

    lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {
      return new Error('hashSettled must be called with an object');
    };

    function lib$rsvp$hash$settled$$hashSettled(object, label) {
      return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;
    }
    var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;
    function lib$rsvp$hash$$hash(object, label) {
      return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;
    }
    var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;
    function lib$rsvp$map$$map(promises, mapFn, label) {
      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
        if (!lib$rsvp$utils$$isFunction(mapFn)) {
          throw new TypeError("You must pass a function as map's second argument.");
        }

        var length = values.length;
        var results = new Array(length);

        for (var i = 0; i < length; i++) {
          results[i] = mapFn(values[i]);
        }

        return lib$rsvp$promise$$default.all(results, label);
      });
    }
    var lib$rsvp$map$$default = lib$rsvp$map$$map;

    function lib$rsvp$node$$Result() {
      this.value = undefined;
    }

    var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();
    var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();

    function lib$rsvp$node$$getThen(obj) {
      try {
       return obj.then;
      } catch(error) {
        lib$rsvp$node$$ERROR.value= error;
        return lib$rsvp$node$$ERROR;
      }
    }


    function lib$rsvp$node$$tryApply(f, s, a) {
      try {
        f.apply(s, a);
      } catch(error) {
        lib$rsvp$node$$ERROR.value = error;
        return lib$rsvp$node$$ERROR;
      }
    }

    function lib$rsvp$node$$makeObject(_, argumentNames) {
      var obj = {};
      var name;
      var i;
      var length = _.length;
      var args = new Array(length);

      for (var x = 0; x < length; x++) {
        args[x] = _[x];
      }

      for (i = 0; i < argumentNames.length; i++) {
        name = argumentNames[i];
        obj[name] = args[i + 1];
      }

      return obj;
    }

    function lib$rsvp$node$$arrayResult(_) {
      var length = _.length;
      var args = new Array(length - 1);

      for (var i = 1; i < length; i++) {
        args[i - 1] = _[i];
      }

      return args;
    }

    function lib$rsvp$node$$wrapThenable(then, promise) {
      return {
        then: function(onFulFillment, onRejection) {
          return then.call(promise, onFulFillment, onRejection);
        }
      };
    }

    function lib$rsvp$node$$denodeify(nodeFunc, options) {
      var fn = function() {
        var self = this;
        var l = arguments.length;
        var args = new Array(l + 1);
        var arg;
        var promiseInput = false;

        for (var i = 0; i < l; ++i) {
          arg = arguments[i];

          if (!promiseInput) {
            // TODO: clean this up
            promiseInput = lib$rsvp$node$$needsPromiseInput(arg);
            if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {
              var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);
              lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);
              return p;
            } else if (promiseInput && promiseInput !== true) {
              arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);
            }
          }
          args[i] = arg;
        }

        var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);

        args[l] = function(err, val) {
          if (err)
            lib$rsvp$$internal$$reject(promise, err);
          else if (options === undefined)
            lib$rsvp$$internal$$resolve(promise, val);
          else if (options === true)
            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));
          else if (lib$rsvp$utils$$isArray(options))
            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));
          else
            lib$rsvp$$internal$$resolve(promise, val);
        };

        if (promiseInput) {
          return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);
        } else {
          return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);
        }
      };

      fn.__proto__ = nodeFunc;

      return fn;
    }

    var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;

    function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {
      var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
      if (result === lib$rsvp$node$$ERROR) {
        lib$rsvp$$internal$$reject(promise, result.value);
      }
      return promise;
    }

    function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self){
      return lib$rsvp$promise$$default.all(args).then(function(args){
        var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
        if (result === lib$rsvp$node$$ERROR) {
          lib$rsvp$$internal$$reject(promise, result.value);
        }
        return promise;
      });
    }

    function lib$rsvp$node$$needsPromiseInput(arg) {
      if (arg && typeof arg === 'object') {
        if (arg.constructor === lib$rsvp$promise$$default) {
          return true;
        } else {
          return lib$rsvp$node$$getThen(arg);
        }
      } else {
        return false;
      }
    }
    function lib$rsvp$race$$race(array, label) {
      return lib$rsvp$promise$$default.race(array, label);
    }
    var lib$rsvp$race$$default = lib$rsvp$race$$race;
    function lib$rsvp$reject$$reject(reason, label) {
      return lib$rsvp$promise$$default.reject(reason, label);
    }
    var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;
    function lib$rsvp$resolve$$resolve(value, label) {
      return lib$rsvp$promise$$default.resolve(value, label);
    }
    var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;
    function lib$rsvp$rethrow$$rethrow(reason) {
      setTimeout(function() {
        throw reason;
      });
      throw reason;
    }
    var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow;

    // default async is asap;
    lib$rsvp$config$$config.async = lib$rsvp$asap$$default;
    var lib$rsvp$$cast = lib$rsvp$resolve$$default;
    function lib$rsvp$$async(callback, arg) {
      lib$rsvp$config$$config.async(callback, arg);
    }

    function lib$rsvp$$on() {
      lib$rsvp$config$$config['on'].apply(lib$rsvp$config$$config, arguments);
    }

    function lib$rsvp$$off() {
      lib$rsvp$config$$config['off'].apply(lib$rsvp$config$$config, arguments);
    }

    // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`
    if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
      var lib$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];
      lib$rsvp$config$$configure('instrument', true);
      for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {
        if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {
          lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);
        }
      }
    }

    var lib$rsvp$umd$$RSVP = {
      'race': lib$rsvp$race$$default,
      'Promise': lib$rsvp$promise$$default,
      'allSettled': lib$rsvp$all$settled$$default,
      'hash': lib$rsvp$hash$$default,
      'hashSettled': lib$rsvp$hash$settled$$default,
      'denodeify': lib$rsvp$node$$default,
      'on': lib$rsvp$$on,
      'off': lib$rsvp$$off,
      'map': lib$rsvp$map$$default,
      'filter': lib$rsvp$filter$$default,
      'resolve': lib$rsvp$resolve$$default,
      'reject': lib$rsvp$reject$$default,
      'all': lib$rsvp$all$$default,
      'rethrow': lib$rsvp$rethrow$$default,
      'defer': lib$rsvp$defer$$default,
      'EventTarget': lib$rsvp$events$$default,
      'configure': lib$rsvp$config$$configure,
      'async': lib$rsvp$$async
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$rsvp$umd$$RSVP; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$rsvp$umd$$RSVP;
    } else if (typeof this !== 'undefined') {
      this['RSVP'] = lib$rsvp$umd$$RSVP;
    }
}).call(this);


}).call(this,require('_process'))

},{"_process":9}],41:[function(require,module,exports){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],42:[function(require,module,exports){
(function (global){

var rng;

if (global.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  _rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

module.exports = rng;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],43:[function(require,module,exports){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = (buf && offset) || 0, ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
    if (ii < 16) { // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0, bth = _byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;

},{"./rng":42}],44:[function(require,module,exports){
'use strict';
var Constants = {};
Constants.DefaultTakeItemsCount = 50;
Constants.ExpandExpressionName = 'Expand';
Constants.ReturnAsFieldName = 'ReturnAs';
Constants.FieldsExpressionName = 'Fields';
Constants.SingleFieldExpressionName = 'SingleField';
Constants.SortExpressionName = 'Sort';
Constants.FilterExpressionName = 'Filter';
Constants.SkipExpressionName = 'Skip';
Constants.TakeExpressionName = 'Take';
Constants.ParentRelationFieldName = 'ParentRelationField';
Constants.IdFieldNameClient = 'Id';
Constants.TargetTypeNameFieldName = 'TargetTypeName';

module.exports = Constants;
},{}],45:[function(require,module,exports){
'use strict';
var Constants = require('./Constants');

/**
 * A class that is used to get all required information in order to process a set of relations.
 * @param parent - An ExecutionNode instance used to supply the tree like data structure.
 * @param relationNode - The relation node used to created the ExecutionNode instance (ExecutionNode instance should contain one or many relations
 * if they can be combined for batch execution).
 * @constructor
 */
var ExecutionNode = function (parent, relationNode) {
    var parentPath = '';
    if (parent) {
        parentPath = parent.path;
    }
    this.parent = parentPath;
    this.relations = [relationNode.path];
    this.name = relationNode.path;
    this.targetTypeName = relationNode.targetTypeName;
    this.canAddOtherRelations = !relationNode.filterExpression && !relationNode.sortExpression && !relationNode.take && !relationNode.skip;
    this.children = [];
    var path = '';
    if (parentPath) {
        path += parentPath + '.';
    }
    path += relationNode.targetTypeName;
    this.path = path;
};

/**
 * Inserts a RelationNode to an ExecutionNode.
 * @param relation - A Relation instance.
 */
ExecutionNode.prototype.insertRelationNode = function (relation) {
    this.relations.push(relation.path);
};

/**
 * Inserts a child node (which relations) depends from parent node result.
 * @param child - ExecutionNode instance representing child node.
 */
ExecutionNode.prototype.insertChildrenNode = function (child) {
    this.children.push(child.name);
};

/**
 * Helper method that checks if some relations could be combined (for example have same TargetType).
 * @param relation
 * @returns {boolean}
 */
ExecutionNode.prototype.canCombineWithRelation = function (relation) {
    //TODO: think some more ?!
    if (!this.canAddOtherRelations) {
        return false;
    }

    return this.targetTypeName === relation.targetTypeName && !relation.filterExpression && !relation.sortExpression && !relation.take && !relation.skip;
};

/** ExecutionTree
 * Class that allows the creation of an execution tree from a relationTree. Used to process all queries (master and child) in a correct order.
 * @param relationTree - An instance of relation tree.
 * @constructor
 */
var ExecutionTree = function (relationTree) {
    this._relationTree = relationTree;
    this._map = {};
};

/**
 * Adds execution node to the ExecutionTree.
 * @param executionNode
 */
ExecutionTree.prototype.addExecutionNode = function (executionNode) {
    this._map[executionNode.name] = executionNode;
};

/**
 * Finds the ExecutionNode which contains the requested relation.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getExecutionNodeOfRelation = function (relation) {
    for (var execNode in this._map) {
        if (this._map.hasOwnProperty(execNode)) {
            if (this._map[execNode].relations.indexOf(relation) > -1) {
                return this._map[execNode];
            }
        }
    }
    return null;
};

/**
 * Finds a RelationNode within the RelationTree.
 * @param relation - String that represents the relation within the RelationTree (for example: Activities.Likes.Role).
 * @returns {*}
 */
ExecutionTree.prototype.getRelationNode = function (relation) {
    if (relation) {
        return this._relationTree[relation] || null;
    } else {
        return null;
    }
};

ExecutionTree.prototype.getRootRelationNode = function () {
    return this._relationTree[this._relationTree.$root] || null;
};
/**
 * Builds the ExecutionTree from a RelationTree.
 */
ExecutionTree.prototype.build = function () {
    //build beginning from the root
    var relationRoot = this.getRelationNode(this._relationTree.$root);
    //Setup the root of the execution tree.
    var rootExecutionNode = new ExecutionNode(null, relationRoot);//no parent node
    this.addExecutionNode(rootExecutionNode);
    this.buildInternal(relationRoot);
};

/**
 * Traverse the relation tree and build the execution tree.
 * @param relationRoot - The root node of the RelationTree.
 */
ExecutionTree.prototype.buildInternal = function (relationRoot) {
    relationRoot.children.forEach(function (child) {
        var childRelationNode = this.getRelationNode(child);
        this.insertRelationNodeInExecutionTree(childRelationNode);
        this.buildInternal(childRelationNode);
    }, this);
};

/**
 * Inserts a relation node within the execution tree (based on its dependencies).
 * @param relation - The relation that will be inserted.
 */
ExecutionTree.prototype.insertRelationNodeInExecutionTree = function (relation) {
    var rootExecutionNode = this.getExecutionNodeOfRelation(relation.parent);
    var childToCombine = this.tryGetChildNodeToCombine(rootExecutionNode, relation);
    if (childToCombine) {//if there is a child that we combine the relation
        childToCombine.insertRelationNode(relation);
    } else {
        var newExecutionNode = new ExecutionNode(rootExecutionNode, relation);//create a separate execution node that will host the relation
        rootExecutionNode.insertChildrenNode(newExecutionNode);
        this.addExecutionNode(newExecutionNode);
    }
};

/**
 * Tries to find an ExecutionNode which could be combined with a relation.
 * @param rootExecutionNode - The root node of the ExecutionTree.
 * @param relation - Relation that will be added to the ExecutionTree.
 * @returns {*}
 */
ExecutionTree.prototype.tryGetChildNodeToCombine = function (rootExecutionNode, relation) {
    if (rootExecutionNode.canCombineWithRelation(relation)) {
        return rootExecutionNode;
    }
    var children = rootExecutionNode.children;
    for (var i = 0; i < children.length; i++) {
        var child = this._map[children[i]];
        var childToCombine = this.tryGetChildNodeToCombine(child, relation);
        if (childToCombine) {
            return childToCombine;
        }
    }
    return null;
};

/**
 * Gets the filter expression from all relations inside an ExecutionNode.
 * @param executionNode - The ExecutionNode instance.
 * @returns {{}}
 */
ExecutionTree.prototype.getFilterFromExecutionNode = function (executionNode, includeArrays) {
    var filter = {};
    var subRelationsFilter = [];
    for (var i = 0; i < executionNode.relations.length; i++) {
        var innerFilter = this.getFilterFromSingleRelation(this._relationTree[executionNode.relations[i]], includeArrays);
        if (innerFilter) {
            subRelationsFilter.push(innerFilter);
        }
    }

    if (subRelationsFilter.length > 1) {
        filter.$or = subRelationsFilter;
    } else if (subRelationsFilter.length > 0) {
        filter = subRelationsFilter[0];
    } else {
        filter = null;
    }
    return filter;
};

/**
 * Gets filter expression from a single relation. Traverse the relation tree in order to get the "Id"s from the result of parent relation
 * along with user defined filters.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getFilterFromSingleRelation = function (relation, includeArrays) {
    var userDefinedFilter = relation.filterExpression;
    var parentRelationFilter = {};
    var parentRelationIds = this.getRelationFieldValues(relation, includeArrays);
    var parentRelationFieldName = (relation.isInvertedRelation ? relation.relationField : Constants.IdFieldNameClient);

    if (parentRelationIds.length > 0) {
        parentRelationFilter[parentRelationFieldName] = {'$in': parentRelationIds};
    } else {
        return null;
    }

    if (userDefinedFilter !== undefined) {
        var filters = [];
        filters.push(parentRelationFilter);
        filters.push(userDefinedFilter);
        return {'$and': filters};
    } else {
        return parentRelationFilter;
    }
};

/**
 * Get relation field values of parent relation in order to construct a proper filter (to create a relation).
 * @param relation - A relation instance which will get the filter.
 * @param includeArrays - Whether to include array valus of the parent items when calculating the items that will be expanded on the current level.
 * @returns {Array} - An array of relation field values.
 */
ExecutionTree.prototype.getRelationFieldValues = function (relation, includeArrays) {
    var parentRelationIds = [];
    var parentRelation = this._relationTree[relation.parent];
    // parentRelationResult actually is an Activity or Array of Activities
    var parentRelationResult = Array.isArray(parentRelation.result) ? parentRelation.result : [parentRelation.result];
    if (relation.isInvertedRelation) {
        for (var p = 0; p < parentRelationResult.length; p++) {
            parentRelationIds.push(parentRelationResult[p][relation.parentRelationField]);
        }
    } else {
        // all comments are related to expand of type content type Activities expand: {"Likes": true}
        if (parentRelation && parentRelation.result) {
            relation.parentRelationIds = relation.parentRelationIds || {};
            for (var i = 0; i < parentRelationResult.length; i++) {
                // itemFromParentRelation is single Activity
                var itemFromParentRelation = parentRelationResult[i];

                // parentRelationFieldValue is Activity.Likes
                var parentRelationFieldValue = itemFromParentRelation[relation.relationField];
                if (Array.isArray(parentRelationFieldValue)) {
                    relation.hasArrayValues = true;
                    if (includeArrays) {
                        for (var j = 0; j < parentRelationFieldValue.length; j++) {
                            // itemToExpandId is current value in Activity.Likes array or just a single "Id"
                            var itemToExpandId = parentRelationFieldValue[j];
                            if(itemToExpandId !== undefined && itemToExpandId !== null) {
                                parentRelationIds.push(itemToExpandId);
                                // we set any value just to create a map of Ids
                                relation.parentRelationIds[itemToExpandId] = 1;
                            }
                        }
                    }
                } else {
                    if(parentRelationFieldValue !== undefined && parentRelationFieldValue !== null) {
                        parentRelationIds.push(parentRelationFieldValue);
                        relation.parentRelationIds[parentRelationFieldValue] = 1;
                    }
                }
            }
        }
    }

    return parentRelationIds;
};

module.exports = ExecutionTree;

},{"./Constants":44}],46:[function(require,module,exports){
'use strict';
var async = require('async');
var RelationTreeBuilder = require('./RelationTreeBuilder');
var ExecutionTree = require('./ExecutionTree');
var Constants = require('./Constants');

function Processor(options) {
    this._executionNodeFunction = options.executionNodeFunction;
    this._metadataProviderFunction = options.metadataProviderFunction;
}

Processor.prototype.getExecutionTreeRoot = function (executionTree) {
    var executionTreeRoot = null;
    for (var exNode in executionTree) {
        if (executionTree.hasOwnProperty(exNode)) {
            if (executionTree[exNode].parent === '') {
                executionTreeRoot = executionTree[exNode];
                break;
            }
        }
    }
    return executionTreeRoot;
};

Processor.prototype.createExecuteNodeExecutor = function (relationsTree, executionTree, executionNode, expandContext) {
    var self = this;
    var relationsTreeMap = relationsTree.map;
    return function (done) {
        var relationNode = executionTree.getRelationNode(executionNode.relations[0]);//get the relation node for the only relation of the execution node.
        var parentRelationNode = executionTree.getRelationNode(relationNode.parent);
        var includeArrays = !(parentRelationNode.parent && parentRelationNode.hasArrayValues); //only expand array fields if the parent relation is not an array. This means that if we have expanded a Likes (multiple to Users), we won't expand any array relations that are nested in it such as the UserComments (multiple relation to Comments).
        var filter = executionTree.getFilterFromExecutionNode(executionNode, includeArrays);

        var errorMessage = relationsTree.validateSingleRelation(relationNode);
        if(errorMessage) {
            return done(new Error(errorMessage));
        }

        // if we have such options executionNode should have only one relation.
        var node = {};
        node.select = relationNode.fieldsExpression;
        node.sort = relationNode.sortExpression;
        node.skip = relationNode.skip;
        node.take = relationNode.take;
        node.filter = filter;
        node.targetTypeName = relationNode.targetTypeName;

        self._executionNodeFunction.call(null, node, expandContext, function onProcessExecutionNode(err, result) {
            if (err) {
                return done(err);
            }

            for (var i = 0; i < executionNode.relations.length; i++) {
                var childRelation = relationsTreeMap[executionNode.relations[i]];
                childRelation.result = self.extractResultForRelation(relationsTreeMap[executionNode.relations[i]], result);
            }
            executionNode.result = childRelation.result;
            var arr = [];
            for (var j = 0; j < executionNode.children.length; j++) {
                var executionTreeMap = executionTree._map;
                arr.push(self.createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionNode.children[j]], expandContext));
            }
            async.parallel(arr, done);
        });
    };
};

Processor.prototype.getSingleResult = function (relationsTree, relation, singleObject) {
    if (!singleObject) {
        return null;
    }

    var childRelation;
    var childItem;

    // if relation has singleFieldName option we just replace the parent id with a single value
    if (relation.singleFieldName) {
        if (relation.children && relation.children.length > 0) {
            childRelation = relationsTree[relation.children[0]];
            childItem = this.getObjectByIdFromArray(childRelation.result, singleObject[relation.singleFieldName]);
            return this.getSingleResult(relationsTree, childRelation, childItem);
        }
        return singleObject[relation.singleFieldName];
    }

    var result = {};
    var passedProperties = {};

    if (relation.children && relation.children.length > 0) {
        for (var j = 0; j < relation.children.length; j++) {
            childRelation = relationsTree[relation.children[j]];
            var childRelationField = childRelation.relationField;
            var userDefinedRelName = childRelation.userDefinedName;
            if (!childRelation.isInvertedRelation) {
                passedProperties[childRelationField] = 1;
            }

            var innerRelationResult = childRelation.result;

            if (childRelation.isInvertedRelation) {
                for (var k = 0; k < innerRelationResult.length; k++) {
                    this.addSingleResultToParentArray(relationsTree, childRelation, innerRelationResult[k], result, userDefinedRelName);
                }
            } else {
                result[userDefinedRelName] = childRelation.isArray() ? [] : null;
                
                if (singleObject[childRelationField]) {
                    if (Array.isArray(singleObject[childRelationField])) {
                        if (childRelation.sortExpression) {
                            // if there is a sorting we replace items using order of the query result
                            for (var p = 0; p < innerRelationResult.length; p++) {
                                if (singleObject[childRelationField].indexOf(innerRelationResult[p].Id) > -1) {
                                    childItem = innerRelationResult[p];
                                    this.addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
                                }
                            }
                        } else {
                            // we just replace items getting them by id which we have
                            for (var i = 0; i < singleObject[childRelationField].length; i++) {
                                childItem = this.getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField][i]);
                                this.addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
                            }
                        }
                    } else {
                        childItem = this.getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField]);
                        result[userDefinedRelName] = this.getSingleResult(relationsTree, childRelation, childItem);
                    }
                }
            }
        }
    }

    // add all other fields to the result (except the relation fields which we have already replaced).
    for (var prop in singleObject) {
        var propertyShouldBeAddedToResult = singleObject.hasOwnProperty(prop) && !passedProperties[prop] &&
            this.fieldExistInFieldsExpression(prop, relation.originalFieldsExpression);
        if (propertyShouldBeAddedToResult) {
            result[prop] = singleObject[prop];
        }
    }

    return result;
};

Processor.prototype.addSingleResultToParentArray = function (relationsTree, childRelation, childItem, result, userDefinedRelName) {
    var singleResult = this.getSingleResult(relationsTree, childRelation, childItem);
    result[userDefinedRelName] = result[userDefinedRelName] || [];
    if (singleResult) {
        result[userDefinedRelName].push(singleResult);
    }
};

/**
 * Checks if a field will be returned via given fields expression.
 * @param field - The name of the field.
 * @param fieldsExpression - The Fields expression which is checked.
 * @returns {*}
 */
Processor.prototype.fieldExistInFieldsExpression = function (field, fieldsExpression) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return true;
    }

    if (field === Constants.IdFieldNameClient) {
        if (fieldsExpression[field] === undefined) {
            return true;
        }
        return fieldsExpression[field];
    }

    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return true;
    }

    if (isExclusive) {
        return !fieldsExpression.hasOwnProperty(field);
    } else {
        return fieldsExpression.hasOwnProperty(field);
    }
};

/**
 * Extracts the result for a single relation (in cases when ExecutionNode contains more than one relations).
 * @param relation - The relation object.
 * @param queryResult - Result of the combined query.
 * @returns {Array}
 */
Processor.prototype.extractResultForRelation = function (relation, queryResult) {
    var result = [];
    for (var i = 0; i < queryResult.length; i++) {
        if (relation.parentRelationIds) {
            if (relation.parentRelationIds.hasOwnProperty(queryResult[i].Id)) {
                result.push(queryResult[i]);
            }
        }
        if (relation.isInvertedRelation) {
            result.push(queryResult[i]);
        }
    }
    return result;
};

/**
 * Gets an object with a given Id from Array.
 * @param array
 * @param id
 * @returns {*}
 */
Processor.prototype.getObjectByIdFromArray = function (array, id) {
    if (array) {
        for (var i = 0; i < array.length; i++) {
            if (array[i].Id === id) {
                return array[i];
            }
        }
    }
    return null;
};

Processor.prototype.prepare = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, prepareContext, done) {
    var rtb = new RelationTreeBuilder(expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, this._metadataProviderFunction, prepareContext);
    rtb.build(function (err, map) {
        var mainQueryFieldsExpression;
        if (map) {
            mainQueryFieldsExpression = map[map.$root].fieldsExpression;
            var prepareResult = {
                relationsTree: rtb,
                mainQueryFieldsExpression: mainQueryFieldsExpression
            }
        }
        done(err, prepareResult);
    });
};

Processor.prototype.expand = function (relationsTree, mainQueryResult, expandContext, done) {
    var relationsTreeMap = relationsTree.map;
    var self = this;
    var executionTree = new ExecutionTree(relationsTreeMap);
    executionTree.build();
    relationsTreeMap[relationsTreeMap.$root].result = mainQueryResult;
    var executionTreeMap = executionTree._map;

    var executionTreeRoot = this.getExecutionTreeRoot(executionTreeMap);

    var maxQueriesCount = 20; //TODO: make it configurable
    if (Object.keys(executionTreeMap).length > maxQueriesCount) {
        done(new Error('Expand expression results in more than ' + maxQueriesCount + ' inner queries!'));
    }

    if (executionTreeRoot) {
        var execFuncs = [];
        for (var i = 0; i < executionTreeRoot.children.length; i++) {
            execFuncs.push(this.createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionTreeRoot.children[i]], expandContext));
        }
        // execFuncs are functions created for every single execution note
        // we execute them in async, since the result of the parent relation is used to get correct filter.
        async.series(execFuncs, function onProcessExecutionTree(err) {
            if (err) {
                done(err);
            } else {
                var output;
                var rootRelation = relationsTreeMap[relationsTreeMap.$root];
                if (Array.isArray(mainQueryResult)) {
                    output = [];
                    for (var i = 0; i < mainQueryResult.length; i++) {
                        var singleResult = self.getSingleResult(relationsTreeMap, rootRelation, mainQueryResult[i]);
                        if (singleResult) {
                            output.push(singleResult);
                        }
                    }
                } else {
                    output = self.getSingleResult(relationsTreeMap, rootRelation, mainQueryResult);
                }
                done(null, output);
            }
        });
    }
};

Processor.Constants = Constants;

module.exports = Processor;

},{"./Constants":44,"./ExecutionTree":45,"./RelationTreeBuilder":48,"async":49}],47:[function(require,module,exports){
'use strict';
var Constants = require('./Constants');
var _ = require('underscore');

function RelationNode(options) {
    this.parent = options.parent;
    this.relationField = options.relationField;
    this.path = options.path || options.parent + '.' + options.relationField;
    this.fieldsExpression = options.fieldsExpression || {};
    var isManuallyValidated = options.hasOwnProperty('validated') ? options.validated : !!options.targetTypeName;
    this.validated = isManuallyValidated;
    this.targetTypeName = options.targetTypeName;
    this.children = [];
    this.isInvertedRelation = options.isInvertedRelation;
    this.isArrayRoot = options.isArrayRoot; //used for validation of cases where various expand features are disabled for a GetAll scenario.
    this.hasArrayValues = false;//set when we have executed the query. Used in validation scenarios where we do not have metadata about whether the relation is an array or not.

    var expandExpression = options.expandExpression || {};

    this.parentRelationField = expandExpression[Constants.ParentRelationFieldName] || Constants.IdFieldNameClient;
    var relationField = this.isInvertedRelation ? this.path : this.relationField; //inverted relations appear with the full path - ContentType.Field - in the result when expanding.
    this.userDefinedName = expandExpression[Constants.ReturnAsFieldName] || relationField;
    _.extend(this.fieldsExpression, expandExpression[Constants.FieldsExpressionName]);
    this.originalFieldsExpression = {};
    _.extend(this.originalFieldsExpression, this.fieldsExpression);
    this.singleFieldName = expandExpression[Constants.SingleFieldExpressionName];
    this.filterExpression = expandExpression[Constants.FilterExpressionName];
    this.sortExpression = expandExpression[Constants.SortExpressionName];
    this.skip = expandExpression[Constants.SkipExpressionName];
    this.take = this._getTakeLimit(expandExpression[Constants.TakeExpressionName], options.maxTakeValue);
}


/**
 * Gets the take limit depending on the application and the take value that the user has provided.
 * @param clientTakeValue
 * @param maxTakeValue
 * @returns {number}
 */
RelationNode.prototype._getTakeLimit = function (clientTakeValue, maxTakeValue) {
    maxTakeValue = maxTakeValue || Constants.DefaultTakeItemsCount;
    if (clientTakeValue) {
        if (clientTakeValue > maxTakeValue) {
            throw new Error('The maximum allowed take value when expanding relations is ' + maxTakeValue + '!');
        }
        return clientTakeValue;
    } else {
        return maxTakeValue;
    }
};

/**
 * Anyone using the bs-expand-processor module can set whether the relation is a multiple relation in the prepare phase.
 * This will allow for certain restrictions to be enforced directly on the prepare phase instead of the execution phase.
 */
RelationNode.prototype.setIsArrayFromMetadata = function () {
    this.isArrayFromMetadata = true;
};

RelationNode.prototype.isArray = function () {
    // We can find out if a relation is an array in the following cases:
    // From metadata in the API Server.
    // All inverted relations are array.
    // Once values have been received we can find out. This is used for scenarios where we do not have metadata about the relation (offline storage in SDK).
    return this.isArrayFromMetadata || this.isInvertedRelation || this.hasArrayValues ;
};

module.exports = RelationNode;

},{"./Constants":44,"underscore":50}],48:[function(require,module,exports){
'use strict';
var RelationNode = require('./RelationNode');
var _ = require('underscore');
var Constants = require('./Constants');

//var relationFieldPropertyName = Constants.RelationExpressionName;

var possibleExpandOptions = [
    Constants.ExpandExpressionName,
    Constants.ReturnAsFieldName,
    Constants.FieldsExpressionName,
    Constants.SingleFieldExpressionName,
    Constants.SortExpressionName,
    Constants.FilterExpressionName,
    Constants.SkipExpressionName,
    Constants.TakeExpressionName,
    Constants.ParentRelationFieldName,
    Constants.TargetTypeNameFieldName
];


/**
 * A class used to parse Expand expression and build a corresponding relation tree.
 * In a process of creating the relation tree are performed several checks in order to force some limitations -
 * 50 items both for master and child queries and entire amount of all queries limited to 20.
 * Checks if the relation field given by the customer is valid (for example: user gives "Like" while the relation field is "Likes").
 * Checks for possible expand options.
 * @constructor
 */
var RelationTreeBuilder = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, metadataProviderFunction, context) {
    this.maxTakeValue = maxTakeValue;
    this._metadataProviderFunction = metadataProviderFunction;
    this.context = context;
    this.expandExpression = this.processExpandExpression(expandExpression);
    // mark the main query in order to avoid some duplication issues.
    this.map = {};
    this.map[mainTypeName] = new RelationNode({
        targetTypeName: mainTypeName,
        isArrayRoot: isArray,
        fieldsExpression: fieldsExpression,
        validated: true,
        path: mainTypeName,
        maxTakeValue: maxTakeValue
    });
    this.map[mainTypeName].originalFieldsExpression = {};
    _.extend(this.map[mainTypeName].originalFieldsExpression, fieldsExpression);
    this.map.$root = mainTypeName;
};

/**
 * Creates fully qualified expand expression from shorthand usages:
 * {"Likes": true} -> {"Likes": {"ReturnAs": "Likes"}}
 * {"Likes": "LikesExpanded"} -> {"Likes": {"ReturnAs": "LikesExpanded"}}
 * @param expandExpression
 * @returns {*}
 */
RelationTreeBuilder.prototype.processExpandExpression = function (expandExpression) {
    for (var property in expandExpression) {
        if (expandExpression.hasOwnProperty(property)) {
            if (typeof expandExpression[property] === 'boolean') {
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = property;
            }
            if (typeof expandExpression[property] === 'string') {
                var relationField = expandExpression[property];
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = relationField;
            }
        }
    }
    return expandExpression;
};

/**
 * Builds the relation tree.
 * @param done
 */
RelationTreeBuilder.prototype.build = function (done) {
    try {
        this.buildMapInternal(this.expandExpression, this.map.$root);
    } catch (e) {
        return done(e);
    }
    var self = this;
    require('async').series([
        this.configureRelationTree.bind(this),
        this.validateRelationTree.bind(this)
    ], function (err) {
        done(err, self.map);
    });
};

/**
 *
 * @param relationName - A path to the external relation collection (Comments.ActivityId)
 * @param expandExpression - The expand expression that contains all information about the relation
 * @param rootName - Name of the parent relation.
 * @returns {RelationNode}
 */
RelationTreeBuilder.prototype.createInvertedRelation = function (relationName, expandExpression, rootName) {
    var options = {};
    var relationNameParts = relationName.split('.');
    options.parent = rootName;
    options.relationField = relationNameParts[1];
    options.isInvertedRelation = true;
    options.targetTypeName = relationNameParts[0];
    options.expandExpression = expandExpression;
    options.path = relationName;
    options.maxTakeValue = this.maxTakeValue;
    options.validated = false;

    return new RelationNode(options);
};

/**
 * An internal method which parses the expand expression and produces a basic relation tree (only names and parent relations).
 * @param expandExpression - The expand expression which will be processed.
 * @param rootName - The name of the root relation (master query) usually the name of the requested content type (Activities).
 */
RelationTreeBuilder.prototype.buildMapInternal = function (expandExpression, rootName) {
    for (var relationName in expandExpression) {
        if (expandExpression.hasOwnProperty(relationName)) {
            var currentExpression = expandExpression[relationName];

            for (var option in currentExpression) {
                if (currentExpression.hasOwnProperty(option) && possibleExpandOptions.indexOf(option) === -1) {
                    throw new Error('\"' + option + '\"' + ' is not a valid option for Expand expression');
                }
            }

            if (relationName.indexOf('.') > -1) {
                var invertedRelation = this.createInvertedRelation(relationName, currentExpression, rootName);
                this.map[invertedRelation.path] = invertedRelation;
                this.map[invertedRelation.parent].children.push(invertedRelation.path);
                // adds a field expression in the original fields expression in order to get the result for that field
                RelationTreeBuilder.addFieldToFieldsExpression(this.map[invertedRelation.parent].originalFieldsExpression, invertedRelation.userDefinedName);

                if (expandExpression[relationName][Constants.ExpandExpressionName]) {
                    var processedExpandExpression = this.processExpandExpression(expandExpression[relationName][Constants.ExpandExpressionName]);
                    this.buildMapInternal(processedExpandExpression, invertedRelation.path);
                }
            } else {
                var options = {};
                options.relationField = relationName;
                options.parent = rootName;
                options.expandExpression = currentExpression;
                options.maxTakeValue = this.maxTakeValue;
                options.targetTypeName = currentExpression[Constants.TargetTypeNameFieldName];
                var relationNode = new RelationNode(options);
                var parentNode = this.map[options.parent];
                parentNode.children.push(relationNode.path);
                this.map[relationNode.path] = relationNode;

                if (currentExpression.hasOwnProperty(Constants.ExpandExpressionName)) {
                    if (typeof(currentExpression[Constants.ExpandExpressionName]) === 'object') {
                        this.buildMapInternal(this.processExpandExpression(currentExpression.Expand), relationNode.path);
                    } else {
                        throw new Error(relationNode.path + '.Expand must be a valid expand expression!');
                    }
                }
            }
        }
    }
};

/**
 * Adds additional metadata which is necessary to execute a query.
 * Name of the content type of the child relation get via relation field.
 * @param done
 */
RelationTreeBuilder.prototype.configureRelationTree = function (done) {
    if (this._metadataProviderFunction) {
        var relationNames = [];
        var self = this;

        for (var rel in this.map) {
            if (this.map.hasOwnProperty(rel)) {
                if (this.map[rel].parent !== null) {
                    relationNames.push(this.map[rel].relationField);
                }
            }
        }

        this._metadataProviderFunction(relationNames, this.map, this.context, function (err, result) {
            done(err);
        });
    } else {
        return done();
    }
};

/**
 * Performs several checks like:
 * Validity of the relation field.
 * To not use filter or sorting expression within a "GetByFilter" scenario.
 * Does not allow to nest (expand multiple relation field) after a multiple relation.
 * Does not allow to use both "Fields" and "SingleField" options.
 * @param done
 * @returns {*}
 */
RelationTreeBuilder.prototype.validateRelationTree = function (done) {
    var errorMessage = '';
    var EOL = '\r\n';
    for (var relationPath in this.map) {
        if (relationPath !== '$root' && this.map.hasOwnProperty(relationPath)) {
            var relation = this.map[relationPath];
            errorMessage += this.validateSingleRelation(relation);
            this.configureFieldsExpressionsForRelation(relation);
        }
    }
    if (errorMessage !== '') {
        var finalErrorMessage = errorMessage.substr(0, errorMessage.lastIndexOf(EOL));
        var error = new Error(finalErrorMessage);
        return done(error);
    } else {
        done();
    }
};

/**
 * Add relation fields to parent relation fields expression if needed (otherwise relation cannot be established).
 * @param relation - A relation which will be configured.
 */
RelationTreeBuilder.prototype.configureFieldsExpressionsForRelation = function (relation) {
    if (relation.parent) {
        var parentRelationFieldsExpression = this.map[relation.parent].fieldsExpression;
        if (relation.isInvertedRelation) {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.parentRelationField);
        } else {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.relationField);
        }
    }
    if (relation.isInvertedRelation) {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, relation.relationField);
    } else {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, Constants.IdFieldNameClient);
    }
    RelationTreeBuilder.adjustParentRelationFieldsExpression(this.map[relation.parent], relation);
};

/**
 * Validates a single relation for all build-in limitations.
 * @param relation - A relation which will be validated.
 * @returns {string} - Returns an error message with all errors or empty string if there is no errors.
 */
RelationTreeBuilder.prototype.validateSingleRelation = function (relation) {
    var errorMessage = '';
    var EOL = '\r\n';
    var isGetByFilterQuery = this.map[this.map.$root].isArrayRoot;

    if (relation.path === relation.parent) {
        errorMessage += relation.path + ' has same parent which will cause an infinite loop.' + EOL;
        return errorMessage;
    }

    if (relation.isArray()) {
        var multipleQueriesCount = this.getParentMultipleRelationsCount(relation);
        if (multipleQueriesCount > 0) {
            errorMessage += 'Expand expression has multiple relation \"' + relation.path + '\" inside a multiple relation.';
            errorMessage += EOL;
        }

        if (this.map[relation.parent] === this.map[this.map.$root] &&
            isGetByFilterQuery &&
            (relation.filterExpression || relation.sortExpression)) {
            errorMessage += 'Filter and Sort expressions are not allowed with GetByFilter scenario.';
            errorMessage += EOL;
        }

        if (isGetByFilterQuery && relation.isInvertedRelation) {
            errorMessage += 'Expanding an external content type is not allowed with GetByFilter scenario.';
            errorMessage += EOL;
        }
    }
    if (!relation.validated) {
        if (relation.isInvertedRelation) {
            errorMessage += 'Content type \"' + relation.targetTypeName + '\"';
        } else {
            var parentRelation = relation.parent;
            errorMessage += 'Content type \"' + this.map[parentRelation].targetTypeName + '\"';
        }
        errorMessage += ' does not contain \"' + relation.relationField + '\"' + ' relation field.';
        errorMessage += EOL;
    }
    if (relation.fieldsExpression && Object.keys(relation.fieldsExpression).length && relation.singleFieldName) {
        errorMessage += relation.path + ' ';
        errorMessage += 'expand expression contains both \"Fields\" and \"SingleField\" expressions.';
        errorMessage += EOL;
    }
    if (relation.singleFieldName) {
        if (relation.children) {
            if (relation.children.length > 1) {
                errorMessage += relation.path + ' has multiple expand expressions with a single field option.' + EOL;
            }
            if (relation.children.length === 1 && this.map[relation.children[0]].relationField !== relation.singleFieldName) {
                errorMessage += 'Expand expression ' + relation.path;
                errorMessage += ' single field \"' + relation.singleFieldName + '\"';
                errorMessage += ' does not match child relation field \"' + this.map[relation.children[0]].relationField + '\".';
                errorMessage += EOL;
            }
        }
    }

    return errorMessage;
};

/**
 * Gets the count of parent multiple relations.
 * @param relation - Starting relation.
 * @returns {number} - count of all parent multiple relations
 */
RelationTreeBuilder.prototype.getParentMultipleRelationsCount = function (relation) {
    var result = 0;
    var relationForLoop = relation;
    while (relationForLoop.parent) {
        var parentRelation = this.map[relationForLoop.parent];
        if (parentRelation.isArray() && parentRelation.parent) {
            result += 1;
        }
        relationForLoop = parentRelation;
    }
    return result;
};


/**
 * Adjusts fields expression of the parent relation based on paging setting of a relation (skip, take).
 * In that case we put a "$slice" option within the parent relation fields expression.
 * @param parentRelation
 * @param relation
 */
RelationTreeBuilder.adjustParentRelationFieldsExpression = function (parentRelation, relation) {
    //TODO: make it dynamic in execution node

    if (!relation.isInvertedRelation && relation.take && typeof relation.take === 'number') {
        // when relation has filter or sorting skip and take should not be transferred to the parent relation as $slice.
        var shouldTransferPagingToParentRelation = relation.isArray() && !relation.filterExpression && !relation.sortExpression && parentRelation;
        if (shouldTransferPagingToParentRelation) {
            if (parentRelation.fieldsExpression === undefined) {
                parentRelation.fieldsExpression = {};
            }

            if (relation.skip && typeof relation.skip === 'number') {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': [relation.skip, relation.take]
                };
            } else {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': relation.take
                };
            }
            relation.take = null;
            relation.skip = null;
            relation.movedSkipTakeAsSlice = true;
        }
    }
};

/**
 * Adds field to parent relation fields expression. For example if the relation field is excluded from the master request.
 * @param fieldsExpression - Fields expression of the parent relation.
 * @param relationField - Name of the field which should be returned.
 */
RelationTreeBuilder.addFieldToFieldsExpression = function (fieldsExpression, relationField) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return;
    }
    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return;
    }

    if (isExclusive) {
        delete fieldsExpression[relationField];
    } else {
        fieldsExpression[relationField] = 1;
    }
};

/**
 * Gets if the fields expression is exclusive ("FieldName" : 0)
 * @param fieldsExpression - Fields expression to check.
 * @returns {*}
 */
RelationTreeBuilder.getIsFieldsExpressionExclusive = function (fieldsExpression) {
    var isExclusive;
    for (var fieldName in fieldsExpression) {
        if (fieldName !== Constants.IdFieldNameClient && fieldsExpression.hasOwnProperty(fieldName)) {
            if (isExclusive === undefined) {
                if (fieldsExpression[fieldName] === 0) {
                    isExclusive = true;
                    break;
                } else {
                    if (typeof fieldsExpression[fieldName] === 'object') {
                        continue;
                    } else {
                        // fieldsExpression[fieldName] === 1
                        isExclusive = false;
                        break;
                    }
                }
            }
        }
    }
    return isExclusive;
};

module.exports = RelationTreeBuilder;

},{"./Constants":44,"./RelationNode":47,"async":49,"underscore":50}],49:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":9}],50:[function(require,module,exports){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],51:[function(require,module,exports){
var buildPromise = require('./utils').buildPromise;
var EverliveError = require('./EverliveError').EverliveError;
var Platform = require('./constants').Platform;

module.exports = (function () {
    /**
     * @class CurrentDevice
     * @deprecated
     * @protected
     * @param pushHandler
     * @constructor
     */
    var CurrentDevice = function (pushHandler) {
        this._pushHandler = pushHandler;
        this._initSuccessCallback = null;
        this._initErrorCallback = null;

        //Suffix for the global callback functions
        this._globalFunctionSuffix = null;

        this.pushSettings = null;
        this.pushToken = null;
        this.isInitialized = false;
        this.isInitializing = false;

        this.emulatorMode = false;
    };

    CurrentDevice.prototype = {

        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in {{site.TelerikBackendServices}} using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @returns {Object} The promise for the request.
         */
        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in Everlive using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        enableNotifications: function (pushSettings, success, error) {
            this.pushSettings = this._cleanPlatformsPushSettings(pushSettings);

            return buildPromise(_.bind(this._initialize, this), success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @returns {Object} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        disableNotifications: function (success, error) {
            var self = this;

            return this.unregister().then(
                function () {
                    return buildPromise(
                        function (success, error) {
                            if (self.emulatorMode) {
                                success();
                            } else {
                                var pushNotification = window.plugins.pushNotification;
                                var unregisterOptions;
                                var platformType = self._getPlatformType(device.platform);
                                if (platformType === Platform.WindowsPhone) {
                                    unregisterOptions = {'channelName': self.pushSettings.wp8.channelName};
                                }
                                pushNotification.unregister(
                                    function () {
                                        self.isInitialized = false;
                                        success();
                                    },
                                    error,
                                    unregisterOptions
                                );
                            }
                        },
                        success,
                        error
                    );
                },
                error
            );
        },

        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @returns {Object} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @param {Function} success Callback to invoke on success.
         * @param {Function} error Callback to invoke on error.
         */
        getRegistration: function (success, error) {
            var deviceId = encodeURIComponent(this._getDeviceId());
            return this._pushHandler.devices.getById('HardwareId/' + deviceId, success, error);
        },

        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()](#CurrentDevice.enableNotifications) has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @returns {Object} The promise for the request.
         */
        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()](#CurrentDevice.enableNotifications) has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    return self._pushHandler.devices.create(deviceRegistration, success, error);
                },
                error
            );
        },

        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @returns {Object} The promise for the request.
         */
        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        unregister: function (success, error) {
            var deviceId = encodeURIComponent(device.uuid);
            return this._pushHandler.devices.destroySingle({Id: 'HardwareId/' + deviceId}, success, error);
        },

        /**
         * Updates the registration of the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @returns {Object} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceRegistration.HardwareId);
                    return self._pushHandler.devices.updateSingle(deviceRegistration, success, error);
                },
                error
            );
        },

        _initializeInteractivePush: function (iOSSettings, success, error) {
            var pushPlugin = window.plugins.pushNotification;

            var interactiveSettings = iOSSettings.interactiveSettings;
            var notificationTypes = [];
            if (iOSSettings.alert) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Alert);
            }
            if (iOSSettings.badge) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Badge);
            }
            if (iOSSettings.sound) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Sound);
            }

            var getAction = function (actionIdentifier) {
                var action = _.find(interactiveSettings.actions, function (action) {
                    return action.identifier === actionIdentifier;
                });

                return action;
            };
            var categories = _.map(interactiveSettings.categories, function (category) {
                return {
                    identifier: category.identifier,
                    actionsForDefaultContext: _.map(category.actionsForDefaultContext, getAction),
                    actionsForMinimalContext: _.map(category.actionsForMinimalContext, getAction)
                }
            });

            pushPlugin.registerUserNotificationSettings(
                // the success callback which will immediately return (APNs is not contacted for this)
                success,
                // called in case the configuration is incorrect
                error, {
                    // asking permission for these features
                    types: notificationTypes,
                    // register these categories
                    categories: categories
                }
            );
        },

        //Initializes the push functionality on the device.
        _initialize: function (success, error) {
            var self = this;

            if (this.isInitializing) {
                error(new EverliveError('Push notifications are currently initializing.'));
                return;
            }

            if (!this.emulatorMode && (!window.navigator || !window.navigator.globalization)) {
                error(new EverliveError('The globalization plugin is not initialized.'));
                return;
            }

            if (!this.emulatorMode && (!window.plugins || !window.plugins.pushNotification)) {
                error(new EverliveError('The push notifications plugin is not initialized.'));
                return;
            }

            this._initSuccessCallback = success;
            this._initErrorCallback = error;

            if (this.isInitialized) {
                this._deviceRegistrationSuccess(this.pushToken);
                return;
            }

            if (this.emulatorMode) {
                setTimeout(
                    function () {
                        self._deviceRegistrationSuccess('fake_push_token');
                    },
                    1000
                );
                return;
            }

            this.isInitializing = true;

            var suffix = this._globalFunctionSuffix;
            if (!suffix) {
                suffix = Date.now().toString();
                this._globalFunctionSuffix = suffix;
            }

            var pushNotification = window.plugins.pushNotification;

            var platformType = this._getPlatformType(device.platform);
            if (platformType === Platform.iOS) {
                //Initialize global APN callback
                var apnCallbackName = 'apnCallback_' + suffix;
                Everlive.PushCallbacks[apnCallbackName] = _.bind(this._onNotificationAPN, this);

                //Construct registration options object and validate iOS settings
                var apnRegistrationOptions = this.pushSettings.iOS;
                this._validateIOSSettings(apnRegistrationOptions);
                apnRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + apnCallbackName;

                //Register for APN
                pushNotification.register(
                    _.bind(this._successfulRegistrationAPN, this),
                    _.bind(this._failedRegistrationAPN, this),
                    apnRegistrationOptions
                );
            } else if (platformType === Platform.Android) {
                //Initialize global GCM callback
                var gcmCallbackName = 'gcmCallback_' + suffix;
                Everlive.PushCallbacks[gcmCallbackName] = _.bind(this._onNotificationGCM, this);

                //Construct registration options object and validate the Android settings
                var gcmRegistrationOptions = this.pushSettings.android;
                this._validateAndroidSettings(gcmRegistrationOptions);
                gcmRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + gcmCallbackName;

                //Register for GCM
                pushNotification.register(
                    _.bind(this._successSentRegistrationGCM, this),
                    _.bind(this._errorSentRegistrationGCM, this),
                    gcmRegistrationOptions
                );
            } else if (platformType === Platform.WindowsPhone) {
                //Initialize global WP8 callbacks.
                var wp8CallbackName = 'wp8Callback_' + suffix;
                var wp8RegistrationSuccessCallbackName = 'wp8RegistrationSuccessCallback_' + suffix;
                var wp8RegistrationErrorCallbackName = 'wp8RegistrationErrorCallback_' + suffix;

                Everlive.PushCallbacks[wp8CallbackName] = _.bind(this._onNotificationWP8, this);
                Everlive.PushCallbacks[wp8RegistrationSuccessCallbackName] = _.bind(this._deviceRegistrationSuccessWP, this);
                Everlive.PushCallbacks[wp8RegistrationErrorCallbackName] = _.bind(this._deviceRegistrationFailed, this);

                //Construct registration options object and validate the WP8  settings
                var wp8RegistrationOptions = this.pushSettings.wp8;
                this._validateWP8Settings(wp8RegistrationOptions);
                wp8RegistrationOptions.ecb = 'Everlive.PushCallbacks.' + wp8CallbackName;
                wp8RegistrationOptions.uccb = 'Everlive.PushCallbacks.' + wp8RegistrationSuccessCallbackName;
                wp8RegistrationOptions.errcb = 'Everlive.PushCallbacks.' + wp8RegistrationErrorCallbackName;


                pushNotification.register(
                    _.bind(this._successSentRegistrationWP8, this),
                    _.bind(this._errorSentRegistrationWP8, this),
                    wp8RegistrationOptions
                );

            } else {
                throw new EverliveError('The current platform is not supported: ' + device.platform);
            }
        },

        _deviceRegistrationSuccessWP: function (result) {
            this._deviceRegistrationSuccess(result.uri);
        },

        _validateAndroidSettings: function (androidSettings) {
            if (!androidSettings.senderID) {
                throw new EverliveError('Sender ID (project number) is not set in the android settings.');
            }
        },
        _validateWP8Settings: function (settings) {
            if (!settings.channelName) {
                throw new EverliveError('channelName is not set in the WP8 settings.');
            }
        },

        _validateIOSSettings: function (iOSSettings) {

        },

        _cleanPlatformsPushSettings: function (pushSettings) {
            var cleanSettings = {};
            pushSettings = pushSettings || {};

            var addSettingsForPlatform = function addSettingsForPlatform(newSettingsObject, platform, allowedFields) {
                if (!pushSettings[platform]) {
                    return;
                }

                newSettingsObject[platform] = newSettingsObject[platform] || {};
                var newPlatformSettings = pushSettings[platform];
                var settings = newSettingsObject[platform];
                _.each(allowedFields, function (allowedField) {
                    if (newPlatformSettings.hasOwnProperty(allowedField)) {
                        settings[allowedField] = newPlatformSettings[allowedField];
                    }
                });
            };

            addSettingsForPlatform(cleanSettings, 'iOS', ['badge', 'sound', 'alert', 'interactiveSettings']);
            addSettingsForPlatform(cleanSettings, 'android', ['senderID', 'projectNumber']);
            addSettingsForPlatform(cleanSettings, 'wp8', ['channelName']);

            var callbackFields = ['notificationCallbackAndroid', 'notificationCallbackIOS', 'notificationCallbackWP8'];
            _.each(callbackFields, function (callbackField) {
                var callback = pushSettings[callbackField];
                if (callback) {
                    if (typeof callback !== 'function') {
                        throw new EverliveError('The "' + callbackField + '" of the push settings should be a function');
                    }

                    cleanSettings[callbackField] = pushSettings[callbackField];
                }
            });

            if (pushSettings.customParameters) {
                cleanSettings.customParameters = pushSettings.customParameters;
            }

            return cleanSettings;
        },

        _populateRegistrationObject: function (deviceRegistration, success, error) {
            var self = this;

            return buildPromise(
                function (success, error) {
                    if (!self.pushToken) {
                        throw new EverliveError('Push token is not available.');
                    }

                    self._getLocaleName(
                        function (locale) {
                            var deviceId = self._getDeviceId();
                            var hardwareModel = device.model;
                            var platformType = self._getPlatformType(device.platform);
                            var timeZone = jstz.determine().name();
                            var pushToken = self.pushToken;
                            var language = locale.value;
                            var platformVersion = device.version;

                            deviceRegistration.HardwareId = deviceId;
                            deviceRegistration.HardwareModel = hardwareModel;
                            deviceRegistration.PlatformType = platformType;
                            deviceRegistration.PlatformVersion = platformVersion;
                            deviceRegistration.TimeZone = timeZone;
                            deviceRegistration.PushToken = pushToken;
                            deviceRegistration.Locale = language;

                            success();
                        },
                        error
                    );
                },
                success,
                error
            );
        },

        _getLocaleName: function (success, error) {
            if (this.emulatorMode) {
                success({value: 'en_US'});
            } else {
                navigator.globalization.getLocaleName(
                    function (locale) {
                        success(locale);
                    },
                    error
                );
                navigator.globalization.getLocaleName(
                    function (locale) {
                    },
                    error
                );
            }
        },

        _getDeviceId: function () {
            return device.uuid;
        },

        //Returns the Everlive device platform constant given a value aquired from cordova's device.platform.
        _getPlatformType: function (platformString) {
            var psLower = platformString.toLowerCase();
            switch (psLower) {
                case 'ios':
                case 'iphone':
                case 'ipad':
                    return Platform.iOS;
                case 'android':
                    return Platform.Android;
                case 'wince':
                    return Platform.WindowsPhone;
                case 'win32nt': // real wp8 devices return this string as platform identifier.
                    return Platform.WindowsPhone;
                default:
                    return Platform.Unknown;
            }
        },

        _deviceRegistrationFailed: function (error) {
            this.pushToken = null;
            this.isInitializing = false;
            this.isInitialized = false;

            if (this._initErrorCallback) {
                this._initErrorCallback({error: error});
            }
        },

        _deviceRegistrationSuccess: function (token) {
            this.pushToken = token;
            this.isInitializing = false;
            this.isInitialized = true;

            if (this._initSuccessCallback) {
                this._initSuccessCallback({token: token});
            }
        },

        //Occurs when the device registration in APN succeeds
        _successfulRegistrationAPN: function (token) {
            var self = this;
            if (this.pushSettings.iOS && this.pushSettings.iOS.interactiveSettings) {
                this._initializeInteractivePush(
                    this.pushSettings.iOS,
                    function () {
                        self._deviceRegistrationSuccess(token);
                    },
                    function (err) {
                        throw new EverliveError('The interactive push configuration is incorrect: ' + err);
                    }
                );
            } else {
                this._deviceRegistrationSuccess(token);
            }
        },

        //Occurs if the device registration in APN fails
        _failedRegistrationAPN: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when device registration has been successfully sent to GCM
        _successSentRegistrationGCM: function (id) {
            //console.log("Successfully sent request for registering with GCM.");
        },
        //Occurs when device registration has been successfully sent for WP8
        _successSentRegistrationWP8: function (id) {
            //console.log("Successfully sent request for registering WP8 .");
        },
        //Occurs when an error occured when sending registration request for WP8
        _errorSentRegistrationWP8: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when an error occured when sending registration request to GCM
        _errorSentRegistrationGCM: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //This function receives all notification events from APN
        _onNotificationAPN: function (e) {
            this._raiseNotificationEventIOS(e);
        },
        //This function receives all notification events for WP8
        _onNotificationWP8: function (e) {
            this._raiseNotificationEventWP8(e);
        },

        //This function receives all notification events from GCM
        _onNotificationGCM: function onNotificationGCM(e) {
            switch (e.event) {
                case 'registered':
                    if (e.regid.length > 0) {
                        this._deviceRegistrationSuccess(e.regid);
                    }
                    break;
                case 'message':
                    this._raiseNotificationEventAndroid(e);
                    break;
                case 'error':
                    if (!this.pushToken) {
                        this._deviceRegistrationFailed(e);
                    } else {
                        this._raiseNotificationEventAndroid(e);
                    }
                    break;
                default:
                    this._raiseNotificationEventAndroid(e);
                    break;
            }
        },

        _raiseNotificationEventAndroid: function (e) {
            if (this.pushSettings.notificationCallbackAndroid) {
                this.pushSettings.notificationCallbackAndroid(e);
            }
        },
        _raiseNotificationEventIOS: function (e) {
            if (this.pushSettings.notificationCallbackIOS) {
                this.pushSettings.notificationCallbackIOS(e);
            }
        },
        _raiseNotificationEventWP8: function (e) {
            if (this.pushSettings.notificationCallbackWP8) {
                this.pushSettings.notificationCallbackWP8(e);
            }
        }
    };

    return CurrentDevice;
}());
},{"./EverliveError":53,"./constants":61,"./utils":77}],52:[function(require,module,exports){
var Setup = require('./Setup');
var Data = require('./types/Data');
var usersModule = require('./types/Users');
var filesModule = require('./types/Files');
var constants = require('./constants');
var utils = require('./utils');
var buildAuthHeader = utils.buildAuthHeader;
var getAuthInfo = utils.getAuthInfo;
var Push = require('./Push');
var offlineModule = require('./offline/offline');
var Request = require('./Request');
var common = require('./common');
var rsvp = common.rsvp;
var _ = common._;

module.exports = (function () {

    // The constructor of Everlive instances.
    // The entry point for the SDK.

    /**
     * @class Everlive
     * @classdesc The constructor of the {{site.bs}} (Everlive) JavaScript SDK. This is the entry point for the SDK.
     * @param {object|string} options - An object containing configuration options for the Setup object. Alternatively, you can pass a string representing your API key.
     * @param {string} options.apiKey - Your API key.
     * @param {string} [options.url=//api.everlive.com/v1/] - The {{site.TelerikBackendServices}} URL.
     * @param {string} [options.token] - An authentication token. The instance will be associated with the provided previously obtained token.
     * @param {string} [options.tokenType=bearer] - The type of the token that is used for authentication.
     * @param {string} [options.scheme=http] - The URI scheme used to make requests. Supported values: http, https
     * @param {boolean} [options.parseOnlyCompleteDateTimeObjects=false] - If set to true, the SDK will parse only complete date strings (according to the ISO 8601 standard).
     * @param {boolean} [options.emulatorMode=false] - Set this option to true to set the SDK in emulator mode.
     * @param {object|boolean} [options.offlineStorage] - Set this option to true to use the default offline settings.
     * @param {boolean} [options.offlineStorage.autoSync=true] - Whether to sync data automatically when going online.
     * @param {boolean} [options.offlineStorage.isOnline=true] - Whether the storage is in online mode initially.
     * @param {ConflictResolutionStrategy|function} [options.offlineStorage.conflictResolutionStrategy=ConflictResolutionStrategy.ClientWins] - A constant specifying the conflict resolution strategy or a function used to resolve the conflicts.
     * @param {StorageProviders|object} [options.offlineStorage.storageProviderSettings=StorageProviders.LocalStorage] - An object specifying settings for the offline storage provider.
     * @param {function} [options.offlineStorage.syncStart=null] - A function that is called whenever a synchronisation starts.
     * @param {function} [options.offlineStorage.syncEnd=null] - A function that is called when the synchronization completes. The function receives a list of sync errors.
     */
    function Everlive(options) {
        var self = this;
        this.setup = new Setup(options);
        _.each(initializations, function (init) {
            init.func.call(self, options);
        });

        if (Everlive.$ === null) {
            Everlive.$ = self;
        }
    }

    /** Reference to the current {{site.TelerikBackendServices}} (Everlive) JavaScript SDK
     * @memberOf Everlive
     * @type {Everlive}
     * @static
     */
    Everlive.$ = null;
    Everlive.idField = constants.idField;


    // An array keeping initialization functions called by the Everlive constructor.
    // These functions will be used to extend the functionality of an Everlive instance.
    var initializations = [];

    /** An array of functions that are invoked during instantiation of the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
     * @memberOf Everlive
     * @type {Function[]}
     * @static
     * @private
     */
    Everlive.initializations = initializations;

    /** Creates a new {{site.TelerikBackendServices}} (Everlive) Java Script SDK instance.
     * @memberOf Everlive
     * @param {object} options - An object containing options used to initialize the {{site.bs}} JavaScript SDK instance.
     * @returns {Everlive} The instance of the {{site.bs}} (Everlive) JavaScript SDK that was created using the provided options.
     * @static
     * @method
     */
    Everlive.init = function (options) {
        Everlive.$ = null;
        return new Everlive(options);
    };

    Everlive.prototype.data = function (collectionName) {
        return new Data(this.setup, collectionName, this.storage);
    };

    /**
     * Returns the URL to the {{site.bs}} application endpoint that the SDK uses.
     * @memberOf Everlive.prototype
     * @method buildUrl
     * @returns {string} The generated URL.
     */
    Everlive.prototype.buildUrl = function () {
        return utils.buildUrl(this.setup);
    };

    /**
     * Generates the Authorization headers that are used by the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK to make requests to the {{site.bs}} servers.
     * @memberOf Everlive
     * @returns {Object} AuthorizationHeaders The generated Authorization headers object.
     */
    Everlive.prototype.buildAuthHeader = function () {
        return buildAuthHeader(this.setup);
    };

    // rsvp promises
    Everlive.getCallbacks = function (success, error) {
        var promise;
        if (typeof success !== 'function' && typeof error !== 'function') {
            promise = new rsvp.Promise(function (resolve, reject) {
                success = function (data) {
                    resolve(data);
                };
                error = function (error) {
                    reject(error);
                };
            });
        }

        return {promise: promise, success: success, error: error};
    };

    Everlive.disableRequestCache = function (url, method) {
        if (method === 'GET') {
            var timestamp = (new Date()).getTime();
            var separator = url.indexOf('?') > -1 ? '&' : '?';
            url += separator + '_el=' + timestamp;
        }

        return url;
    };

    var AuthStatus = constants.AuthStatus;
    Everlive.AuthStatus = AuthStatus;

    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Everlive.prototype.authInfo = function (success, error) {
        return getAuthInfo(this.setup, _.bind(this.Users.getById, this.Users, 'me'), success, error);
    };

    // A utility method for creating requests for the current Everlive instance

    /**
     * Make a request to the current {{site.bs}} JavaScript SDK instance.
     * @method request
     * @memberOf Everlive.prototype
     * @param {object} options Object used to configure the request.
     * @param {object} [options.endpoint] The endpoint of the {{site.bs}} JavaScript API relative to the API key section. (For example, options.endpoint = MyType will make a request to the MyType type.)
     * @param {HttpMethod} [options.method] HTTP request method.
     * @param {object} [options.data] Data to be sent with the request.
     * @param {Function} [options.success] Success callback that will be called when the request finishes successfully.
     * @param {Function} [options.error] Error callback to be called in case of an error.
     * @param {object} [options.headers] Additional headers to be included in the request.
     * @param {Query|object} [options.filter] This is either a {@link Query} or a [filter]({% slug rest-api-querying-filtering %}) expression.
     * @param {boolean} [options.authHeaders=true] When set to false, no Authorization headers will be sent with the request.
     * @returns {function} The request configuration object containing the `send` function that sends the request.
     */
    Everlive.prototype.request = function (options) {
        return new Request(this.setup, options);
    };

    var initDefault = function () {
        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Users]{@link Users} class for working with users.
         * @member {Users} Users
         */
        this.Users = this.data('Users');
        usersModule.addUsersFunctions(this.Users);

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Files]{@link Files} class for working with files.
         * @member {Files} Files
         */
        this.Files = this.data('Files');
        filesModule.addFilesFunctions(this.Files);

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Push]{@link Push} class for working with push notifications.
         * @member {Push} Push
         */
        this.push = new Push(this);
    };

    initializations.push({name: 'offlineStorage', func: offlineModule.initOfflineStorage});
    initializations.push({name: 'default', func: initDefault});

    return Everlive;
}());

},{"./Push":57,"./Request":58,"./Setup":59,"./common":60,"./constants":61,"./offline/offline":66,"./types/Data":74,"./types/Files":75,"./types/Users":76,"./utils":77}],53:[function(require,module,exports){
var EverliveErrors = {
    itemNotFound: {
        code: 801,
        message: 'Item not found.'
    },
    syncConflict: {
        code: 4242,
        message: 'A conflict occurred while syncing data'
    },
    syncCancelled: {
        code: 4243,
        message: 'Synchronization cancelled by user'
    },
    syncInProgress: {
        code: 4244,
        message: 'Cannot perform operation while synchronization is in progress'
    }
};

var EverliveError = (function () {
    function EverliveError() {
        var tmp = Error.apply(this, arguments);

        tmp.name = this.name = 'EverliveError';

        this.message = tmp.message;

        Object.defineProperty(this, 'stack', {
            get: function () {
                return tmp.stack
            }
        });

        return this;
    }

    EverliveError.prototype = Object.create(Error.prototype);
    EverliveError.prototype.toJSON = function () {
        return {
            name: this.name,
            message: this.message,
            stack: this.stack
        };
    };

    return EverliveError;
}());

var DeviceRegistrationError = (function () {
    var DeviceRegistrationError = function (errorType, message, additionalInformation) {
        EverliveError.call(this, message);
        this.errorType = errorType;
        this.message = message;
        if (additionalInformation !== undefined) {
            this.additionalInformation = additionalInformation;
        }
    };

    DeviceRegistrationError.prototype = Object.create(EverliveError.prototype);

    DeviceRegistrationError.fromEverliveError = function (everliveError) {
        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.EverliveError, everliveError.message, everliveError);
        return deviceRegistrationError;
    };

    DeviceRegistrationError.fromPluginError = function (errorObj) {
        var message = 'A plugin error occurred';
        if (errorObj) {
            if (typeof errorObj.error === 'string') {
                message = errorObj.error;
            } else if (typeof errorObj.message === 'string') {
                message = errorObj.message;
            }
        }

        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.PluginError, message, errorObj);
        return deviceRegistrationError;
    };

    var DeviceRegistrationErrorTypes = {
        EverliveError: 1,
        PluginError: 2
    };

    return DeviceRegistrationError;
}());

module.exports = {
    EverliveError: EverliveError,
    EverliveErrors: EverliveErrors,
    DeviceRegistrationError: DeviceRegistrationError
};
},{}],54:[function(require,module,exports){
var Processor = require('./common').Processor;
var DataQuery = require('./query/DataQuery');
var Query = require('./query/Query');

module.exports = (function () {
    return new Processor({
        executionNodeFunction: function (node, expandContext, done) {
            var query = new DataQuery({
                operation: DataQuery.operations.read,
                collectionName: node.targetTypeName,
                filter: new Query(node.filter, node.select, node.sort, node.skip, node.take)
            });

            expandContext.offlineModule.processQuery(query).then(function (data) {
                done(null, data.result);
            }, done);
        },
        metadataProviderFunction: function (relationNames, map, prepareContext, done) {
            for (var rel in map) {
                if (map.hasOwnProperty(rel)) {
                    if (typeof map[rel] === 'object') {
                        map[rel].validated = true;
                    }
                }
            }
            done();
        }
    });
}());

},{"./common":60,"./query/DataQuery":69,"./query/Query":70}],55:[function(require,module,exports){
module.exports = (function () {
    function Expression(operator, operands) {
        this.operator = operator;
        this.operands = operands || [];
    }

    Expression.prototype = {
        addOperand: function (operand) {
            this.operands.push(operand);
        }
    };

    return Expression;
}());
},{}],56:[function(require,module,exports){
module.exports = (function () {
    //TODO add a function for calculating the distances in geospatial queries

    /**
     * @classdesc A class representing a value for the {{site.TelerikBackendServices}} GeoPoint field.
     * @class GeoPoint
     * @param longitude Longitude of the GeoPoint in decimal degrees (range: -180 to 180). Example: `123.3239467`
     * @param latitude Latitude of the GeoPoint in decimal degrees (range: -90 to 90). Example: `42.6954322`
     */
    function GeoPoint(longitude, latitude) {
        this.longitude = longitude || 0;
        this.latitude = latitude || 0;
    }

    return GeoPoint;
}());
},{}],57:[function(require,module,exports){
var utils = require('./utils');
var buildPromise = utils.buildPromise;
var DeviceRegistrationResult = utils.DeviceRegistrationResult;
var everliveErrorModule = require('./EverliveError').EverliveError;
var DeviceRegistrationError = everliveErrorModule.DeviceRegistrationError;
var EverliveError = everliveErrorModule.EverliveError;
var CurrentDevice = require('./CurrentDevice');


module.exports = (function () {
    /**
     * @class Push
     * @classdesc A class for managing push notifications in your application. Supported are push notifications for hybrid apps on Android and iOS.
     * @protected
     * @param el {Everlive} Everlive Object
     */
    function Push(el) {
        this._el = el;
        this.notifications = el.data('Push/Notifications');
        this.devices = el.data('Push/Devices');
    }

    Push.prototype = {

        /**
         * Ensures that the Telerik Push Notifications plug-in has been loaded and is ready to use. An {EverliveError} is returned if the plug-in is not available.
         * @method ensurePushIsAvailable
         * @memberOf Push.prototype
         */
        ensurePushIsAvailable: function () {
            var isPushNotificationPluginAvailable = (typeof window !== 'undefined' && window.plugins && window.plugins.pushNotification);

            if (!isPushNotificationPluginAvailable) {
                throw new EverliveError("The push notification plugin is not available. Ensure that the pushNotification plugin is included " +
                "and use after `deviceready` event has been fired.");
            }
        },
        /**
         * Returns the current device for sending push notifications
         * @deprecated since version 1.2.7
         * @see [Push.register]{@link push.register}
         * @memberOf Push.prototype
         * @method currentDevice
         * @name currentDevice
         * @param [emulatorMode] {Boolean} If set to true, emulator mode is enabled meaning you cannot send push notifications.
         * @returns {CurrentDevice} Returns an instance of CurrentDevice.
         */
        currentDevice: function (emulatorMode) {
            this.ensurePushIsAvailable();

            if (arguments.length === 0) {
                emulatorMode = this._el.setup._emulatorMode;
            }

            if (!window.cordova) {
                throw new EverliveError('Error: currentDevice() can only be called from within a hybrid mobile app, after \'deviceready\' event has been fired.');
            }

            if (!this._currentDevice) {
                this._currentDevice = new CurrentDevice(this);
            }

            this._currentDevice.emulatorMode = emulatorMode;

            return this._currentDevice;
        },

        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings An object containing settings for the registration. It can include custom parameters to be stored by {{site.bs}}.
         * @param {Object} settings.iOS=null iOS-specific settings.
         * @param {Boolean} settings.iOS.alert=true If set to true, the push notification will display as a standard iOS alert.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.sound=true If set to true, the device will play a notification sound.
         * @param {Object} settings.android=null Android-specific settings.
         * @param {String} settings.android.senderID=null Your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * Telerik Backend Services if it hasn't already been registered.
         * If it was registered the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings Settings for the registration. Can include custom parameters to be saved in backend services.
         * @param {Object} settings.iOS=null iOS specific settings
         * @param {Boolean} settings.iOS.alert=true Specifies whether the device will display an alert message.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.sound=true Specifies whether the device will play a sound.
         * @param {Object} settings.android=null Android specific settings
         * @param {String} settings.android.senderID=null This is your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (settings, success, error) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            var self = this;
            settings = settings || {};

            if (settings.android) {
                settings.android.senderID = settings.android.projectNumber || settings.android.senderID;
            }

            var successCallback = function (token, callback) {
                var result = new DeviceRegistrationResult(token);
                callback(result);
            };

            var errorCallback = function (err, callback) {
                var registrationError = DeviceRegistrationError.fromEverliveError(err);
                callback(registrationError);
            };

            var clearBadgeIfNeeded = function (token, successCb, errorCb) {
                var platformType = currentDevice._getPlatformType(device.platform);
                var clearBadge = platformType === Platform.iOS;

                if (clearBadge && settings.iOS) {
                    clearBadge = settings.iOS.clearBadge !== false;
                }

                if (clearBadge) {
                    self.clearBadgeNumber().then(function () {
                        successCallback(token, successCb);
                    }, function (err) {
                        errorCallback(err, errorCb);
                    });
                } else {
                    successCallback(token, successCb);
                }
            };

            return buildPromise(function (successCb, errorCb) {
                currentDevice.enableNotifications(settings, function (response) {
                    var token = response.token;
                    var customParameters = settings.customParameters;
                    currentDevice.getRegistration()
                        .then(function () {
                            currentDevice.updateRegistration(customParameters, function () {
                                clearBadgeIfNeeded(token, successCb, errorCb);
                            }, function (err) {
                                errorCallback(err, errorCb);
                            });
                        }, function (err) {
                            if (err.code === 801) { //Not registered
                                currentDevice.register(customParameters, function () {
                                    clearBadgeIfNeeded(token, successCb, errorCb);
                                }, errorCb);
                            } else {
                                errorCallback(err, errorCb);
                            }
                        });
                }, function (err) {
                    var deviceRegistrationError = DeviceRegistrationError.fromPluginError(err);
                    errorCb(deviceRegistrationError);
                });
            }, success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * This method invalidates any push tokens that were obtained for the device from the current application.
         * The device will also be unregistered from Telerik Backend Services.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        unregister: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.disableNotifications.apply(currentDevice, arguments);
        },

        /**
         * Updates the registration of the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.updateRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sets the badge number on the {{site.TelerikBackendServices}} server.
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the badge number on the server
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        setBadgeNumber: function (badge, onSuccess, onError) {
            this.ensurePushIsAvailable();

            badge = parseInt(badge);
            if (isNaN(badge)) {
                return buildPromise(function (success, error) {
                    error(new EverliveError('The badge must have a numeric value'));
                }, onSuccess, onError);
            }

            var deviceRegistration = {};
            var currentDevice = this.currentDevice();
            var deviceId = currentDevice._getDeviceId();
            deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceId);
            deviceRegistration.BadgeCounter = badge;
            return buildPromise(function (successCb, errorCb) {
                currentDevice._pushHandler.devices.updateSingle(deviceRegistration).then(
                    function () {
                        if (window.plugins && window.plugins.pushNotification) {
                            return window.plugins.pushNotification.setApplicationIconBadgeNumber(successCb, errorCb, badge);
                        } else {
                            return successCb();
                        }
                    }, errorCb)
            }, onSuccess, onError);
        },

        /**
         * Resets the badge number on the {{site.TelerikBackendServices}} server to 0.
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Clears the badge number on the server by setting it to 0
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        clearBadgeNumber: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.setBadgeNumber(0, onSuccess, onError);
        },

        /**
         * Returns the push notifications registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        getRegistration: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.getRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sends a push notification.
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @returns {Promise} The promise for request.
         */
        /**
         * Sends a push message
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        send: function (notification, onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.notifications.create.apply(this.notifications, arguments);
        },

        /**
         * This method provides a different operation on each supported platform:
         *
         * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
         * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
         * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
         * @returns {Promise} The promise for the request.
         */
        /**
         * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
         * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
         * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
         * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
         * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
         */
        areNotificationsEnabled: function (options, onSuccess, onError) {
            this.ensurePushIsAvailable();

            options = options || {};
            var pushNotification = window.plugins.pushNotification;

            return buildPromise(function (successCb, errorCb) {
                pushNotification.areNotificationsEnabled(successCb, errorCb, options);
            }, onSuccess, onError);
        }
    };

    return Push;
}());
},{"./CurrentDevice":51,"./EverliveError":53,"./utils":77}],58:[function(require,module,exports){
var utils = require('./utils');
var buildAuthHeader = utils.buildAuthHeader;
var parseUtilities = utils.parseUtilities;
var guardUnset = utils.guardUnset;
var common = require('./common');
var reqwest = common.reqwest;
var _ = common._;
var Headers = require('./constants').Headers;

module.exports = (function () {
    var _self;

    // The Request type is an abstraction over Ajax libraries
    // A Request object needs information about the Everlive connection and initialization options

    function Request(setup, options) {
        guardUnset(setup, 'setup');
        guardUnset(options, 'options');
        this.setup = setup;
        this.method = null;
        this.endpoint = null;
        this.data = null;
        this.headers = {};
        // TODO success and error callbacks should be uniformed for all ajax libs
        this.success = null;
        this.error = null;
        this.parse = Request.parsers.simple;
        _.extend(this, options);
        _self = this;
        this._init(options);
    }

    Request.prototype = {
        // Calls the underlying Ajax library
        send: function () {
            Request.sendRequest(this);
        },
        // Returns an authorization header used by the request.
        // If there is a logged in user for the Everlive instance then her/his authentication will be used.
        buildAuthHeader: buildAuthHeader,
        // Builds the URL of the target Everlive service
        buildUrl: function buildUrl(setup) {
            return utils.buildUrl(setup);
        },
        // Processes the given query to return appropriate headers to be used by the request
        buildQueryHeaders: function buildQueryHeaders(query) {
            if (query) {
                if (query instanceof Everlive.Query) {
                    return Request.prototype._buildQueryHeaders(query);
                }
                else {
                    return Request.prototype._buildFilterHeader(query);
                }
            }
            else {
                return {};
            }
        },
        // Initialize the Request object by using the passed options
        _init: function (options) {
            _.extend(this.headers, this.buildAuthHeader(this.setup, options), this.buildQueryHeaders(options.filter), options.headers);
        },
        // Translates an Everlive.Query to request headers
        _buildQueryHeaders: function (query) {
            query = query.build();
            var headers = {};
            if (query.$where !== null) {
                headers[Headers.filter] = JSON.stringify(query.$where);
            }
            if (query.$select !== null) {
                headers[Headers.select] = JSON.stringify(query.$select);
            }
            if (query.$sort !== null) {
                headers[Headers.sort] = JSON.stringify(query.$sort);
            }
            if (query.$skip !== null) {
                headers[Headers.skip] = query.$skip;
            }
            if (query.$take !== null) {
                headers[Headers.take] = query.$take;
            }
            if (query.$expand !== null) {
                headers[Headers.expand] = JSON.stringify(query.$expand);
            }
            return headers;
        },
        // Creates a header from a simple filter
        _buildFilterHeader: function (filter) {
            var headers = {};
            headers[Headers.filter] = JSON.stringify(filter);
            return headers;
        }
    };

    var parseOnlyCompleteDateTimeString = _self && _self.setup && _self.setup.parseOnlyCompleteDateTimeObjects;

    var reviver = parseUtilities.getReviver(parseOnlyCompleteDateTimeString);

    Request.parsers = {
        simple: {
            result: parseUtilities.parseResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        },
        single: {
            result: parseUtilities.parseSingleResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        },
        update: {
            result: parseUtilities.parseUpdateResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        }
    };

    // TODO built for request
    if (typeof Request.sendRequest === 'undefined') {
        Request.sendRequest = function (request) {
            var url = request.buildUrl(request.setup) + request.endpoint;
            url = Everlive.disableRequestCache(url, request.method);
            var data = request.method === 'GET' ? request.data : JSON.stringify(request.data);

            reqwest({
                url: url,
                method: request.method,
                data: data,
                headers: request.headers,
                type: 'json',
                contentType: 'application/json',
                crossOrigin: true,
                //processData: request.method === "GET",
                success: function (data, textStatus, jqXHR) {
                    request.success.call(request, request.parse.result(data));
                },
                error: function (jqXHR, textStatus, errorThrown) {
                    request.error.call(request, request.parse.error(jqXHR.responseText));
                }
            });
        };
    }

    return Request;
}());
},{"./common":60,"./constants":61,"./utils":77}],59:[function(require,module,exports){
var _ = require('./common')._;
var constants = require('./constants');

module.exports = (function () {

    var everliveUrl = constants.everliveUrl;

    // An object that keeps information about an Everlive connection
    function Setup(options) {
        this.url = everliveUrl;
        this.apiKey = null;
        this.masterKey = null;
        this.token = null;
        this.tokenType = null;
        this.scheme = 'http'; // http or https
        this.parseOnlyCompleteDateTimeObjects = false;
        if (typeof options === 'string') {
            this.apiKey = options;
        } else {
            this._emulatorMode = options.emulatorMode;
            _.extend(this, options);
        }
    }

    return Setup;

}());
},{"./common":60,"./constants":61}],60:[function(require,module,exports){
(function (global){
module.exports = (function () {
    var common = {};

    var platform = require('./everlive.platform');
    var isNativeScript = platform.isNativeScript;
    var isNodejs = platform.isNodejs;

    if (!isNodejs && !isNativeScript) {
        common.reqwest = require('reqwest');
    } else {
        var http = require('http');
        common.reqwest = function (options) {
            var httpRequestOptions = {
                url: options.url,
                method: options.method,
                headers: options.headers || {}
            };

            if (options.data) {
                httpRequestOptions.content = options.data; // NOTE: If we pass null/undefined, it will raise an exception in the http module.
            }

            httpRequestOptions.headers['Accept'] = 'application/json';
            httpRequestOptions.headers['Content-Type'] = 'application/json';

            var noop = function () {
            };
            var success = options.success || noop;
            var error = options.error || noop;
            http.request(httpRequestOptions).then(
                function (response) {
                    var contentString = response.content.toString();
                    if (response.statusCode < 400) {
                        // Success callback calls a custom parse function
                        success(contentString);
                    } else {
                        // Error callback relies on a JSON Object with ResponseText inside
                        error({
                            responseText: contentString
                        });
                    }
                },
                function (err) {
                    // error: function(jqXHR, textStatus, errorThrown)
                    // when timeouting for example (i.e. no internet connectivity), we get an err with content { message: "timeout...", stack: null }
                    error({
                        responseText: err
                    });
                });
        };
    }

    if (isNativeScript) {
        common.root = global;
    } else if (isNodejs) {
        common.root = global;
    }

    if (!common.root) {
        //browser/requirejs/cordova
        common.root = window;
    }

    var ensureDependency = function ensureDependency(globalName, localName) {
        if (!localName) {
            localName = globalName;
        }

        if (!Object.keys(common[localName]).length) {
            common[localName] = common.root[globalName];
        }
    };

    //for the everlive bundle without dependencies included browserify replaces them with empty objects
    common._ = require('underscore');
    ensureDependency('_');

    common.jstz = require('jstimezonedetect');
    ensureDependency('jstz');

    common.mongoQuery = require('mongo-query');
    ensureDependency('mongoQuery');

    common.Mingo = require('mingo');
    ensureDependency('Mingo');

    common.uuid = require('uuid');
    ensureDependency('uuid');

    common.Processor = require('../scripts/bs-expand-processor');
    ensureDependency('Processor');

    common.rsvp = require('rsvp');
    ensureDependency('RSVP', 'rsvp');

    if (!isNodejs && !isNativeScript) {
        ensureDependency('reqwest');
    }

    return common;
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../scripts/bs-expand-processor":46,"./everlive.platform":62,"http":"http","jstimezonedetect":25,"mingo":26,"mongo-query":28,"reqwest":39,"rsvp":40,"underscore":41,"uuid":43}],61:[function(require,module,exports){
var _ = require('./common')._;

var constants = {
    idField: 'Id',
    everliveUrl: '//api.everlive.com/v1/',
    /**
     * A class used to represent the conflict resolution strategies.
     * @property {string} ClientWins
     * @property {string} ServerWins
     * @property {string} Custom
     * @typedef {string} Everlive.ConflictResolutionStrategy
     */
    ConflictResolutionStrategy: {
        ClientWins: 'clientWins',
        ServerWins: 'serverWins',
        Custom: 'custom'
    },
    ConflictResolution: {
        KeepServer: 'keepServer',
        KeepClient: 'keepClient',
        Custom: 'custom'
    },
    /**
     * A class used to represent the available storage providers.
     * @property {string} LocalStorage
     * @property {string} FileSystem
     * @property {string} Custom
     * @typedef {string} Everlive.StorageProviders
     */
    StorageProviders: {
        LocalStorage: 'localStorage',
        FileSystem: 'fileSystem',
        Custom: 'custom'
    },
    // The headers used by the Everlive services
    Headers: {
        filter: 'X-Everlive-Filter',
        select: 'X-Everlive-Fields',
        sort: 'X-Everlive-Sort',
        skip: 'X-Everlive-Skip',
        take: 'X-Everlive-Take',
        expand: 'X-Everlive-Expand',
        singleField: 'X-Everlive-Single-Field',
        includeCount: 'X-Everlive-Include-Count',
        powerFields: 'X-Everlive-Power-Fields',
        debug: 'X-Everlive-Debug',
        overrideSystemFields: 'X-Everlive-Override-System-Fields'
    },
    //Constants for different platforms in Everlive
    Platform: {
        WindowsPhone: 1,
        Windows: 2,
        Android: 3,
        iOS: 4,
        OSX: 5,
        Blackberry: 6,
        Nokia: 7,
        Unknown: 100
    },
    OperatorType: {
        query: 1,

        where: 100,
        filter: 101,

        and: 110,
        or: 111,
        not: 112,

        equal: 120,
        not_equal: 121,
        lt: 122,
        lte: 123,
        gt: 124,
        gte: 125,
        isin: 126,
        notin: 127,
        all: 128,
        size: 129,
        regex: 130,
        contains: 131,
        startsWith: 132,
        endsWith: 133,

        nearShpere: 140,
        withinBox: 141,
        withinPolygon: 142,
        withinShpere: 143,

        select: 200,
        exclude: 201,

        order: 300,
        order_desc: 301,

        skip: 400,
        take: 401,
        expand: 402
    },

    /**
     * A class used to represent the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @property {string} unauthenticated Indicates that no user is authenticated.
     * @property {string} masterKey Indicates that a master key authentication is used.
     * @property {string} invalidAuthentication Indicates an authentication has been attempted, but it was invalid.
     * @property {string} authenticated Indicates that a user is authenticated.
     * @typedef {string} Everlive.AuthStatus
     */
    AuthStatus: {
        unauthenticated: 'unauthenticated',
        masterKey: 'masterKey',
        invalidAuthentication: 'invalidAuthentication',
        authenticated: 'authenticated'
    },
    offlineItemStates: {
        created: 'created',
        modified: 'modified',
        deleted: 'deleted'
    },

    /**
     * HTTP Methods
     * @enum {string}
     */
    HttpMethod: {
        GET: 'GET',
        POST: 'POST',
        PUT: 'PUT',
        DELETE: 'DELETE'
    },
    maxDistanceConsts: {
        radians: '$maxDistance',
        km: '$maxDistanceInKilometers',
        miles: '$maxDistanceInMiles'
    },
    radiusConsts: {
        radians: 'radius',
        km: 'radiusInKilometers',
        miles: 'radiusInMiles'
    }
};

// using an invalid field name in the context of Everlive
// to ensure no naming collisions can occur
constants.offlineItemsStateMarker = '__everlive_offline_state';

// the minimum interval between sync requests
constants.defaultSyncInterval = 1000 * 60 * 10; // 10 minutes

module.exports = constants;
},{"./common":60}],62:[function(require,module,exports){
(function (global){
var isNativeScriptApplication = Boolean(((typeof android !== 'undefined' && android && android.widget && android.widget.Button)
    || (typeof UIButton !== 'undefined' && UIButton)));

if (isNativeScriptApplication) {
    global.isNativeScriptApplication = isNativeScriptApplication;
    global.isCordovaApplication = false;

    global.window = {
            localStorage: {
                removeItem: function () { } //shim for mongo-query under nativescript
            }
        };
} else if (typeof window !== 'undefined') {
    var isCordovaApplication = /^file:\/{3}[^\/]/i.test(window.location.href) && /ios|iphone|ipod|ipad|android/i.test(navigator.userAgent);
}

var isNodejs = typeof exports === 'object' && typeof window === 'undefined';
var isRequirejs = typeof define === 'function' && define.amd;

module.exports = {
    isCordova: isCordovaApplication,
    isNativeScript: isNativeScriptApplication,
    isNodejs: isNodejs,
    isRequirejs: isRequirejs
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],63:[function(require,module,exports){
/*!
 Everlive SDK
 Version 1.2.14
 */
/*global device, define, window, navigator*/
(function () {

    var Everlive = require('./Everlive');
    var platform = require('./everlive.platform');
    var common = require('./common');
    common.root.Everlive = Everlive;

    if (!platform.isNativeScript) {
        var kendo = require('./kendo/kendo.everlive');
        Everlive.createDataSource = kendo.createDataSource;
        Everlive.createHierarchicalDataSource = kendo.createHierarchicalDataSource;
    }

    //Global event handlers for push notification events. Required by the cordova PushNotifications plugin that we use.
    Everlive.PushCallbacks = {};
    Everlive.Offline = {};

    Everlive.Query = require('./query/Query');
    Everlive.QueryBuilder = require('./query/QueryBuilder');
    Everlive.GeoPoint = require('./GeoPoint');
    Everlive.Constants = require('./constants');
    Everlive.Request = require('./Request');
    Everlive.Data = require('./types/Data');
    Everlive._traverseAndRevive = require('./utils').parseUtilities.traverseAndRevive;

    var persistersModule = require('./offline/offlinePersisters');
    Everlive.persister = {
        LocalStorage: persistersModule.LocalStoragePersister,
        FileSystem: persistersModule.FileSystemPersister
    };

    if (typeof exports === 'object') {
        module.exports = common.root.Everlive;
    }
}());
},{"./Everlive":52,"./GeoPoint":56,"./Request":58,"./common":60,"./constants":61,"./everlive.platform":62,"./kendo/kendo.everlive":64,"./offline/offlinePersisters":67,"./query/Query":70,"./query/QueryBuilder":71,"./types/Data":74,"./utils":77}],64:[function(require,module,exports){
var QueryBuilder = require('../query/QueryBuilder');
var Query = require('../query/Query');
var Request = require('../Request');
var constants = require('../constants');
var _ = require('../common')._;
var Everlive = require('../Everlive');

(function () {
    var $ = window.jQuery;
    var kendo = window.kendo;

    if ($ === undefined || kendo === undefined) {
        return;
    }

    var extend = $.extend;

    var everliveTransport = kendo.data.RemoteTransport.extend({
        init: function (options) {
            this.everlive$ = options.dataProvider || Everlive.$;
            if (!this.everlive$) {
                throw new Error('An instance of the Backend services sdk must be provided.');
            }

            if (!options.typeName) {
                throw new Error('A type name must be provided.');
            }

            this.headers = options.headers;

            this.dataCollection = this.everlive$.data(options.typeName);
            kendo.data.RemoteTransport.fn.init.call(this, options);
        },

        read: function (options) {
            var query = translateKendoQuery(options.data);
            var everliveQuery = new Query(query.$where, null, query.$sort, query.$skip, query.$take);
            var id = options.data.Id;
            if (id) {
                this.dataCollection.withHeaders(this.headers).getById(id).then(options.success, options.error);
            } else {
                this.dataCollection.withHeaders(this.headers).get(everliveQuery).then(options.success, options.error);
            }
        },

        update: function (options) {
            var isMultiple = _.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch update is not supported.');
            } else {
                var itemForUpdate = options.data;
                return this.dataCollection.withHeaders(this.headers).updateSingle(itemForUpdate)
                    .then(options.success.bind(this, itemForUpdate), options.error);
            }
        },

        create: function (options) {
            var isMultiple = _.isArray(options.data.models);
            var createData = isMultiple ? options.data.models : options.data;

            return this.dataCollection.withHeaders(this.headers).create(createData)
                .then(options.success.bind(this, createData), options.error);
        },

        destroy: function (options) {
            var isMultiple = _.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch destroy is not supported.');
            }
            return this.dataCollection.withHeaders(this.headers).destroy(options.data)
                .then(options.success, options.error);
        }
    });

    $.extend(true, kendo.data, {
        transports: {
            everlive: everliveTransport
        },
        schemas: {
            everlive: {
                type: 'json',
                total: 'count',
                data: function (data) {
                    return data.result || data;
                },
                model: {
                    id: constants.idField
                }
            }
        }
    });

    function translateKendoQuery(data) {
        var result = {};
        if (data) {
            if (data.skip) {
                result.$skip = data.skip;
                delete data.skip;
            }
            if (data.take) {
                result.$take = data.take;
                delete data.take;
            }
            if (data.sort) {
                var sortExpressions = data.sort;
                var sort = {};
                if (!$.isArray(sortExpressions)) {
                    sortExpressions = [sortExpressions];
                }
                $.each(sortExpressions, function (idx, value) {
                    sort[value.field] = value.dir === 'asc' ? 1 : -1;
                });
                result.$sort = sort;
                delete data.sort;
            }
            if (data.filter) {
                var filter = filterBuilder.build(data.filter);
                result.$where = filter;
                delete data.filter;
            }
        }
        return result;
    }

    var regexOperations = ['startswith', 'startsWith', 'endswith', 'endsWith', 'contains'];

    var filterBuilder = {
        build: function (filter) {
            return filterBuilder._build(filter);
        },
        _build: function (filter) {
            if (filterBuilder._isRaw(filter)) {
                return filterBuilder._raw(filter);
            }
            else if (filterBuilder._isSimple(filter)) {
                return filterBuilder._simple(filter);
            }
            else if (filterBuilder._isRegex(filter)) {
                return filterBuilder._regex(filter);
            }
            else if (filterBuilder._isAnd(filter)) {
                return filterBuilder._and(filter);
            }
            else if (filterBuilder._isOr(filter)) {
                return filterBuilder._or(filter);
            }
        },
        _isRaw: function (filter) {
            return filter.operator === '_raw';
        },
        _raw: function (filter) {
            var fieldTerm = {};
            fieldTerm[filter.field] = filter.value;
            return fieldTerm;
        },
        _isSimple: function (filter) {
            return typeof filter.logic === 'undefined' && !filterBuilder._isRegex(filter);
        },
        _simple: function (filter) {
            var term = {}, fieldTerm = {};
            var operator = filterBuilder._translateoperator(filter.operator);
            if (operator) {
                term[operator] = filter.value;
            }
            else {
                term = filter.value;
            }
            fieldTerm[filter.field] = term;
            return fieldTerm;
        },
        _isRegex: function (filter) {
            return $.inArray(filter.operator, regexOperations) !== -1;
        },
        _regex: function (filter) {
            var fieldTerm = {};
            var regex = filterBuilder._getRegex(filter);
            fieldTerm[filter.field] = filterBuilder._getRegexValue(regex);
            return fieldTerm;
        },
        _getRegex: function (filter) {
            var pattern = filter.value;
            var filterOperator = filter.operator;
            switch (filterOperator) {
                case 'contains':
                    return new RegExp(".*" + pattern + ".*", "i");
                case 'startsWith': // removing the camel case operators will be a breaking change
                case 'startswith': // the Kendo UI operators are in lower case
                    return new RegExp("^" + pattern, "i");
                case 'endsWith':
                case 'endswith':
                    return new RegExp(pattern + "$", "i");
            }
            throw new Error("Unknown operator type.");
        },
        _getRegexValue: function (regex) {
            return QueryBuilder.prototype._getRegexValue.call(this, regex);
        },
        _isAnd: function (filter) {
            return filter.logic === 'and';
        },
        _and: function (filter) {
            var i, l, term, result = {};
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result = filterBuilder._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function (andObj, newObj) {
            return QueryBuilder.prototype._andAppend.call(this, andObj, newObj);
        },
        _isOr: function (filter) {
            return filter.logic === 'or';
        },
        _or: function (filter) {
            var i, l, term, result = [];
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result.push(term);
            }
            return {$or: result};
        },
        _translateoperator: function (operator) {
            switch (operator) {
                case 'eq':
                    return null;
                case 'neq':
                    return "$ne";
                case 'gt':
                    return "$gt";
                case 'lt':
                    return "$lt";
                case 'gte':
                    return "$gte";
                case 'lte':
                    return "$lte";
            }
            throw new Error("Unknown operator type.");
        }
    };

    var getUrlGeneratorForNode = function (baseUrl, expandArray) {
        var expandField = getRelationFieldForExpandNode(expandArray[expandArray.length - 1]);
        var pathArray = expandArray.slice(0, expandArray.length - 1);
        var pathUrl = '/_expand';
        for (var i = 0; i < pathArray.length; i++) {
            pathUrl += '/' + getRelationFieldForExpandNode(pathArray[i]);
        }
        return (function (pathUrl, expandField) {
            return function (options) {
                var url = baseUrl + '';
                if (options.Id && expandField) {//if we are expanding
                    url += pathUrl + '/' + options.Id + '/' + expandField;
                }
                return url;
            }
        }(pathUrl, expandField));
    };

    var getHeadersForExpandNode = function (expandNode) {
        if (typeof expandNode === "string") {
            var expandObject = {};
            expandObject[expandNode] = true;
            var headers = {
                'X-Everlive-Expand': JSON.stringify(expandObject),
                'X-Everlive-Single-Field': expandNode
            };

            return headers;
        } else {
            return {
                'X-Everlive-Filter': JSON.stringify(expandNode.filter),
                'X-Everlive-Sort': JSON.stringify(expandNode.sort),
                'X-Everlive-Single-Field': expandNode.singleField,
                'X-Everlive-Skip': expandNode.skip,
                'X-Everlive-Take': expandNode.take,
                'X-Everlive-Fields': JSON.stringify(expandNode.fields)
            }
        }
    };

    var getRelationFieldForExpandNode = function (expandNode) {
        if (typeof expandNode === "string") {
            return expandNode;
        } else {
            if (expandNode.relation) {
                return expandNode.relation;
            } else {
                throw new Error("You need to specify a 'relation' for an expand node when using the object notation");
            }
        }
    };

    /**
     * Creates a new [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) that manages a certain Backend Services content type and can expand a chain of relations.
     * Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) is used in conjunction with other Kendo widgets (such as [TreeView](http://docs.telerik.com/kendo-ui/web/treeview/overview)) to render data from Backend Services in a structured way.
     * The chain of relations is defined by specifying the field names that contain the relation on each level. For example a generic hierarchy chain is a content type 'Continents' with relation to 'Countries', which in turn contains a relation to 'Towns'.
     * *including Kendo scripts is required*.
     * @param options data source options for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
     * @param options.typeName name of the main content type for the data source.
     * @param {ExpandDefinition[]} options.expand an array of expand definitions. It defines the levels of hierarchy by specifying the relation fields. An expand definition can either be the field name as a **string**, or an **object** that allows additional options.
     * @param {string} ExpandDefinition - The field name of the relation that will be expanded.
     * @param {string} ExpandDefinition.relation - *Required*. The field name of the relation that will be expanded.
     * @param {object} ExpandDefinition.filter - an object specifying the filter expression.
     * @param {object} ExpandDefinition.sort - an object specifying the sort expression.
     * @param {object} ExpandDefinition.skip - a number specifying the skip value.
     * @param {object} ExpandDefinition.take - a number specifying the take value.
     * @param {object} ExpandDefinition.fields - an object specifying the fields expression.
     * @returns {HierarchicalDataSource} A new instance of Kendo UI HierarchicalDataSource. See Kendo UI documentation for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource)
     * @example ```js
     * var el = new Everlive('your-api-key-here');
     * var continents = Everlive.createHierarchicalDataSource({
 *   "typeName": "Continents",
 *   "expand": ["Countries", "Towns"]
 * });
     *
     * ...
     * ("#treeview").kendoTreeView({
 *   dataSource: continents,
 *   dataTextField: ["ContinentName", "CountryName", "TownName"]
 * });
     * ```
     */
    var createHierarchicalDataSource = function createHierarchicalDataSource(options) {
        options = options || {};
        var expand = options.expand;
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || Everlive.$;
        delete options.expand;
        delete options.typeName;
        delete options.dataProvider;
        var baseUrl;

        if (options.url) {
            baseUrl = options.url;
        } else if (everlive$ && typeName) {
            baseUrl = Request.prototype.buildUrl(everlive$.setup) + typeName;
        } else {
            if (!everlive$) {
                throw new Error("You need to instantiate an Everlive instance in order to create a kendo HierarchicalDataSource.");
            }
            if (!typeName) {
                throw new Error("You need to specify a 'typeName' in order to create a kendo HierarchicalDataSource.");
            }
        }

        var expandSchema;
        if (expand) {
            for (var i = expand.length - 1; i >= 0; i--) {
                expandSchema = {
                    model: {
                        hasChildren: getRelationFieldForExpandNode(expand[i]),
                        children: {
                            type: "everlive",
                            transport: {
                                typeName: typeName,
                                dataProvider: everlive$,
                                headers: getHeadersForExpandNode(expand[i])
                            },
                            schema: expandSchema
                        }
                    }
                }
            }
        }
        var dataSourceOptions = {};
        dataSourceOptions.type = 'everlive';
        dataSourceOptions.transport = {
            typeName: typeName,
            dataProvider: everlive$
        };
        dataSourceOptions.schema = expandSchema;
        extend(true, dataSourceOptions, options);
        return new kendo.data.HierarchicalDataSource(dataSourceOptions);
    };

    /**
     * Creates a new Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) that manages a certain Backend Services content type.
     * Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) is used in conjunction with other Kendo UI widgets (such as [ListView](http://docs.telerik.com/kendo-ui/web/listview/overview) and [Grid](http://docs.telerik.com/kendo-ui/web/grid/overview)) to provide an easy way to render data from Backend Services.
     * *including Kendo scripts is required*.
     * @param options data source options. See Kendo UI documentation of [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more info.
     * @param options.transport.typeName the content type name in Backend Services that will be managed.
     * @returns {DataSource} A new instance of Kendo UI DataSource. See Kendo UI documentation of [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more info.
     * @example ```js
     * var booksDataSource = Everlive.createDataSource({
 *   transport: {
 *     typeName: 'Books'
 *   }
 * });
     * ```
     */
    var createDataSource = function (options) {
        options = options || {};
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || Everlive.$;
        if (!everlive$) {
            throw new Error("You need to instantiate an Everlive instance in order to create a kendo DataSource.");
        }
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a kendo DataSource.");
        }
        delete options.typeName;
        delete options.dataProvider;

        var dataSourceOptions = {};
        dataSourceOptions.type = 'everlive';
        dataSourceOptions.transport = {
            typeName: typeName,
            dataProvider: everlive$
        };
        extend(true, dataSourceOptions, options);
        return new kendo.data.DataSource(dataSourceOptions);
    };

    module.exports = {
        createDataSource: createDataSource,
        createHierarchicalDataSource: createHierarchicalDataSource
    };
}());
},{"../Everlive":52,"../Request":58,"../common":60,"../constants":61,"../query/Query":70,"../query/QueryBuilder":71}],65:[function(require,module,exports){
var DataQuery = require('../query/DataQuery');
var everliveErrorModule = require('../EverliveError');
var EverliveError = everliveErrorModule.EverliveError;
var EverliveErrors = everliveErrorModule.EverliveErrors;
var constants = require('../constants');
var offlineItemStates = constants.offlineItemStates;
var Headers = constants.Headers;
var RequestOptionsBuilder = require('../query/RequestOptionsBuilder');
var common = require('../common');
var rsvp = common.rsvp;
var mingo = common.Mingo;
var mongoQuery = common.mongoQuery;
var uuid = common.uuid;
var _ = common._;
var utils = require('../utils');
var buildPromise = utils.buildPromise;
var Request = require('../Request');
var expandProcessor = require('../ExpandProcessor');
var offlineTransformations = require('./offlineTransformations');

/**
 * @class OfflineModule
 * @classDesc A class providing access to some offline storage functionalities.
 */

/**
 * Represents the {@link OfflineModule} class.
 * @memberOf Everlive.prototype
 * @member {OfflineModule} storage
 */

module.exports = (function () {
    function OfflineModule(everlive, options, persister) {
        this.everlive = everlive;
        this.settings = options;
        this.local = persister;
        this._isSynchronizing = false;
        this._collectionCache = {};
    }

    var getSyncFilterForItem = function (item) {
        return {
            Id: item.Id,
            ModifiedAt: item.ModifiedAt
        }
    };

    function buildUsersErrorMessage(dataQuery) {
        var operation = dataQuery.operation;
        if (operation === DataQuery.operations.userLoginWithProvider ||
            operation === DataQuery.operations.userLinkWithProvider ||
            operation === DataQuery.operations.userUnlinkFromProvider) {
            operation += dataQuery.data.Provider || dataQuery.data.Identity.Provider;
        }

        return 'The Users operation ' + operation + ' is not supported in offline mode';
    }

    var unsupportedUsersOperations = {};
    unsupportedUsersOperations[DataQuery.operations.create] = true;
    unsupportedUsersOperations[DataQuery.operations.update] = true;
    unsupportedUsersOperations[DataQuery.operations.remove] = true;
    unsupportedUsersOperations[DataQuery.operations.removeSingle] = true;
    unsupportedUsersOperations[DataQuery.operations.rawUpdate] = true;
    unsupportedUsersOperations[DataQuery.operations.setAcl] = true;
    unsupportedUsersOperations[DataQuery.operations.setOwner] = true;
    unsupportedUsersOperations[DataQuery.operations.userLoginWithProvider] = true;
    unsupportedUsersOperations[DataQuery.operations.userLinkWithProvider] = true;
    unsupportedUsersOperations[DataQuery.operations.userUnlinkFromProvider] = true;
    unsupportedUsersOperations[DataQuery.operations.userLogin] = true;
    unsupportedUsersOperations[DataQuery.operations.userLogout] = true;
    unsupportedUsersOperations[DataQuery.operations.userChangePassword] = true;

    var unsupportedOfflineHeaders = [Headers.powerFields];

    OfflineModule.prototype = {
        processQuery: function (dataQuery) {
            var unsupportedClientOpMessage = this.getUnsupportedClientOpMessage(dataQuery);
            if (unsupportedClientOpMessage && !dataQuery.isSync) {
                return new rsvp.Promise(function (resolve, reject) {
                    reject(new EverliveError(unsupportedClientOpMessage));
                });
            }

            var sort = dataQuery.getHeaderAsJSON(Headers.sort);
            var limit = dataQuery.getHeaderAsJSON(Headers.take);
            var skip = dataQuery.getHeaderAsJSON(Headers.skip);
            var select = dataQuery.getHeaderAsJSON(Headers.select);
            var filter = dataQuery.getHeaderAsJSON(Headers.filter);
            var expand = dataQuery.getHeaderAsJSON(Headers.expand);

            if (dataQuery.filter instanceof Everlive.Query) {
                var filterObj = dataQuery.filter.build();
                filter = filterObj.$where || filter;
                sort = filterObj.$sort || sort;
                limit = filterObj.$take || limit;
                skip = filterObj.$skip || skip;
                select = filterObj.$select || select;
                expand = filterObj.$expand || expand;
            } else {
                filter = dataQuery.filter || filter;
            }

            if (!filter) {
                filter = {};
            }

            var unsupportedOperators = utils.getUnsupportedOperators(filter);
            var unsupportedOperatorCount = unsupportedOperators.length;
            if (unsupportedOperatorCount) {
                return new rsvp.Promise(function (resolve, reject) {
                    var errorMessage;
                    if (unsupportedOperatorCount === 1) {
                        errorMessage = 'The operator ' + unsupportedOperators[0] + ' is not supported in offline mode.';
                    } else {
                        errorMessage = 'The operators ' + unsupportedOperators.join(',') + 'are not supported in offline mode.';
                    }
                    reject(new EverliveError(errorMessage));
                });
            }

            offlineTransformations.traverseAndTransformFilterId(filter);

            switch (dataQuery.operation) {
                case DataQuery.operations.read:
                    return this.read(dataQuery, filter, sort, skip, limit, select, expand);
                case DataQuery.operations.readById:
                    return this.readById(dataQuery, expand);
                case DataQuery.operations.count:
                    return this.count(dataQuery, filter);
                case DataQuery.operations.create:
                    return this.create(dataQuery);
                case DataQuery.operations.rawUpdate:
                case DataQuery.operations.update:
                    return this.update(dataQuery, filter);
                case DataQuery.operations.remove:
                    return this.remove(dataQuery, filter);
                case DataQuery.operations.removeSingle:
                    filter._id = dataQuery.additionalOptions.id;
                    return this.remove(dataQuery, filter);
                default:
                    return new rsvp.Promise(function (resolve, reject) {
                        if (dataQuery.isSync) {
                            resolve();
                        } else {
                            reject(new EverliveError(dataQuery.operation + ' is not supported in offline mode'));
                        }
                    });
            }
        },

        getUnsupportedClientOpMessage: function (dataQuery) {
            for (var i = 0; i < unsupportedOfflineHeaders.length; i++) {
                var header = unsupportedOfflineHeaders[i];
                if (dataQuery.getHeader(header)) {
                    return 'The header ' + header + ' is not supported in offline mode';
                }
            }

            if (dataQuery.collectionName.toLowerCase() === 'files') {
                return 'Operations on files are not supported in offline mode';
            }

            if (dataQuery.collectionName.toLowerCase() === 'users' && unsupportedUsersOperations[dataQuery.operation]) {
                return buildUsersErrorMessage(dataQuery);
            }
        },

        _getCreateResult: function (createdItems) {
            if (createdItems.length === 1) {
                return {
                    result: {
                        CreatedAt: utils.cloneDate(createdItems[0].CreatedAt),
                        Id: createdItems[0]._id
                    }
                }
            } else {
                var multipleCreateResult = [];
                _.each(createdItems, function (createdItem) {
                    multipleCreateResult.push({
                        CreatedAt: utils.cloneDate(createdItem.CreatedAt),
                        Id: createdItem._id
                    });
                });

                return {
                    result: multipleCreateResult
                }
            }
        },

        /**
         * Create the items of the specified type
         * @param dataQuery
         */
        create: function (dataQuery) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                self._createItems(dataQuery.collectionName, dataQuery.data, dataQuery.isSync, function (createdItems) {
                    var createResult = self._getCreateResult(createdItems);
                    resolve(createResult);
                }, reject);
            });
        },

        /**
         * Get items from a content type, based on a filter
         * @param dataQuery {Object} - the data query object
         * @param filter
         * @param sort
         * @param skip
         * @param limit
         * @param select
         * @param expand
         * @returns {RSVP.Promise} - filtered results
         */
        read: function (dataQuery, filter, sort, skip, limit, select, expand) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                var collectionLength;

                self._prepareExpand(expand, dataQuery, true)
                    .then(function (prepareExpandResult) {
                        if (prepareExpandResult) {
                            select = prepareExpandResult.mainQueryFieldsExpression;
                        }

                        return self._getCollection(dataQuery.collectionName)
                            .then(function (collection) {
                                var result = self._readInternal(collection, filter, sort, skip, limit, select);

                                if (skip || limit) {
                                    var all = self._readInternal(collection);
                                    collectionLength = all.length;
                                }

                                result = offlineTransformations.idTransform(result);
                                return self._expandResult(prepareExpandResult, result);
                            });
                    })
                    .then(function (result) {
                        var response = self._transformOfflineResult(result, collectionLength, dataQuery);
                        resolve(response);
                    })
                    .catch(reject);
            });
        },

        _readInternal: function (collection, filter, sort, skip, limit, select) {
            filter = _.extend({}, filter);
            this._getWithoutDeletedFilter(filter);
            offlineTransformations.traverseAndTransformFilterId(filter);
            var query = mingo.Query(filter);
            var cursor = mingo.Cursor(collection, query, select);
            if (sort) {
                cursor = cursor.sort(sort);
            }

            if (skip) {
                cursor.skip(skip);
            }

            if (limit) {
                cursor.limit(limit);
            }

            return _.map(cursor.all(), function (item) {
                return _.extend({}, item);
            });
        },

        readById: function (dataQuery, expand) {
            var self = this;

            return self._prepareExpand(expand, dataQuery, false)
                .then(function (prepareExpandResult) {
                    return self._getCollection(dataQuery.collectionName)
                        .then(function (collection) {
                            return new rsvp.Promise(function (resolve, reject) {
                                var item = self._getById(collection, dataQuery.additionalOptions.id);

                                if (!item) {
                                    return reject(EverliveErrors.itemNotFound);
                                }

                                item = offlineTransformations.idTransform(item);
                                return self._expandResult(prepareExpandResult, item).then(resolve).catch(reject);
                            });
                        });
                })
                .then(function (result) {
                    var response = self._transformOfflineResult(result, null, dataQuery);
                    return response;
                });
        },

        _prepareExpand: function (expand, dataQuery, isArray) {
            return new rsvp.Promise(function (resolve, reject) {
                if (expand) {
                    expandProcessor.prepare(expand, dataQuery.collectionName, isArray, dataQuery.fields, null, null, function (err, prepareResult) {
                        if (err) {
                            return reject(err);
                        }
                        resolve(prepareResult);
                    });
                } else {
                    resolve();
                }
            });
        },

        _expandResult: function (prepareExpandResult, result) {
            var self = this;
            return new rsvp.Promise(function (resolve, reject) {
                if (prepareExpandResult) {
                    expandProcessor.expand(prepareExpandResult.relationsTree, result, {
                        offlineModule: self
                    }, function (err, result) {
                        if (err) {
                            return reject(err);
                        }
                        resolve(result);
                    });
                } else {
                    resolve(result);
                }
            })
        },

        _getWithoutDeletedFilter: function (filter) {
            filter = filter || {};
            filter[constants.offlineItemsStateMarker] = {'$ne': offlineItemStates.deleted};
            return filter;
        },

        /**
         * Update items of a content type
         * @param dataQuery {DataQuery} - the data query
         * @param [filter] {Object}- The filter to apply when updating
         * @param isSync
         */
        update: function (dataQuery, filter) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                self._updateItems(dataQuery, dataQuery.data, filter, dataQuery.isSync, resolve, reject);
            });
        },

        /**
         * Remove items from a content type, based on a filter
         * @param dataQuery {DataQuery} - the data query
         * @param [filter] {Object} - Filter to apply when removing
         */
        remove: function (dataQuery, filter) {
            var self = this;
            return new rsvp.Promise(function (resolve, reject) {
                self._removeItems(dataQuery, filter, dataQuery.isSync, resolve, reject);
            });
        },

        count: function (dataQuery, filter) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                self._getCollection(dataQuery.collectionName)
                    .then(function (collection) {
                        var filterResult = self._readInternal(collection, filter);
                        resolve({result: filterResult.length});
                    }).catch(reject);
            });
        },

        goOnline: function (autoSync) {
            var self = this;
            this.settings.offline = false;

            if (autoSync === undefined) {
                autoSync = this.settings.autoSync;
            }

            if (autoSync) {
                this.sync();
            }
        },

        goOffline: function () {
            this.settings.offline = true;
        },

        isOnline: function () {
            return !this.settings.offline;
        },

        clearAll: function (success, error) {
            this._collectionCache = {};
            this.local.clearAll(success, error);
        },

        _prepareSyncData: function (contentTypesForSync) {
            var self = this;

            var contentTypesSyncData = {};
            var conflicts = [];
            _.map(contentTypesForSync, function (contentType, typeName) {
                var syncItems = offlineTransformations.idTransform(contentType.offlineItemsToSync);
                var syncData = self._getSyncItemStates(typeName, syncItems, contentType.serverItems);
                conflicts.push(syncData.conflicts);
                contentTypesSyncData[typeName] = syncData.itemsForSync;
            });

            return {
                conflicts: conflicts,
                contentTypesSyncData: contentTypesSyncData
            };
        },

        _resolveConflicts: function (syncData) {
            var self = this;
            return this._applyResolutionStrategy(syncData.conflicts)
                .then(self._mergeResolvedConflicts.bind(self, syncData.conflicts, syncData.contentTypesSyncData))
                .then(function () {
                    return syncData.contentTypesSyncData;
                });
        },

        isSynchronizing: function () {
            return this._isSynchronizing;
        },

        _fireSyncStart: function () {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                if (!self._isSynchronizing) {
                    self._isSynchronizing = true;
                    self.settings.syncStart(function (options) {
                        var syncOptions = {
                            cancel: false
                        };

                        _.extend(syncOptions, options);
                        if (syncOptions.cancel) {
                            self._isSynchronizing = false;
                            reject(EverliveErrors.syncCancelled);
                        } else {
                            resolve();
                        }
                    });
                } else {
                    resolve();
                }
            });
        },

        _fireSyncEnd: function () {
            this._isSynchronizing = false;
            this.settings.syncEnd.apply(this.everlive, arguments);
        },

        _addUpdatedItemsForSync: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            _.each(contentTypeData.modifiedItems, function (modifiedItem) {
                var modifiedItemFilter = getSyncFilterForItem(modifiedItem);
                syncPromises[modifiedItem.Id] =
                    dataCollection
                        .update(modifiedItem, modifiedItemFilter, {isSync: true, applyOffline: false})
                        .then(function (res) {
                            return self._onSyncResponse(res, modifiedItem, dataCollection.collectionName, DataQuery.operations.update);
                        });
            })
        },

        _onSyncResponse: function (res, item, collectionName, operation) {
            if (res.result !== 1) {
                return new rsvp.Promise(function (resolve, reject) {
                    reject(EverliveErrors.syncConflict);
                });
            } else {
                var updateQuery = new DataQuery({
                    operation: operation,
                    data: item,
                    additionalData: {
                        id: item.Id
                    },
                    collectionName: collectionName,
                    isSync: true
                });

                return this.processQuery(updateQuery);
            }
        },

        _addDeletedItemsForSync: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            _.each(contentTypeData.deletedItems, function (deletedItem) {
                var deletedItemFilter = getSyncFilterForItem(deletedItem);
                syncPromises[deletedItem.Id] =
                    dataCollection
                        .destroy(deletedItemFilter, {isSync: true, applyOffline: false})
                        .then(function (res) {
                            return self._onSyncResponse(res, deletedItem, dataCollection.collectionName, DataQuery.operations.remove);
                        });
            });
        },

        sync: function (success, error) {
            var self = this;
            return buildPromise(function (successCb, errorCb) {
                return self._fireSyncStart()
                    .then(function () { // omit any values returned by the client syncStart function
                        return self._syncGetServerItems();
                    })
                    .then(self._prepareSyncData.bind(self))
                    .then(self._resolveConflicts.bind(self))
                    .then(function (contentTypeSyncData) {
                        var syncPromises = {};
                        _.map(contentTypeSyncData, function (contentTypeData, typeName) {
                            var dataCollection = self.everlive.data(typeName);
                            if (contentTypeData.createdItems.length !== 0) {
                                syncPromises['create'] =
                                    dataCollection.create(contentTypeData.createdItems, {
                                        isSync: true,
                                        applyOffline: false
                                    }).then(function () {
                                        var dataQuery = new DataQuery({
                                            workOffline: true,
                                            operation: DataQuery.operations.create,
                                            data: contentTypeData.createdItems,
                                            collectionName: typeName,
                                            isSync: true
                                        });

                                        return self.processQuery(dataQuery);
                                    });
                            }

                            if (contentTypeData.modifiedItems.length !== 0) {
                                self._addUpdatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                            }

                            if (contentTypeData.deletedItems.length !== 0) {
                                self._addDeletedItemsForSync(contentTypeData, syncPromises, dataCollection);
                            }
                        });

                        return rsvp.hashSettled(syncPromises);
                    })
                    .then(function (syncResults) {
                        var failedSyncRequests = _.filter(syncResults, function (syncResult) {
                            if (syncResult && syncResult.state === 'rejected') {
                                return syncResult;
                            }
                        });

                        if (failedSyncRequests.length !== 0) {
                            return self.sync(successCb, errorCb);
                        } else {
                            self._fireSyncEnd();
                            return successCb(syncResults);
                        }
                    })
                    .catch(function (err) {
                        self._fireSyncEnd(err);
                        errorCb(err);
                    });
            }, success, error);
        },

        _handleKeepServer: function (typeName, conflictingItem, offlineSyncOperations) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var syncQuery;
            if (serverItem && clientItem) {
                // update the item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.update,
                    additionalOptions: {
                        id: serverItem.Id
                    },
                    data: serverItem
                });
            } else if (serverItem && !clientItem) {
                // create item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.create,
                    data: serverItem
                });
            } else if (!serverItem && clientItem) {
                // delete item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.removeSingle,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });
            } else {
                throw new EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepServer" resolution strategy.');
            }

            syncQuery.isSync = true;
            offlineSyncOperations.push(this.processQuery(syncQuery));
        },

        _handleKeepClient: function (conflictingItem, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            if (serverItem && clientItem) {
                var modifiedObject = _.extend(clientItem, {ModifiedAt: new Date(serverItem.ModifiedAt)});
                if (conflictingItem.result.force) {
                    delete modifiedObject.ModifiedAt;
                }

                contentTypeSyncData.modifiedItems.push(modifiedObject);
            } else if (serverItem && !clientItem) {
                contentTypeSyncData.deletedItems.push(serverItem);
            } else if (!serverItem && clientItem) {
                contentTypeSyncData.createdItems.push(clientItem);
            } else {
                throw new EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepClient" resolution strategy.');
            }
        },

        _handleCustom: function (conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var customItem = conflictingItem.result.item;
            if (serverItem && customItem && !clientItem) {
                var createItemOfflineQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.create,
                    data: customItem,
                    skipSyncCheck: true
                });

                offlineSyncOperations.push(this.processQuery(createItemOfflineQuery));
                contentTypeSyncData.modifiedItems.push(customItem);
            } else if (serverItem && !customItem) {
                contentTypeSyncData.deletedItems.push(serverItem);
            } else if (!serverItem && customItem && clientItem) {
                var updateItemOfflineQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.update,
                    data: customItem,
                    additionalOptions: {
                        id: clientItem.Id
                    },
                    skipSyncCheck: true
                });

                offlineSyncOperations.push(this.processQuery(updateItemOfflineQuery));

                contentTypeSyncData.createdItems.push(customItem);
            } else {
                contentTypeSyncData.modifiedItems.push(customItem);
            }
        },

        _mergeResolvedConflicts: function (conflicts, syncData) {
            var self = this;

            var offlineSyncOperations = [];
            _.each(conflicts, function (conflict) {
                var typeName = conflict.contentTypeName;
                _.each(conflict.conflictingItems, function (conflictingItem) {
                    var contentTypeSyncData = syncData[typeName];
                    switch (conflictingItem.result.resolutionType) {
                        case constants.ConflictResolution.KeepServer:
                            self._handleKeepServer(typeName, conflictingItem, offlineSyncOperations);
                            break;
                        case constants.ConflictResolution.KeepClient:
                            self._handleKeepClient(conflictingItem, contentTypeSyncData);
                            break;
                        case constants.ConflictResolution.Custom:
                            self._handleCustom(conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData);
                            break;
                    }
                });
            });

            return rsvp.all(offlineSyncOperations);
        },

        _getSyncItemStates: function (contentType, offlineItems, serverItems) {
            var contentTypeSyncData = {
                itemsForSync: {
                    createdItems: [],
                    modifiedItems: [],
                    deletedItems: []
                },
                conflicts: {
                    contentTypeName: contentType,
                    conflictingItems: []
                }
            };

            _.each(offlineItems, function (offlineItem) {
                var serverItem = _.findWhere(serverItems, {Id: offlineItem.Id});
                if (serverItem) {
                    var hasUpdateConflict = serverItem.ModifiedAt && (!offlineItem.ModifiedAt || serverItem.ModifiedAt.getTime() !== offlineItem.ModifiedAt.getTime());
                    if (hasUpdateConflict) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            // if the item was modified on the server and deleted locally we have a conflict and set the client item to null
                            // otherwise it is a simple modification conflict
                            clientItem: offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted ? null : offlineItem,
                            serverItem: serverItem,
                            result: {}
                        });
                    } else {
                        if (offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted) {
                            contentTypeSyncData.itemsForSync.deletedItems.push(offlineItem);
                        } else {
                            contentTypeSyncData.itemsForSync.modifiedItems.push(offlineItem);
                        }
                    }
                } else {
                    // if the item in memory has been modified, but the item on the server has been deleted
                    if (offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.modified) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            clientItem: offlineItem,
                            serverItem: null,
                            result: {}
                        });
                    } else {
                        contentTypeSyncData.itemsForSync.createdItems.push(offlineItem);
                    }
                }

                delete offlineItem[constants.offlineItemsStateMarker];
            });

            return contentTypeSyncData;
        },

        _setResolutionTypeForItem: function (resolutionType, force, conflictingItem) {
            conflictingItem.result = {
                resolutionType: resolutionType,
                force: force
            };
        },

        _applyResolutionStrategy: function (conflicts) {
            var self = this;
            var conflictResolutionStrategy = self.settings.conflictResolution;
            var promise = new rsvp.Promise(function (resolve, reject) {
                if (typeof conflictResolutionStrategy === 'function') {
                    conflictResolutionStrategy(conflicts, resolve);
                } else {
                    var conflictKeys = Object.keys(conflicts);
                    for (var i = 0; i < conflictKeys.length; i++) {
                        var key = conflictKeys[i];
                        var conflict = conflicts[key];
                        if (conflict.conflictingItems.length !== 0) {
                            switch (conflictResolutionStrategy) {
                                case constants.ConflictResolutionStrategy.ServerWins:
                                    _.each(conflict.conflictingItems,
                                        self._setResolutionTypeForItem.bind(self, constants.ConflictResolution.KeepServer));
                                    break;
                                case constants.ConflictResolutionStrategy.ClientWins:
                                    _.each(conflict.conflictingItems,
                                        self._setResolutionTypeForItem.bind(self, constants.ConflictResolution.KeepClient, true));
                                    break;
                                default:
                                    return reject(new EverliveError('Invalid resolution strategy provided'));
                            }
                        }
                    }

                    resolve();
                }
            });

            return promise;
        },

        _syncGetServerItems: function () {
            var self = this;
            return this._getAllCollections()
                .then(function (collections) {
                    var promises = {};
                    _.map(collections, function (collection, contentType) {
                        promises[contentType] = new rsvp.Promise(function (resolve, reject) {
                            var offlineItemsToSync = self._getDirtyItems(collection);
                            var syncIds = _.pluck(offlineItemsToSync, '_id');
                            var filter = {
                                'Id': {
                                    '$in': syncIds
                                }
                            };

                            var dataQuery = new DataQuery({
                                collectionName: contentType,
                                filter: filter,
                                operation: DataQuery.operations.read,
                                onSuccess: function (res) {
                                    resolve({
                                        offlineItemsToSync: offlineItemsToSync,
                                        serverItems: res.result
                                    });
                                },
                                onError: reject
                            });

                            var getRequestOptionsFromQuery = RequestOptionsBuilder[dataQuery.operation];
                            var requestOptions = getRequestOptionsFromQuery(dataQuery);
                            var request = new Request(self.everlive.setup, requestOptions);
                            request.send();
                        });
                    });

                    return rsvp.hash(promises);
                });
        },

        _getDirtyItems: function (collection) {
            var filter = {};
            filter[constants.offlineItemsStateMarker] = {$exists: true};
            var query = mingo.Query(filter);
            var cursor = mingo.Cursor(collection, query);
            return cursor.all();
        },

        _getAllCollections: function () {
            return new rsvp.Promise(this.local.getAllData.bind(this.local));
        },

        _getCollection: function (contentType) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                // check the persister if there is no data in the collection cache for this content type
                if (!self._collectionCache[contentType]) {
                    self.local.getData(contentType, function (data) {
                        self._collectionCache[contentType] = data || {};
                        resolve(self._collectionCache[contentType]);
                    }, reject);
                } else {
                    resolve(self._collectionCache[contentType]);
                }
            });
        },

        _persistData: function (contentType, success, error) {
            var contentTypeData = this._collectionCache[contentType];
            this.local.saveData(contentType, contentTypeData, success, error);
        },

        _getById: function (collection, id) {
            if (!id) {
                throw new EverliveError('Id field is mandatory when using offline storage');
            }

            if (collection[id]) {
                var item = _.extend({}, collection[id]);
                var isDeleted = item && item[constants.offlineItemsStateMarker] === offlineItemStates.deleted;

                return isDeleted ? undefined : item;
            }
        },

        _setItem: function (collection, item, state) {
            if (!this.isOnline()) {
                item[constants.offlineItemsStateMarker] = state;
            }
            collection[item._id] = item;
        },

        _createItems: function (contentType, items, isSync, success, error) {
            var self = this;
            this._getCollection(contentType)
                .then(function (collection) {
                    var itemsToCreate = _.isArray(items) ? items : [items];
                    var createdItems = [];
                    for (var i = 0; i < itemsToCreate.length; i++) {
                        var itemToCreate = itemsToCreate[i];
                        var itemCopy = _.extend({}, itemToCreate);

                        itemCopy._id = itemCopy.Id || uuid.v1();
                        delete itemCopy.Id;

                        var itemExists = itemCopy._id && !!self._getById(collection, itemCopy._id);
                        if (itemExists && !isSync) {
                            // TODO: [offline] return the same error as the server does
                            return error(new Error('An item with the specified id already exists'));
                        }

                        if (itemToCreate.CreatedAt && itemCopy.CreatedAt instanceof Date) {
                            itemCopy.CreatedAt = utils.cloneDate(itemToCreate.CreatedAt);
                        } else {
                            itemCopy.CreatedAt = new Date();
                        }

                        if (itemToCreate.ModifiedAt && itemsToCreate.ModifiedAt instanceof Date) {
                            itemCopy.ModifiedAt = utils.cloneDate(itemToCreate.ModifiedAt);
                        } else {
                            itemCopy.ModifiedAt = utils.cloneDate(itemCopy.CreatedAt);
                        }

                        var state = isSync ? undefined : offlineItemStates.created; // set the state to created only if not syncing
                        self._setItem(collection, itemCopy, state);
                        createdItems.push(itemCopy);
                    }

                    self._persistData(contentType, function () {
                        success(createdItems);
                    }, error);
                }, error)
        },

        _applyUpdateOperation: function (originalUpdateExpression, itemToUpdate, collection, hasDbOperator, isSync) {
            var updateExpression;
            if (!hasDbOperator) {
                updateExpression = {
                    $set: _.extend({}, originalUpdateExpression)
                };
            } else {
                updateExpression = _.extend({}, originalUpdateExpression);
            }

            updateExpression.$set = _.extend({}, updateExpression.$set);

            if (isSync) {
                updateExpression.$set.ModifiedAt = utils.cloneDate(itemToUpdate.ModifiedAt);
            } else {
                updateExpression.$set.ModifiedAt = new Date();
            }

            mongoQuery(itemToUpdate, {}, updateExpression, {strict: true}); // Setting strict to true so only exact matches would be updated

            itemToUpdate._id = itemToUpdate._id || updateExpression._id || updateExpression.Id;
            delete itemToUpdate.Id;

            var newState;
            if (isSync) {
                newState = null;
            } else if (itemToUpdate[constants.offlineItemsStateMarker] === offlineItemStates.created) {
                newState = offlineItemStates.created;
            } else {
                newState = offlineItemStates.modified;
            }
            this._setItem(collection, itemToUpdate, newState);
        },

        _updateItems: function (dataQuery, updateExpression, filter, isSync, resolve, reject) {
            var self = this;

            self._getCollection(dataQuery.collectionName)
                .then(function (collection) {
                    var updateItems;

                    var dbOperators = utils.getDbOperators(updateExpression, true);
                    var hasDbOperator = dbOperators.length !== 0;

                    if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
                        itemToUpdate = self._getById(collection, dataQuery.additionalOptions.id);
                        self._applyUpdateOperation(updateExpression, itemToUpdate, collection, hasDbOperator, isSync);
                        updateItems = [itemToUpdate];
                    } else {
                        updateItems = self._readInternal(collection, filter);
                        for (var i = 0; i < updateItems.length; i++) {
                            var itemToUpdate = updateItems[i];
                            var itemExists = !!self._getById(collection, itemToUpdate._id.toString());

                            if (!itemExists && !isSync) {
                                return reject(EverliveErrors.itemNotFound);
                            }

                            self._applyUpdateOperation(updateExpression, itemToUpdate, collection, hasDbOperator, isSync);
                        }
                    }

                    self._persistData(dataQuery.collectionName, function () {
                        var result = {
                            ModifiedAt: updateItems[0].ModifiedAt,
                            result: updateItems.length
                        };

                        resolve(result);
                    }, reject);
                });
        },

        _clearItem: function (collection, item) {
            delete collection[item._id];
        },

        _removeItems: function (dataQuery, filter, isSync, resolve, reject) {
            var self = this;

            self._getCollection(dataQuery.collectionName)
                .then(function (collection) {
                    var itemsToRemove = self._readInternal(collection, filter);

                    for (var i = 0; i < itemsToRemove.length; i++) {
                        var itemToRemove = itemsToRemove[i];
                        itemToRemove._id = itemToRemove._id || itemToRemove.Id;
                        var itemExists = !!self._getById(collection, itemToRemove._id.toString());

                        if (!itemExists && !isSync) {
                            return reject(new EverliveError('Cannot delete item - item with id ' + itemToRemove._id + ' does not exist.'));
                        }

                        var removeFromMemory = itemToRemove[constants.offlineItemsStateMarker] === offlineItemStates.created || isSync;
                        if (removeFromMemory) {
                            self._clearItem(collection, itemToRemove);
                        } else {
                            self._setItem(collection, itemToRemove, offlineItemStates.deleted);
                        }
                    }

                    self._persistData(dataQuery.collectionName, function () {
                        var response = self._transformOfflineResult(itemsToRemove.length);
                        resolve(response);
                    }, reject);
                });
        },

        _applyTransformations: function (transformedResult, transformations) {
            if (Array.isArray(transformedResult.result)) {
                _.each(transformations, function (transformation) {
                    transformedResult.result.map(function (value, key) {
                        transformedResult.result[key] = transformation(value);
                    });
                });
            } else {
                _.each(transformations, function (transformation) {
                    transformedResult.result = transformation(transformedResult.result);
                });
            }
        },

        _transformOfflineResult: function (resultSet, count, dataQuery, additionalTransformations) {
            var transformedResult = {
                result: resultSet,
                count: count || (resultSet || []).length
            };

            if ((count !== undefined && count !== null) || Array.isArray(resultSet)) {
                transformedResult.count = count || resultSet.length;
            }

            var transformations = [];
            transformations.push(offlineTransformations.idTransform);
            transformations.push(offlineTransformations.removeMarkersTransform);

            if (dataQuery) {
                var includeCount = dataQuery.getHeader(Headers.includeCount);
                if (includeCount === false) {
                    delete transformedResult.count;
                }

                var singleFieldExpression = dataQuery.getHeader(Headers.singleField);
                if (typeof singleFieldExpression === 'string') {
                    transformations.push(offlineTransformations.singleFieldTransform.bind(this, singleFieldExpression));
                }
            }

            if (additionalTransformations) {
                transformations = transformations.concat(additionalTransformations);
            }

            this._applyTransformations(transformedResult, transformations);

            if (transformedResult.count === undefined) {
                delete transformedResult.count;
            }

            return transformedResult;
        }
    };

    return OfflineModule;
})();
},{"../EverliveError":53,"../ExpandProcessor":54,"../Request":58,"../common":60,"../constants":61,"../query/DataQuery":69,"../query/RequestOptionsBuilder":72,"../utils":77,"./offlineTransformations":68}],66:[function(require,module,exports){
var constants = require('../constants');
var persistersModule = require('./offlinePersisters');
var LocalStoragePersister = persistersModule.LocalStoragePersister;
var FileSystemPersister = persistersModule.FileSystemPersister;
var OfflineStorageModule = require('./OfflineStorageModule');
var EverliveError = require('../EverliveError').EverliveError;
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;

var defaultOfflineStorageOptions = {
    autoSync: true,
    conflictResolution: constants.ConflictResolutionStrategy.ClientWins,
    offline: false,
    providerType: constants.StorageProviders.LocalStorage,
    syncStart: function (cb) {
        cb();
    },
    syncEnd: _.noop,
    syncInterval: constants.defaultSyncInterval
};

module.exports = (function () {

    var conflictResolutionStrategies = {};

    conflictResolutionStrategies[constants.ConflictResolutionStrategy.ClientWins] = function (collection, local, server) {
        return new rsvp.Promise(function (resolve) {
            resolve(local);
        });
    };

    conflictResolutionStrategies[constants.ConflictResolutionStrategy.ServerWins] = function (collection, local, server) {
        return new rsvp.Promise(function (resolve) {
            resolve(server);
        });
    };

    var buildOfflineStorageModule = function (storageOptions) {
        var options;
        if (storageOptions === true) { // explicit check for shorthand initialization
            options = _.defaults({}, defaultOfflineStorageOptions);
        } else if (_.isObject(storageOptions) && storageOptions.provider) {
            options = _.defaults(storageOptions, defaultOfflineStorageOptions);
        } else {
            return;
        }

        var persister;
        var persisterType = options.providerType;
        var storageKey = storageOptions.name || 'everliveOfflineStorage_' + this.setup.apiKey;
        if (typeof persisterType === 'function') {
            persister = new storageOptions.providerType(storageKey, storageOptions.customOptions);
            throw new EverliveError('Custom storage not yet supported');
        } else {
            switch (persisterType) {
                case constants.StorageProviders.LocalStorage:
                    persister = new LocalStoragePersister(storageKey);
                    break;
                case constants.StorageProviders.FileSystem:
                    persister = new FileSystemPersister(storageKey);
                    break;
                default:
                    throw new EverliveError('Unsupported storage type');
            }
        }

        return new OfflineStorageModule(this, options, persister);
    };

    var initOfflineStorage = function (options) {
        if (!options || !options.offlineStorage) {
            return;
        }

        this.storage = buildOfflineStorageModule.call(this, options.offlineStorage);
    };

    return {
        initOfflineStorage: initOfflineStorage
    }
}());
},{"../EverliveError":53,"../common":60,"../constants":61,"./OfflineStorageModule":65,"./offlinePersisters":67}],67:[function(require,module,exports){
var platform = require('../everlive.platform');
var isNativeScriptApplication = platform.isNativeScript;
var isCordovaApplication = platform.isCordova;
var common = require('../common');
var rsvp = common.rsvp;
var _ = common._;
var parseUtilities = require('../utils').parseUtilities;
var EverliveError = require('../EverliveError').EverliveError;

/**
 * Can be one of the following types: {@link LocalStoragePersister},
 * {@link FileSystemPersister} or a custom based on {@link BasePersister}
 * @memberOf OfflineModule
 * @instance
 * @member {BasePersister} local
 */

var BasePersister = (function () {

    /**
     * @class BasePersister
     * @classdesc An abstraction layer for all persisters. Every persister can write/read
     * data from a specific place. The data is saved as key-value pairs where the keys are
     * content types.
     */
    function BasePersister() {
    }

    BasePersister.prototype = {
        /**
         * Gets all the saved data.
         * @method getAllData
         * @memberof BasePersister
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @returns {Object} Keys are the content types and the values are the corresponding data
         */
        getAllData: function (success, error) {
            throw new EverliveError('The method getAllData is not implemented');
        },

        /**
         * Returns the saved data for a specific content type
         * @method getData
         * @param {string} contentType The content type for which to retreive the data
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @memberof BasePersister
         * @returns {Object} The retreved data
         */
        getData: function (contentType, success, error) {
            throw new EverliveError('The method getData is not implemented');
        },

        /**
         * Saves data for a specific content type
         * @method saveData
         * @param {string} contentType The content for which to save the data
         * @param {object} data The data coresponding to the specified content type
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @memberof BasePersister
         */
        saveData: function (contentType, data, success, error) {
            throw new EverliveError('The method saveData is not implemented');
        },

        /**
         * Clears the persisted data for a specific content type
         * @method clear
         * @param {string} contentType The content type for which to clear the data
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @memberof BasePersister
         */
        clear: function (contentType, success, error) {
            throw new EverliveError('The method clear is not implemented');
        },

        /**
         * Clears the persisted data for a content type
         * @method clearAll
         * @memberof BasePersister
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         */
        clearAll: function (success, error) {
            throw new EverliveError('The method clearAll is not implemented');
        },

        _getKey: function (contentType) {
            return this.key + '_' + contentType;
        }
    };

    return BasePersister;
}());

var LocalStoragePersister = (function () {
    /**
     * @class LocalStoragePersister
     * @extends BasePersister
     */
    function LocalStoragePersister(key) {
        this.key = key;

        if (isNativeScriptApplication) {
            this.localSettings = require('local-settings');
        }
    }

    _.extend(LocalStoragePersister.prototype, BasePersister.prototype, {
        getAllData: function (success, error) {
            var self = this;
            var contentTypes = this._getContentTypes();
            var allCollections = {};
            _.each(contentTypes, function (contentType) {
                allCollections[contentType] = new rsvp.Promise(function (resolve, reject) {
                    self.getData(contentType, resolve, reject);
                });
            });

            rsvp.hash(allCollections).then(success, error);
        },

        getData: function (contentType, success, error) {
            var key = this._getKey(contentType);
            var storedItem = this._getItem(key) || '{}';
            var reviver = parseUtilities.getReviver();
            var storedItemObject = JSON.parse(storedItem, reviver);
            success(storedItemObject);
        },

        saveData: function (contentType, data, success, error) {
            var collectionsString = JSON.stringify(data);
            var contentTypeKey = this._getKey(contentType);
            this._setItem(contentTypeKey, collectionsString);
            success();
        },

        clear: function (contentType, success, error) {
            var key = this._getKey(contentType);
            this._removeItem(key);
            success();
        },

        clearAll: function (success, error) {
            var self = this;

            var contentTypes = this._getContentTypes();
            _.each(contentTypes, function (contentType) {
                var contentTypeKey = self._getKey(contentType);
                self._removeItem(contentTypeKey);
            });

            var contentTypesKey = this._getContentTypesCollectionKey();
            this._removeItem(contentTypesKey);

            success();
        },

        _getItem: function (key) {
            if (isNativeScriptApplication) {
                return this.localSettings.getString(key);
            }

            return localStorage.getItem(key);
        },

        _removeItem: function (key) {
            if (isNativeScriptApplication) {
                return this.localSettings.remove(key);
            }

            localStorage.removeItem(key);
        },

        _setItem: function (key, value) {
            if (isNativeScriptApplication) {
                return this.localSettings.setString(key, value);
            }

            return localStorage.setItem(key, value);
        },

        _getKey: function (contentType) {
            this._addTypeToCollectionsCache(contentType);
            return this.key + '_' + contentType;
        },

        _getContentTypesCollectionKey: function () {
            return this.key + '@ContentTypes';
        },

        _getContentTypes: function () {
            var collectionKey = this._getContentTypesCollectionKey();
            var localStorageString = this._getItem(collectionKey);

            if (localStorageString) {
                return JSON.parse(localStorageString);
            }

            return [];
        },

        _setContentTypesCollection: function (collection) {
            var collectionKey = this._getContentTypesCollectionKey();
            this._setItem(collectionKey, JSON.stringify(collection));
        },

        _addTypeToCollectionsCache: function (typeName) {
            var contentTypesCollection = this._getContentTypes();
            if (!_.contains(contentTypesCollection, typeName)) {
                contentTypesCollection.push(typeName);
                this._setContentTypesCollection(contentTypesCollection);
            }
        }
    });

    return LocalStoragePersister;
}());

var FileSystemPersister = (function () {
    /**
     * @class FileSystemPersister
     * @extends BasePersister
     */
    function FileSystemPersister(key) {
        var separator = '/';
        if (!isCordovaApplication && !isNativeScriptApplication) {
            throw new EverliveError('FileSystemPersister can be used only with Cordova and NativeScript');
        }

        if (isCordovaApplication) {
            if (!cordova && !cordova.file) {
                throw new EverliveError('You need to enable the cordova file plugin to use file offline storage. ' +
                'Make sure to initialize your Everlive instance after the "deviceReady" event has fired.');
            }

            this.dataDirectoryPath = cordova.file.dataDirectory;
        } else if (isNativeScriptApplication) {
            this.fs = require('file-system');
            separator = this.fs.path.separator;
            this.dataDirectoryPath = this.fs.knownFolders.currentApp().path;
        }

        this.key = key;
        this.contentTypesStoreKey = '@ContentTypes';
        this.filesDirectoryPath = 'el_store' + separator;
    }

    _.extend(FileSystemPersister.prototype, BasePersister.prototype, {
        getAllData: function (success, error) {
            var self = this;
            var errorHandler = this._fileSystemErrorHandler(error);
            var promises = {};
            this._getContentTypesMetadata(function (contentTypes) {
                Object.keys(contentTypes).forEach(function (contentType) {
                    promises[contentType] = new rsvp.Promise(function (resolve, reject) {
                        self.getData(contentType, resolve, reject);
                    });
                });

                rsvp.hash(promises).then(success, errorHandler);
            }, errorHandler);
        },

        getData: function (contentType, success, error) {
            var self = this;
            var errorHandler = this._fileSystemErrorHandler(error);
            this._getFileFull(contentType, function (fileEntry) {
                self._readFileContent(fileEntry, success, errorHandler);
            });
        },

        saveData: function (contentType, data, success, error) {
            var self = this;
            var dataString = JSON.stringify(data);
            var errorHandler = this._fileSystemErrorHandler(error);
            this._getFileFull(contentType, function (fileEntry) {
                self._writeFileContent(fileEntry, dataString, function () {
                    self._saveContentTypesMetadata(contentType, success, errorHandler);
                }, errorHandler);
            }, errorHandler);
        },

        clear: function (contentType, success, error) {
            var self = this;
            var errorHandler = this._fileSystemErrorHandler(error);
            this._getFileFull(contentType, function (fileEntry) {
                self._removeFile(fileEntry, success, error);
            }, errorHandler);
        },

        clearAll: function (success, error) {
            var self = this;
            var errorHandler = this._fileSystemErrorHandler(error);
            this._resolveDataDirectory(function (dataDirEntry) {
                self._removeFilesDirectory(dataDirEntry, success, errorHandler);
            }, errorHandler);
        },

        _getContentTypesMetadata: function (success, error) {
            this.getData(this.contentTypesStoreKey, success, error);
        },

        _saveContentTypesMetadata: function (contentType, success, error) {
            var self = this;
            this._getContentTypesMetadata(function (savedContentTypes) {
                savedContentTypes[contentType] = true;
                self._getFileFull(self.contentTypesStoreKey, function (contentTypesFile) {
                    self._writeFileContent(contentTypesFile, JSON.stringify(savedContentTypes), success, error);
                }, error);
            });
        },

        _getFileFull: function (contentType, success, error) {
            var self = this;
            this._ensureFilesDirectory(function () {
                var path = self._getFilePath(contentType);
                self._getFile(path, success, error);
            }, error);
        },

        _removeFilesDirectory: function (directoryEntry, success, error) {
            if (isCordovaApplication) {
                directoryEntry.getDirectory(this.filesDirectoryPath, {
                    create: true,
                    exclusive: false
                }, function (filesDirEntry) {
                    filesDirEntry.removeRecursively(function () {
                        success();
                    }, error);
                }, error)
            } else if (isNativeScriptApplication) {
                var filesDirectoryPath = this.fs.path.join(directoryEntry.path, this.filesDirectoryPath);
                var filesDirectory = this.fs.Folder.fromPath(filesDirectoryPath);
                filesDirectory.remove().then(success, error);
            }
        },

        _removeFile: function (fileEntry, success, error) {
            if (isCordovaApplication) {
                fileEntry.remove(function () {
                    success();
                }, error);
            } else if (isNativeScriptApplication) {
                fileEntry.remove().then(success, error);
            }
        },

        _readFileContent: function (fileEntry, success, error) {
            var readTextSuccess = function (content) {
                var reviver = parseUtilities.getReviver();
                var resultObject = JSON.parse(content || '{}', reviver);
                success(resultObject);
            };

            if (isCordovaApplication) {
                fileEntry.file(function (file) {
                    var reader = new FileReader();
                    reader.onloadend = function () {
                        readTextSuccess(this.result);
                    };
                    reader.onerror = error;
                    reader.readAsText(file);
                }, error);
            } else if (isNativeScriptApplication) {
                fileEntry.readText().then(readTextSuccess, error);
            }
        },

        _writeFileContent: function (fileEntry, content, success, error) {
            if (isCordovaApplication) {
                fileEntry.createWriter(function (fileWriter) {
                    fileWriter.onwriteend = function () {
                        success();
                    };
                    fileWriter.onerror = error;
                    fileWriter.write(content);
                }, error);
            } else if (isNativeScriptApplication) {
                fileEntry.writeText(content).then(success, error);
            }
        },

        _getFile: function (path, success, error) {
            this._resolveDataDirectory(function (directoryEntry) {
                if (isCordovaApplication) {
                    directoryEntry.getFile(path, {
                        create: true,
                        exclusive: false
                    }, success, error);
                } else if (isNativeScriptApplication) {
                    var fullFilePath = this.fs.path.join(directoryEntry.path, path);
                    var file = this.fs.File.fromPath(fullFilePath);
                    success(file);
                }
            }.bind(this), error)
        },

        _getFilePath: function (contentType) {
            return this.filesDirectoryPath + this._getKey(contentType);
        },

        _resolveDataDirectory: function (success, error) {
            if (isCordovaApplication) {
                resolveLocalFileSystemURL(this.dataDirectoryPath, success, error);
            } else if (isNativeScriptApplication) {
                var dataDirectory = this.fs.Folder.fromPath(this.dataDirectoryPath);
                success(dataDirectory);
            }
        },

        _ensureFilesDirectory: function (success, error) {
            var filesDirectoryPath = this.filesDirectoryPath;
            this._resolveDataDirectory(function (directoryEntry) {
                if (isCordovaApplication) {
                    directoryEntry.getDirectory(filesDirectoryPath, {
                        create: true,
                        exclusive: false
                    }, success, error);
                } else if (isNativeScriptApplication) {
                    var fileDirectoryPath = this.fs.path.join(directoryEntry.path, filesDirectoryPath);
                    this.fs.Folder.fromPath(fileDirectoryPath);
                    success();
                }
            }.bind(this), error);
        },

        _fileSystemErrorHandler: function (callback) {
            if (!isNativeScriptApplication) {
                var errorsMap = {};
                _.each(Object.keys(FileError), function (error) {
                    errorsMap[FileError[error]] = error;
                });

                return function (e) {
                    var msg = errorsMap[e.code];
                    console.log('Error: ' + msg);
                    e.message = msg;
                    callback && callback(e);
                }
            }

            return function (e) {
                console.log('Error: ' + JSON.stringify(e));
                callback && callback(e);
            }
        }
    });

    return FileSystemPersister;
}());

module.exports = {
    BasePersister: BasePersister,
    LocalStoragePersister: LocalStoragePersister,
    FileSystemPersister: FileSystemPersister
};
},{"../EverliveError":53,"../common":60,"../everlive.platform":62,"../utils":77,"file-system":"file-system","local-settings":"local-settings"}],68:[function(require,module,exports){
'use strict';

var constants = require('../constants');
var _ = require('../common')._;
var offlineItemStateMarker = constants.offlineItemsStateMarker;

var offlineTransformations = {
    idTransform: function (value) {
        if (_.isArray(value)) {
            return _.map(value, function (item) {
                return offlineTransformations.idTransform(item);
            });
        }

        if (typeof value === 'object' && value._id && !value.Id) {
            value.Id = value._id;
            delete value._id;
        }

        return value;
    },
    singleFieldTransform: function (singleFieldExpression, value) {
        if (typeof value === 'undefined' || value === null) {
            return null;
        } else {
            return value[singleFieldExpression];
        }
    },
    traverseAndTransformFilterId: function (filterObj) {
        if (filterObj && filterObj.Id) {
            filterObj._id = filterObj.Id;
            delete filterObj.Id;
        }

        for (var prop in filterObj) {
            if (filterObj.hasOwnProperty(prop)) {
                var objectMember = filterObj[prop];
                if (typeof objectMember === 'object') {
                    offlineTransformations.traverseAndTransformFilterId(objectMember);
                }
            }
        }
    },
    removeMarkersTransform: function (value) {
        delete value[offlineItemStateMarker];
        return value;
    }
};

module.exports = offlineTransformations;
},{"../common":60,"../constants":61}],69:[function(require,module,exports){
var _ = require('../common')._;

module.exports = (function () {
    // TODO: [offline] Update the structure - filter field can be refactored for example and a skip/limit/sort property can be added
    var DataQuery = function (config) {
        this.collectionName = config.collectionName;
        this.headers = config.headers || {};
        this.filter = config.filter;
        this.onSuccess = config.onSuccess;
        this.onError = config.onError;
        this.operation = config.operation;
        this.parse = config.parse;
        this.additionalOptions = config.additionalOptions;
        this.data = config.data;
        this.workOffline = config.workOffline;
        this.applyOffline = config.applyOffline;
        this._normalizedHeaders = null;
        this.isSync = config.isSync;
    };

    DataQuery.prototype = {
        getHeader: function (header) {
            var self = this;
            var headerKeys = Object.keys(this.headers);

            if (!this._normalizedHeaders) {
                this._normalizedHeaders = {};
                _.each(headerKeys, function (headerKey) {
                    var normalizedKey = headerKey.toLowerCase();
                    var headerValue = self.headers[headerKey];
                    self._normalizedHeaders[normalizedKey] = headerValue;
                });
            }

            var normalizedHeader = header.toLowerCase();
            return this._normalizedHeaders[normalizedHeader];
        },

        getHeaderAsJSON: function (header) {
            var headerValue = this._normalizedHeaders[header.toLowerCase()];
            if (headerValue) {
                return JSON.parse(headerValue);
            }
        },

        setOptions: function (operationParameters) {
            this.workOffline = operationParameters.workOffline;
            this.applyOffline = operationParameters.applyOffline;
            this.isSync = operationParameters.isSync;
        }
    };

    DataQuery.operations = {
        read: 'read',
        create: 'create',
        update: 'update',
        remove: 'destroy',
        removeSingle: 'destroySingle',
        readById: 'readById',
        count: 'count',
        rawUpdate: 'rawUpdate',
        setAcl: 'setAcl',
        setOwner: 'setOwner',
        userLogin: 'login',
        userLogout: 'logout',
        userChangePassword: 'changePassword',
        userLoginWithProvider: 'loginWith',
        userLinkWithProvider: 'linkWith',
        userUnlinkFromProvider: 'unlinkFrom',
        filesUpdateContent: 'updateContent',
        filesGetDownloadUrlById: 'downloadUrlById'
    };

    return DataQuery;
}());
},{"../common":60}],70:[function(require,module,exports){
var Expression = require('../Expression');
var OperatorType = require('../constants').OperatorType;
var WhereQuery = require('./WhereQuery');
var QueryBuilder = require('./QueryBuilder');

module.exports = (function () {
    /**
     * @class Query
     * @classdesc A query class used to describe a request that will be made to the {{site.TelerikBackendServices}} JavaScript API.
     * @param {object} [filter] A [filter expression]({% slug rest-api-querying-filtering %}) definition.
     * @param {object} [fields] A [fields expression]({% slug rest-api-querying-Subset-of-fields %}) definition.
     * @param {object} [sort] A [sort expression]({% slug rest-api-querying-sorting %}) definition.
     * @param {number} [skip] Number of items to skip. Used for paging.
     * @param {number} [take] Number of items to take. Used for paging.
     * @param {object} [expand] An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
     */
    function Query(filter, fields, sort, skip, take, expand) {
        this.filter = filter;
        this.fields = fields;
        this.sort = sort;
        this.toskip = skip;
        this.totake = take;
        this.expand = expand;
        this.expr = new Expression(OperatorType.query);
    }

    Query.prototype = {
        /** Applies a filter to the current query. This allows you to retrieve only a subset of the items based on various filtering criteria.
         * @memberOf Query.prototype
         * @method where
         * @name where
         * @param {object} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Query}
         */
        /** Defines a filter definition for the current query.
         * @memberOf Query.prototype
         * @method where
         * @name where
         * @returns {WhereQuery}
         */
        where: function (filter) {
            if (filter) {
                return this._simple(OperatorType.filter, [filter]);
            }
            else {
                return new WhereQuery(this);
            }
        },
        /** Applies a fields selection to the current query. This allows you to retrieve only a subset of all available item fields.
         * @memberOf Query.prototype
         * @method select
         * @param {object} fieldsExpression A [fields expression]({% slug rest-api-querying-Subset-of-fields %}) definition.
         * @returns {Query}
         */
        select: function () {
            return this._simple(OperatorType.select, arguments);
        },
        // TODO
        //exclude: function () {
        //    return this._simple(OperatorType.exclude, arguments);
        //},
        /** Sorts the items in the current query in ascending order by the specified field.
         * @memberOf Query.prototype
         * @method order
         * @param {string} field The field name to order by in ascending order.
         * @returns {Query}
         */
        order: function (field) {
            return this._simple(OperatorType.order, [field]);
        },
        /** Sorts the items in the current query in descending order by the specified field.
         * @memberOf Query.prototype
         * @method orderDesc
         * @param {string} field The field name to order by in descending order.
         * @returns {Query}
         */
        orderDesc: function (field) {
            return this._simple(OperatorType.order_desc, [field]);
        },
        /** Skips a certain number of items from the beginning before returning the rest of the items. Used for paging.
         * @memberOf Query.prototype
         * @method skip
         * @see [query.take]{@link query.take}
         * @param {number} value The number of items to skip.
         * @returns {Query}
         */
        skip: function (value) {
            return this._simple(OperatorType.skip, [value]);
        },
        /** Takes a specified number of items from the query result. Used for paging.
         * @memberOf Query.prototype
         * @method take
         * @see [query.skip]{@link query.skip}
         * @param {number} value The number of items to take.
         * @returns {Query}
         */
        take: function (value) {
            return this._simple(OperatorType.take, [value]);
        },
        /** Sets an expand expression for the current query. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Query.prototype
         * @method expand
         * @param {object} expandExpression An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
         * @returns {Query}
         */
        expand: function (expandExpression) {
            return this._simple(OperatorType.expand, [expandExpression]);
        },
        /** Builds an object containing the different expressions that will be sent to {{site.TelerikBackendServices}}. It basically translates any previously specified expressions into standard queries that {{site.bs}} can understand.
         * @memberOf Query.prototype
         * @method build
         * @returns {{$where,$select,$sort,$skip,$take,$expand}}
         */
        build: function () {
            return new QueryBuilder(this).build();
        },
        _simple: function (op, oprs) {
            var args = [].slice.call(oprs);
            this.expr.addOperand(new Expression(op, args));
            return this;
        }
    };

    return Query;
}());
},{"../Expression":55,"../constants":61,"./QueryBuilder":71,"./WhereQuery":73}],71:[function(require,module,exports){
var constants = require('../constants');
var OperatorType = constants.OperatorType;
var _ = require('../common')._;
var GeoPoint = require('../GeoPoint');
var EverliveError = require('../EverliveError').EverliveError;
var Expression = require('../Expression');
var maxDistanceConsts = constants.maxDistanceConsts;
var radiusConsts = constants.radiusConsts;

module.exports = (function () {
    function QueryBuilder(query) {
        this.query = query;
        this.expr = query.expr;
    }

    QueryBuilder.prototype = {
        // TODO merge the two objects before returning them
        build: function () {
            var query = this.query;
            if (query.filter || query.fields || query.sort || query.toskip || query.totake || query.expand) {
                return {
                    $where: query.filter || null,
                    $select: query.fields || null,
                    $sort: query.sort || null,
                    $skip: query.toskip || null,
                    $take: query.totake || null,
                    $expand: query.expand || null
                };
            }
            return {
                $where: this._buildWhere(),
                $select: this._buildSelect(),
                $sort: this._buildSort(),
                $skip: this._getSkip(),
                $take: this._getTake(),
                $expand: this._getExpand()
            };
        },
        _getSkip: function () {
            var skipExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.skip;
            });
            return skipExpression ? skipExpression.operands[0] : null;
        },
        _getTake: function () {
            var takeExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.take;
            });
            return takeExpression ? takeExpression.operands[0] : null;
        },
        _getExpand: function () {
            var expandExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.expand;
            });
            return expandExpression ? expandExpression.operands[0] : null;
        },
        _buildSelect: function () {
            var selectExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.select;
            });
            var result = {};
            if (selectExpression) {
                _.reduce(selectExpression.operands, function (memo, value) {
                    memo[value] = 1;
                    return memo;
                }, result);
                return result;
            }
            else {
                return null;
            }
        },
        _buildSort: function () {
            var sortExpressions = _.filter(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.order || value.operator === OperatorType.order_desc;
            });
            var result = {};
            if (sortExpressions.length > 0) {
                _.reduce(sortExpressions, function (memo, value) {
                    memo[value.operands[0]] = value.operator === OperatorType.order ? 1 : -1;
                    return memo;
                }, result);
                return result;
            }
            else {
                return null;
            }
        },
        _buildWhere: function () {
            var whereExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.where;
            });
            if (whereExpression) {
                return this._build(new Expression(OperatorType.and, whereExpression.operands));
            }
            else {
                var filterExpression = _.find(this.expr.operands, function (value, index, list) {
                    return value.operator === OperatorType.filter;
                });
                if (filterExpression) {
                    return filterExpression.operands[0];
                }
                return null;
            }
        },
        _build: function (expr) {
            if (this._isSimple(expr)) {
                return this._simple(expr);
            }
            else if (this._isRegex(expr)) {
                return this._regex(expr);
            }
            else if (this._isGeo(expr)) {
                return this._geo(expr);
            }
            else if (this._isAnd(expr)) {
                return this._and(expr);
            }
            else if (this._isOr(expr)) {
                return this._or(expr);
            }
            else if (this._isNot(expr)) {
                return this._not(expr);
            }
        },
        _isSimple: function (expr) {
            return expr.operator >= OperatorType.equal && expr.operator <= OperatorType.size;
        },
        _simple: function (expr) {
            var term = {}, fieldTerm = {};
            var operands = expr.operands;
            var operator = this._translateoperator(expr.operator);
            if (operator) {
                term[operator] = operands[1];
            }
            else {
                term = operands[1];
            }
            fieldTerm[operands[0]] = term;
            return fieldTerm;
        },
        _isRegex: function (expr) {
            return expr.operator >= OperatorType.regex && expr.operator <= OperatorType.endsWith;
        },
        _regex: function (expr) {
            var fieldTerm = {};
            var regex = this._getRegex(expr);
            var regexValue = this._getRegexValue(regex);
            var operands = expr.operands;
            fieldTerm[operands[0]] = regexValue;
            return fieldTerm;
        },
        _getRegex: function (expr) {
            var pattern = expr.operands[1];
            var flags = expr.operands[2] ? expr.operands[2] : '';
            switch (expr.operator) {
                case OperatorType.regex:
                    return pattern instanceof RegExp ? pattern : new RegExp(pattern, flags);
                case OperatorType.startsWith:
                    return new RegExp("^" + pattern, flags);
                case OperatorType.endsWith:
                    return new RegExp(pattern + "$", flags);
                default:
                    throw new EverliveError('Unknown operator type.');
            }
        },
        _getRegexValue: function (regex) {
            var options = '';
            if (regex.global) {
                options += 'g';
            }
            if (regex.multiline) {
                options += 'm';
            }
            if (regex.ignoreCase) {
                options += 'i';
            }
            return {$regex: regex.source, $options: options};
        },
        _isGeo: function (expr) {
            return expr.operator >= OperatorType.nearShpere && expr.operator <= OperatorType.withinShpere;
        },
        _geo: function (expr) {
            var fieldTerm = {};
            var operands = expr.operands;
            fieldTerm[operands[0]] = this._getGeoTerm(expr);
            return fieldTerm;
        },
        _getGeoTerm: function (expr) {
            switch (expr.operator) {
                case OperatorType.nearShpere:
                    return this._getNearSphereTerm(expr);
                case OperatorType.withinBox:
                    return this._getWithinBox(expr);
                case OperatorType.withinPolygon:
                    return this._getWithinPolygon(expr);
                case OperatorType.withinShpere:
                    return this._getWithinCenterSphere(expr);
                default:
                    throw new EverliveError('Unknown operator type.');
            }
        },
        _getNearSphereTerm: function (expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var maxDistance = operands[2];
            var metrics = operands[3];
            var maxDistanceConst;
            var term = {
                '$nearSphere': center
            };
            if (typeof maxDistance !== 'undefined') {
                maxDistanceConst = maxDistanceConsts[metrics] || maxDistanceConsts.radians;
                term[maxDistanceConst] = maxDistance;
            }
            return term;
        },
        _getWithinBox: function (expr) {
            var operands = expr.operands;
            var bottomLeft = this._getGeoPoint(operands[1]);
            var upperRight = this._getGeoPoint(operands[2]);
            return {
                '$within': {
                    '$box': [bottomLeft, upperRight]
                }
            };
        },
        _getWithinPolygon: function (expr) {
            var operands = expr.operands;
            var points = this._getGeoPoints(operands[1]);
            return {
                '$within': {
                    '$polygon': points
                }
            };
        },
        _getWithinCenterSphere: function (expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var radius = operands[2];
            var metrics = operands[3];
            var radiusConst = radiusConsts[metrics] || radiusConsts.radians;
            var sphereInfo = {
                'center': center
            };
            sphereInfo[radiusConst] = radius;
            return {
                '$within': {
                    '$centerSphere': sphereInfo
                }
            };
        },
        _getGeoPoint: function (point) {
            if (_.isArray(point)) {
                return new GeoPoint(point[0], point[1]);
            }
            return point;
        },
        _getGeoPoints: function (points) {
            var self = this;
            return _.map(points, function (point) {
                return self._getGeoPoint(point);
            });
        },
        _isAnd: function (expr) {
            return expr.operator === OperatorType.and;
        },
        _and: function (expr) {
            var i, l, term, result = {};
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result = this._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function (andObj, newObj) {
            var i, l, key, value, newValue;
            var keys = _.keys(newObj);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                value = andObj[key];
                if (typeof value === 'undefined') {
                    andObj[key] = newObj[key];
                }
                else {
                    newValue = newObj[key];
                    if (typeof value === 'object' && typeof newValue === 'object') {
                        value = _.extend(value, newValue);
                    } else {
                        value = newValue;
                    }
                    andObj[key] = value;
                }
            }
            return andObj;
        },
        _isOr: function (expr) {
            return expr.operator === OperatorType.or;
        },
        _or: function (expr) {
            var i, l, term, result = [];
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result.push(term);
            }
            return {$or: result};
        },
        _isNot: function (expr) {
            return expr.operator === OperatorType.not;
        },
        _not: function (expr) {
            return {$not: this._build(expr.operands[0])};
        },
        _translateoperator: function (operator) {
            switch (operator) {
                case OperatorType.equal:
                    return null;
                case OperatorType.not_equal:
                    return '$ne';
                case OperatorType.gt:
                    return '$gt';
                case OperatorType.lt:
                    return '$lt';
                case OperatorType.gte:
                    return '$gte';
                case OperatorType.lte:
                    return '$lte';
                case OperatorType.isin:
                    return '$in';
                case OperatorType.notin:
                    return '$nin';
                case OperatorType.all:
                    return '$all';
                case OperatorType.size:
                    return '$size';
            }
            throw new EverliveError('Unknown operator type.');
        }
    };

    return QueryBuilder;
}());
},{"../EverliveError":53,"../Expression":55,"../GeoPoint":56,"../common":60,"../constants":61}],72:[function(require,module,exports){
var DataQuery = require('./DataQuery');
var Request = require('../Request');
var _ = require('../common')._;

module.exports = (function () {
    var RequestOptionsBuilder = {};

    RequestOptionsBuilder._buildEndpointUrl = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
            endpoint += '/' + dataQuery.additionalOptions.id;
        }

        return endpoint;
    };

    RequestOptionsBuilder._buildBaseObject = function (dataQuery) {
        var defaultObject = {
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery),
            filter: dataQuery.filter,
            success: dataQuery.onSuccess,
            error: dataQuery.onError,
            data: dataQuery.data,
            headers: dataQuery.headers
        };

        if (dataQuery.parse) {
            defaultObject.parse = dataQuery.parse;
        }

        return defaultObject;
    };

    RequestOptionsBuilder._build = function (dataQuery, additionalOptions) {
        return _.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), additionalOptions);
    };

    RequestOptionsBuilder[DataQuery.operations.read] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.readById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.count] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: dataQuery.collectionName + '/_count'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.create] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.rawUpdate] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;
        var ofilter = null; // request options filter

        if (typeof filter === 'string') {
            endpoint += '/' + filter; // send the filter through query string
        } else if (typeof filter === 'object') {
            ofilter = filter; // send the filter as filter headers
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: endpoint,
            filter: ofilter
        });
    };

    RequestOptionsBuilder[DataQuery.operations.update] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.remove] = function (dataQuery) {
        return _.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), {
            method: 'DELETE'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.removeSingle] = RequestOptionsBuilder[DataQuery.operations.remove];

    RequestOptionsBuilder[DataQuery.operations.setAcl] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;

        if (typeof filter === 'string') { // if filter is string than will update a single item using the filter as an identifier
            endpoint += '/' + filter;
        } else if (typeof filter === 'object') { // else if it is an object than we will use it's id property
            endpoint += '/' + filter[idField];
        }
        endpoint += '/_acl';
        var method, data;
        if (dataQuery.additionalOptions.acl === null) {
            method = 'DELETE';
        } else {
            method = 'PUT';
            data = dataQuery.additionalOptions.acl;
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: method,
            endpoint: endpoint,
            data: data
        });
    };

    RequestOptionsBuilder[DataQuery.operations.setOwner] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;
        if (typeof filter === 'string') { // if filter is string than will update a single item using the filter as an identifier
            endpoint += '/' + filter;
        } else if (typeof filter === 'object') { // else if it is an object than we will use it's id property
            endpoint += '/' + filter[idField];
        }
        endpoint += '/_owner';

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: endpoint
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLogin] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: 'oauth/token',
            authHeaders: false,
            parse: Request.parsers.single
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLogout] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: 'oauth/logout'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userChangePassword] = function (dataQuery) {
        var keepTokens = dataQuery.additionalOptions.keepTokens;
        var endpoint = 'Users/changepassword';
        if (keepTokens) {
            endpoint += '?keepTokens=true';
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: endpoint,
            authHeaders: false,
            parse: Request.parsers.single
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLoginWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            authHeaders: false
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLinkWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/link'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userUnlinkFromProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/unlink'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.filesUpdateContent] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/Content'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.filesGetDownloadUrlById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    return RequestOptionsBuilder;
}());
},{"../Request":58,"../common":60,"./DataQuery":69}],73:[function(require,module,exports){
var Expression = require('../Expression');
var OperatorType = require('../constants').OperatorType;

module.exports = (function () {
    /**
     * @classdesc A fluent API operation for creating a filter for a query by chaining different rules.
     * @class WhereQuery
     * @protected
     * @borrows WhereQuery#eq as WhereQuery#equal
     * @borrows WhereQuery#ne as WhereQuery#notEqual
     * @borrows WhereQuery#gt as WhereQuery#greaterThan
     * @borrows WhereQuery#gte as WhereQuery#greaterThanEqual
     * @borrows WhereQuery#lt as WhereQuery#lessThan
     * @borrows WhereQuery#lte as WhereQuery#lessThanEqual
     */
    function WhereQuery(parentQuery, exprOp, singleOperand) {
        this.parent = parentQuery;
        this.single = singleOperand;
        this.expr = new Expression(exprOp || OperatorType.where);
        this.parent.expr.addOperand(this.expr);
    }

    WhereQuery.prototype = {
        /**
         * Adds an `and` clause to the current condition and returns it for further chaining.
         * @method and
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        and: function () {
            return new WhereQuery(this, OperatorType.and);
        },
        /**
         * Adds an `or` clause to the current condition and returns it for further chaining.
         * @method or
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        or: function () {
            return new WhereQuery(this, OperatorType.or);
        },
        /**
         * Adds a `not` clause to the current condition and returns it for further chaining.
         * @method not
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        not: function () {
            return new WhereQuery(this, OperatorType.not, true);
        },
        _simple: function (operator) {
            var args = [].slice.call(arguments, 1);
            this.expr.addOperand(new Expression(operator, args));
            return this._done();
        },
        /**
         * Adds a condition that a field must be equal to a specific value.
         * @method eq
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the fields must be equal).
         * @returns {WhereQuery}
         */
        eq: function (field, value) {
            return this._simple(OperatorType.equal, field, value);
        },
        /**
         * Adds a condition that a field must *not* be equal to a specific value.
         * @method ne
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the field must not be equal).
         * @returns {WhereQuery}
         */
        ne: function (field, value) {
            return this._simple(OperatorType.not_equal, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than` a certain value. Applicable to Number, String, and Date fields.
         * @method gt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than).
         * @returns {WhereQuery}
         */
        gt: function (field, value) {
            return this._simple(OperatorType.gt, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method gte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than or equal to).
         * @returns {WhereQuery}
         */
        gte: function (field, value) {
            return this._simple(OperatorType.gte, field, value);
        },
        /**
         * Adds a condition that a field must be `less than` a certain value. Applicable to Number, String, and Date fields.
         * @method lt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than).
         * @returns {WhereQuery}
         */
        lt: function (field, value) {
            return this._simple(OperatorType.lt, field, value);
        },
        /**
         * Adds a condition that a field must be `less than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method lte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than or equal to).
         * @returns {WhereQuery}
         */
        lte: function (field, value) {
            return this._simple(OperatorType.lte, field, value);
        },
        /**
         * Adds a condition that a field must be in a set of values.
         * @method isin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of the values that the field should be in.
         * @returns {WhereQuery}
         */
        isin: function (field, value) {
            return this._simple(OperatorType.isin, field, value);
        },
        /**
         * Adds a condition that a field must *not* be in a set of values.
         * @method notin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field should not be in.
         * @returns {WhereQuery}
         */
        notin: function (field, value) {
            return this._simple(OperatorType.notin, field, value);
        },
        /**
         * Adds a condition that a field must include *all* of the specified values. Applicable to Array fields.
         * @method all
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field must include.
         * @returns {WhereQuery}
         */
        all: function (field, value) {
            return this._simple(OperatorType.all, field, value);
        },
        /**
         * Adds a condition that a field must contain an array whose length is larger than a specified value. Applicable to Array fields.
         * @method size
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {number} value The size that the array must be bigger than.
         * @returns {WhereQuery}
         */
        size: function (field, value) {
            return this._simple(OperatorType.size, field, value);
        },
        /**
         * Adds a condition that a field must satisfy a specified regex.
         * @method regex
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} regularExpression Regular expression in PCRE format.
         * @param {string} [options] A string of regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        regex: function (field, value, flags) {
            return this._simple(OperatorType.regex, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *start* with a specified string.
         * @method startsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should start with.
         * @param {string} [options] A string of regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        startsWith: function (field, value, flags) {
            return this._simple(OperatorType.startsWith, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *end* with a specified string.
         * @method endsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should end with.
         * @param {string} [options] A string of  regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        endsWith: function (field, value, flags) {
            return this._simple(OperatorType.endsWith, field, value, flags);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a certain distance from another geopoint. Applicable to GeoPoint fields only.
         * @method nearSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} point Comparison geopoint value.
         * @param {number} distance Distance value.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for distance. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        nearSphere: function (field, point, distance, metrics) {
            return this._simple(OperatorType.nearShpere, field, point, distance, metrics);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate rectangle. Applicable to GeoPoint fields only.
         * @method withinBox
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} pointBottomLeft Value representing the bottom left corner of the box.
         * @param {Everlive.GeoPoint} pointUpperRight Value representing the upper right corner of the box.
         * @example ```js
         var query = new Everlive.Query();
         query.where().withinBox('Location',
         new Everlive.GeoPoint(23.317871, 42.687709),
         new Everlive.GeoPoint(23.331346, 42.707075));
         ```
         * @returns {WhereQuery}
         */
        withinBox: function (field, pointBottomLeft, pointUpperRight) {
            return this._simple(OperatorType.withinBox, field, pointBottomLeft, pointUpperRight);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate polygon. The polygon is specified as an array of geopoints. The last point in the array is implicitly connected to the first point thus closing the shape. Applicable to GeoPoint fields only.
         * @method withinPolygon
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint[]} points Comparison value in the form of an array of geopoints defining the polygon.
         * @example ```js
         var point1 = new Everlive.GeoPoint(23.317871, 42.687709);
         var point2 = new Everlive.GeoPoint(42.698749, 42.698749);
         var point3 = new Everlive.GeoPoint(23.331346, 42.702282);

         var query = new Everlive.Query();
         query.where().withinPolygon("location", [point1, point2, point3]);
         * ```
         * @returns {WhereQuery}
         */
        withinPolygon: function (field, points) {
            return this._simple(OperatorType.withinPolygon, field, points);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a coordinate circle. Applicable to GeoPoint fields only.
         * @method withinCenterSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} center Comparison value specifying the center of the coordinate circle.
         * @param {number} radius Value specifying the radius length.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for radius length. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        withinCenterSphere: function (field, center, radius, metrics) {
            return this._simple(OperatorType.withinShpere, field, center, radius, metrics);
        },
        /**
         * Ends the definition of the current WhereQuery. You need to call this method in order to continue with the definition of the parent `Query`. All other `WhereQuery` methods return the current instance of `WhereQuery` to allow chaining.
         * @method done
         * @memberOf WhereQuery.prototype
         * @returns {Query}
         */
        done: function () {
            if (this.parent instanceof WhereQuery) {
                return this.parent._done();
            } else {
                return this.parent;
            }
        },
        _done: function () {
            if (this.single) {
                return this.parent;
            } else {
                return this;
            }
        }
    };

    WhereQuery.prototype.equal = WhereQuery.prototype.eq;
    WhereQuery.prototype.notEqual = WhereQuery.prototype.ne;
    WhereQuery.prototype.greaterThan = WhereQuery.prototype.gt;
    WhereQuery.prototype.greaterThanEqual = WhereQuery.prototype.gte;
    WhereQuery.prototype.lessThan = WhereQuery.prototype.lt;
    WhereQuery.prototype.lessThanEqual = WhereQuery.prototype.lte;

    return WhereQuery;
}());
},{"../Expression":55,"../constants":61}],74:[function(require,module,exports){
var buildPromise = require('../utils').buildPromise;
var DataQuery = require('../query/DataQuery');
var RequestOptionsBuilder = require('../query/RequestOptionsBuilder');
var rsvp = require('../common').rsvp;
var Request = require('../Request');
var idField = require('../constants').idField;
var Everlive = require('../Everlive');
var EverliveError = require('../EverliveError').EverliveError;
var _ = require('../common')._;

module.exports = (function () {
    function mergeResultData(data, success) {
        return function (res, response) {
            var attrs = res.result;
            // support for kendo observable array
            if (_.isArray(data) || typeof data.length === 'number') {
                _.each(data, function (item, index) {
                    _.extend(item, attrs[index]);
                });
            }
            else {
                _.extend(data, attrs);
            }

            success(res, response);
        };
    }

    function mergeUpdateResultData(data, success) {
        return function (res) {
            var modifiedAt = res.ModifiedAt;
            data.ModifiedAt = modifiedAt;
            success(res);
        };
    }

    /**
     * @class Data
     * @classdesc A class that provides methods for all CRUD operations to a given {{site.bs}} data type. Covers advanced scenarios with custom headers and special server-side functionality.
     * @param {object} setup
     * @param {string} collectionName
     * @protected
     */
    function Data(setup, collectionName, offlineStorage) {
        this.setup = setup;
        this.collectionName = collectionName;
        this.options = null;
        this.offlineStorage = offlineStorage;
    }

    Data.prototype = {
        _isOnline: function () {
            return this.offlineStorage ? this.offlineStorage.isOnline() : true;
        },
        _getOfflineCreateData: function (query, requestResponse) {
            var createData;
            if (_.isArray(query.data)) {
                createData = [];
                for (var i = 0; i < query.data.length; i++) {
                    var objectToCreate = _.extend(query.data[i], requestResponse.result[i]);
                    createData.push(objectToCreate)
                }
            } else {
                createData = _.extend(query.data, requestResponse.result);
            }

            return createData;
        },
        _getOperationParameters: function _getOperationParameters(args) {
            var params = {
                success: undefined, //_.defaults fills in only undefined values
                error: undefined,
                workOffline: !this._isOnline(),
                applyOffline: true
            };

            //the case when we have one or two callbacks in the arguments:
            //[{}, function success{}]; [{}, function success{}, function error{}];
            var lastArguments = _.last(args, 2);
            var firstArg = lastArguments[0];
            var lastArg = lastArguments[1] || firstArg;
            if (_.isFunction(lastArg)) {
                if (_.isFunction(firstArg)) { //we have two callbacks - success and error
                    params.success = firstArg;
                    params.error = lastArg;
                } else { //we have only one callback - success, error should be {noop}
                    params.success = lastArg;
                    params.error = _.noop;
                }
            } else if (_.isObject(lastArg) && args.length > 1) { //we have a configuration object in the format of {params}
                params = _.extend(params, lastArg);
            }

            return params;
        },
        _applyOffline: function (query, requestResponse) {
            var autoSyncEnabled = this.offlineStorage && this.offlineStorage.settings.autoSync;
            if (autoSyncEnabled) {
                switch (query.operation) {
                    case DataQuery.operations.read:
                    case DataQuery.operations.readById:
                        var syncReadQuery = new DataQuery(_.defaults({
                            data: requestResponse.result,
                            isSync: true
                        }, query));
                        return this.offlineStorage.create(syncReadQuery);
                    case DataQuery.operations.create:
                        var createData = this._getOfflineCreateData(query, requestResponse);
                        var createQuery = new DataQuery(_.defaults({
                            data: createData,
                            isSync: true
                        }, query));
                        return this.offlineStorage.create(createQuery);
                    default:
                        query.isSync = true;
                        return this.offlineStorage.processQuery(query);
                }
            }

            return new rsvp.Promise(function (resolve, reject) {
                resolve();
            });
        },
        /**
         * Sets additional non-standard HTTP headers in the current data request. See [List of Non-Standard HTTP Headers]{{% slug rest-api-headers}} for more information.
         * @memberOf Data.prototype
         * @method
         * @param {object} headers Additional headers to be sent with the data request.
         * @returns {Data}
         */
        withHeaders: function (headers) {
            var options = this.options || {};
            options.headers = _.extend(options.headers || {}, headers);
            this.options = options;
            return this;
        },
        /**
         * Sets an expand expression to be used in the data request. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Data.prototype
         * @method
         * @param {object} expandExpression An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
         * @returns {Data}
         */
        expand: function (expandExpression) {
            var expandHeader = {
                'X-Everlive-Expand': JSON.stringify(expandExpression)
            };
            return this.withHeaders(expandHeader);
        },

        /**
         * Processes a query with all of its options. Applies the operation online/offline
         * @param {DataQuery} query The query to process
         */
        processDataQuery: function (query) {
            var self = this;

            if (this.options) {
                query.headers = this.options.headers;
            }

            this.options = null;

            if ((!query.isSync && this.offlineStorage && this.offlineStorage.isSynchronizing()) || query.skipSyncCheck) {
                query.onError.call(this, require('../EverliveError').EverliveErrors.syncInProgress);
            } else if (!query.workOffline) {
                var originalSuccess = query.onSuccess;
                query.onSuccess = function () {
                    var args = arguments;
                    var data = args[0];
                    if (query.applyOffline) {
                        return self._applyOffline(query, data)
                            .then(function () {
                                originalSuccess.apply(this, args);
                            }, function () {
                                query.onError.apply(this, arguments);
                            });
                    } else {
                        return originalSuccess.apply(this, args);
                    }
                };

                var getRequestOptionsFromQuery = RequestOptionsBuilder[query.operation];
                var requestOptions = getRequestOptionsFromQuery(query);
                var request = new Request(this.setup, requestOptions);
                request.send();
            } else {
                if (!query.applyOffline) {
                    return query.onError.call(this, new EverliveError('The applyOffline must be false when working offline.'));
                }

                self.offlineStorage.processQuery(query).then(function () {
                    query.onSuccess.apply(this, arguments);
                }, function () {
                    query.onError.apply(this, arguments);
                });
            }
        },
        // TODO implement options: { requestSettings: { executeServerCode: false } }. power fields queries could be added to that options argument
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        get: function (filter, operationParameters) {
            var self = this;
            operationParameters = this._getOperationParameters(arguments);

            return buildPromise(function (successCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.read,
                    collectionName: self.collectionName,
                    filter: filter,
                    onSuccess: successCb,
                    onError: errorCb
                });
                dataQuery.setOptions(operationParameters);

                return self.processDataQuery(dataQuery);
            }, operationParameters.success, operationParameters.error);
        },
        // TODO handle options
        // TODO think to pass the id as a filter

        /**
         * Gets a data item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets an item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        getById: function (id, operationParameters) {
            var self = this;
            operationParameters = this._getOperationParameters(arguments);

            return buildPromise(function (successCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.readById,
                    collectionName: self.collectionName,
                    parse: Request.parsers.single,
                    additionalOptions: {
                        id: id
                    },
                    onSuccess: successCb,
                    onError: errorCb
                });

                dataQuery.setOptions(operationParameters);

                return self.processDataQuery(dataQuery);
            }, operationParameters.success, operationParameters.error);
        },

        /**
         * Gets the count of the data items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets the count of the items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        count: function (filter, operationParameters) {
            var self = this;
            operationParameters = this._getOperationParameters(arguments);

            return buildPromise(function (sucessCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.count,
                    collectionName: self.collectionName,
                    filter: filter,
                    parse: Request.parsers.single,
                    onSuccess: sucessCb,
                    onError: errorCb
                });
                dataQuery.setOptions(operationParameters);
                return self.processDataQuery(dataQuery);
            }, operationParameters.success, operationParameters.error);
        },

        /**
         * Creates a data item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data Item or items that will be created.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Creates an item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data The item or items that will be created.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        create: function (data, operationParameters) {
            var self = this;
            operationParameters = this._getOperationParameters(arguments);

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.create,
                    collectionName: self.collectionName,
                    data: data,
                    parse: Request.parsers.single,
                    onSuccess: mergeResultData(data, success),
                    onError: error
                });

                dataQuery.setOptions(operationParameters);

                return self.processDataQuery(dataQuery);
            }, operationParameters.success, operationParameters.error);
        },
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updatedObject Updated object that contains the new values.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Updated object that contains the new values.
         * @param {string} id The ID of the item.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        rawUpdate: function (attrs, filter, operationParameters) {
            var self = this;
            operationParameters = this._getOperationParameters(arguments);

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.rawUpdate,
                    collectionName: self.collectionName,
                    filter: filter,
                    data: attrs,
                    onSuccess: success,
                    onError: error
                });
                dataQuery.setOptions(operationParameters);
                return self.processDataQuery(dataQuery);
            }, operationParameters.success, operationParameters.error);
        },
        // TODO: Check if there is a case in which replace = true is passed to this function
        _update: function (attrs, filter, single, replace, operationParameters) {
            var self = this;
            operationParameters = this._getOperationParameters(arguments);

            return buildPromise(function (success, error) {
                var data = {};
                data[replace ? '$replace' : '$set'] = attrs;

                // if the update is for a single item - merge the update result and add the ModifiedAt field to the result
                var onSuccess = single ? mergeUpdateResultData(attrs, success) : success;

                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.update,
                    collectionName: self.collectionName,
                    parse: Request.parsers.update,
                    filter: filter,
                    data: data,
                    additionalOptions: {
                        id: single ? attrs[idField] : undefined
                    },
                    onSuccess: onSuccess,
                    onError: error
                });
                dataQuery.setOptions(operationParameters);
                return self.processDataQuery(dataQuery);
            }, operationParameters.success, operationParameters.error);
        },

        /**
         * Updates a single data item. This operation takes an object that specifies both the data item to be updated and the updated values.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} item The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the provided item.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} model The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        updateSingle: function (model, operationParameters) {
            operationParameters = this._getOperationParameters(arguments);
            return this._update(model, null, true, false, operationParameters);
        },

        /**
         * Updates all items that match a filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} updateObject The update object.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all items that match the filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} model The update object.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        update: function (model, filter, operationParameters) {
            operationParameters = this._getOperationParameters(arguments);
            return this._update(model, filter, false, false, operationParameters);
        },
        _destroy: function (attrs, filter, single, operationParameters) {
            var self = this;
            operationParameters = this._getOperationParameters(arguments);

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: single ? DataQuery.operations.removeSingle : DataQuery.operations.remove,
                    collectionName: self.collectionName,
                    filter: filter,
                    onSuccess: success,
                    onError: error,
                    additionalOptions: {
                        id: single ? attrs[idField] : undefined
                    }
                });
                dataQuery.setOptions(operationParameters);
                return self.processDataQuery(dataQuery);
            }, operationParameters.success, operationParameters.error);
        },

        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} item Object containing the item ID to be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} model Object containing the item ID to be deleted.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        destroySingle: function (model, operationParameters) {
            operationParameters = this._getOperationParameters(arguments);
            return this._destroy(model, null, true, operationParameters);
        },

        /**
         * Deletes all data items that match a filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes all items that match the filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        destroy: function (filter, operationParameters) {
            operationParameters = this._getOperationParameters(arguments);
            return this._destroy(null, filter, false, operationParameters);
        },

        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of an item with a specified ID.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} id The ID of the item.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        setAcl: function (acl, filter, operationParameters) {
            var self = this;
            operationParameters = this._getOperationParameters(arguments);

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.setAcl,
                    collectionName: self.collectionName,
                    parse: Request.parsers.single,
                    filter: filter,
                    additionalOptions: {
                        acl: acl
                    },
                    onSuccess: success,
                    onError: error
                });

                dataQuery.setOptions(operationParameters);
                return self.processDataQuery(dataQuery);
            }, operationParameters.success, operationParameters.error);
        },

        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        setOwner: function (ownerId, filter, operationParameters) {
            var self = this;
            operationParameters = this._getOperationParameters(arguments);

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.setOwner,
                    collectionName: self.collectionName,
                    filter: filter,
                    data: {
                        Owner: ownerId
                    },
                    onSuccess: success,
                    onError: error
                });
                dataQuery.setOptions(operationParameters);
                return self.processDataQuery(dataQuery);
            }, operationParameters.success, operationParameters.error);
        },
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} item An object containing the item that is being saved.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} model An object containing the item that is being saved.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.workOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        save: function (model, operationParameters) {
            var self = this;
            var isNew = this.isNew(model);
            operationParameters = this._getOperationParameters(arguments);

            return buildPromise(function (success, error) {
                function saveSuccess(res) {
                    res.type = isNew ? 'create' : 'update';
                    success(res);
                }

                function saveError(err) {
                    err.type = isNew ? 'create' : 'update';
                    error(err);
                }

                var createParams = _.clone(operationParameters);
                createParams.success = saveSuccess;
                createParams.error = saveError;

                if (isNew) {
                    return self.create(model, createParams);
                } else {
                    return self.updateSingle(model, createParams);
                }
            }, operationParameters.success, operationParameters.error);
        },
        /**
         * Checks if the specified data item is new or not.
         * @memberOf Data.prototype
         * @method
         * @param model Item to check.
         * @returns {boolean}
         */
        isNew: function (model) {
            return typeof model[idField] === 'undefined';
        }
    };

    return Data;
}());

},{"../Everlive":52,"../EverliveError":53,"../Request":58,"../common":60,"../constants":61,"../query/DataQuery":69,"../query/RequestOptionsBuilder":72,"../utils":77}],75:[function(require,module,exports){
/**
 * @class Files
 * @protected
 * @extends Data
 */

var buildPromise = require('../utils').buildPromise;
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');

module.exports.addFilesFunctions = function addFilesFunctions(ns) {
    /**
     * Get a URL that can be used as an endpoint for uploading a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUploadUrl
     * @returns {string}
     */
    ns.getUploadUrl = function () {
        return Everlive.buildUrl(this.setup) + this.collectionName;
    };

    /**
     * Get the download URL for a file.
     * @memberof Files.prototype
     * @method getDownloadUrl
     * @deprecated
     * @param {string} fileId The ID of the file.
     * @returns {string} url The download URL.
     */
    ns.getDownloadUrl = function (fileId) {
        return Everlive.buildUrl(this.setup) + this.collectionName + '/' + fileId + '/Download';
    };

    ns._getUpdateUrl = function (fileId) {
        return this.collectionName + '/' + fileId + '/Content';
    };

    /**
     * Get a URL that can be used as an endpoint for updating a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUpdateUrl
     * @param {string} fileId The ID of the file.
     * @returns {string} url The update URL.
     */
    ns.getUpdateUrl = function (fileId) {
        return Everlive.buildUrl(this.setup) + this._getUpdateUrl(fileId);
    };

    /**
     * Updates a file's content
     * @memberof Files.prototype
     * @method updateContent
     * @param {string} fileId File ID.
     * @param {string} file File contents in base64 encoding.
     * @param operationParameters
     * @returns {Promise} The promise for the request
     */
    ns.updateContent = function (fileId, file, operationParameters) {
        var self = this;
        operationParameters = this._getOperationParameters(arguments);
        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.filesUpdateContent,
                // the passed file content is base64 encoded
                data: file,
                collectionName: self.collectionName,
                additionalOptions: {
                    id: fileId
                },
                onSuccess: success,
                onError: error
            });

            dataQuery.setOptions(operationParameters);
            return self.processDataQuery(dataQuery);
        }, operationParameters.success, operationParameters.error);
    };

    /**
     * Gets the download URL for a file by ID.
     * @memberof Files.prototype
     * @method getDownloadUrlById
     * @param {string} fileId File ID.
     * @param operationParameters
     * @returns {Promise} The promise for the request
     */
    ns.getDownloadUrlById = function (fileId, operationParameters) {
        var self = this;
        operationParameters = this._getOperationParameters(arguments);
        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.filesGetDownloadUrlById,
                collectionName: self.collectionName,
                additionalOptions: {
                    id: fileId
                },
                parse: Request.parsers.single,
                onSuccess: function (data) {
                    success(data.result.Uri);
                },
                onError: error
            });

            dataQuery.setOptions(operationParameters);
            return self.processDataQuery(dataQuery);
        }, operationParameters.success, operationParameters.error);
    };
};
},{"../Request":58,"../query/DataQuery":69,"../utils":77}],76:[function(require,module,exports){
/**
 * @class Users
 * @extends Data
 * @protected
 */

var utils = require('../utils');
var buildPromise = utils.buildPromise;
var guardUnset = utils.guardUnset;
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var getAuthInfo = utils.getAuthInfo;
var _ = require('../common')._;

module.exports.addUsersFunctions = function addUsersFunctions(ns) {
    ns._loginSuccess = function (data) {
        var result = data.result;
        this.setAuthorization(result.access_token, result.token_type);
    };
    ns._logoutSuccess = function () {
        this.clearAuthorization();
    };

    /**
     * Registers a new user with username and password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param {object} userInfo Additional information for the user (ex. DisplayName, Email, etc.)
     * @returns {Promise} The promise for the request.
     */
    /**
     * Registers a new user using a username and a password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param attrs
     * @param operationParameters
     */
    ns.register = function (username, password, attrs, operationParameters) {
        guardUnset(username, 'username');
        guardUnset(password, 'password');
        operationParameters = this._getOperationParameters(arguments);
        var user = {
            Username: username,
            Password: password
        };
        _.extend(user, attrs);
        return this.create(user, operationParameters);
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param operationParameters
     */
    ns.login = function (username, password, operationParameters) {
        var self = this;
        operationParameters = this._getOperationParameters(arguments);
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._loginSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userLogin,
                collectionName: self.collectionName,
                data: {
                    username: username,
                    password: password,
                    grant_type: 'password'
                },
                onSuccess: successFunc,
                onError: error
            });

            dataQuery.setOptions(operationParameters);

            return self.processDataQuery(dataQuery);
        }, operationParameters.success, operationParameters.error);
    };
    // TODO: [offline] this needs to be supported

    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @returns {Promise} The promise for the request.
     */
    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.currentUser = function (success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            getAuthInfo(self.setup, _.bind(self.getById, self, 'me'))
                .then(function (res) {
                    if (typeof res.user !== 'undefined') {
                        success({result: res.user});
                    }
                    else {
                        success({result: null});
                    }
                }, function (err) {
                    error(err);
                });
        }, success, error);
    };

    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.changePassword = function (username, password, newPassword, keepTokens, operationParameters) {
        var self = this;
        operationParameters = this._getOperationParameters(arguments);
        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userChangePassword,
                collectionName: self.collectionName,
                data: {
                    Username: username,
                    Password: password,
                    NewPassword: newPassword
                },
                additionalOptions: {
                    keepTokens: keepTokens
                },
                onSuccess: success,
                onError: error
            });
            dataQuery.setOptions(operationParameters);
            return self.processDataQuery(dataQuery);
        }, operationParameters.success, operationParameters.error);
    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @param operationParameters
     */
    ns.logout = function (operationParameters) {
        var self = this;
        operationParameters = this._getOperationParameters(arguments);
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._logoutSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var errorFunc = function (err) {
                if (err.code === 301) { //invalid token
                    self.clearAuthorization();
                }

                error.apply(null, arguments);
            };

            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userLogout,
                collectionName: self.collectionName,
                onSuccess: successFunc,
                onError: errorFunc
            });
            dataQuery.setOptions(operationParameters);

            return self.processDataQuery(dataQuery);
        }, operationParameters.success, operationParameters.error);
    };

    ns._loginWithProvider = function (identity, operationParameters) {
        var user = {
            Identity: identity
        };

        operationParameters = this._getOperationParameters(arguments);
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._loginSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userLoginWithProvider,
                collectionName: self.collectionName,
                data: user,
                authHeaders: false,
                parse: Request.parsers.single,
                onSuccess: successFunc,
                onError: error
            });
            dataQuery.setOptions(operationParameters);
            self.processDataQuery(dataQuery);
        }, operationParameters.success, operationParameters.error);
    };
    ns._linkWithProvider = function (identity, userId, operationParameters) {
        var self = this;
        operationParameters = this._getOperationParameters(arguments);
        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                additionalOptions: {
                    id: userId
                },
                operation: DataQuery.operations.userLinkWithProvider,
                collectionName: self.collectionName,
                data: identity,
                parse: Request.parsers.single,
                onSuccess: success,
                onError: error
            });

            dataQuery.setOptions(operationParameters);
            return self.processDataQuery(dataQuery);
        }, operationParameters.success, operationParameters.error);
    };
    ns._unlinkFromProvider = function (providerName, userId, operationParameters) {
        var self = this;
        operationParameters = this._getOperationParameters(arguments);

        var identity = {
            Provider: providerName
        };
        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                additionalOptions: {
                    userId: userId
                },
                operation: DataQuery.operations.userUnlinkFromProvider,
                collectionName: self.collectionName,
                data: identity,
                parse: Request.parsers.single,
                onSuccess: success,
                onError: error
            });

            dataQuery.setOptions(operationParameters);
            return self.processDataQuery(dataQuery);
        }, operationParameters.success, operationParameters.error);
    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @param operationParameters
     */
    ns.loginWithFacebook = function (accessToken, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return ns._loginWithProvider(identity, operationParameters);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a Backend Services user with a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.         * @param {Function} [success] a success callback.
     * @param operationParameters
     */
    ns.linkWithFacebook = function (userId, accessToken, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, operationParameters);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param operationParameters
     */
    ns.unlinkFromFacebook = function (userId, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        return ns._unlinkFromProvider('Facebook', userId, operationParameters);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @param operationParameters
     */
    ns.loginWithADFS = function (accessToken, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return ns._loginWithProvider(identity, operationParameters);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @param operationParameters
     */
    ns.linkWithADFS = function (userId, accessToken, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, operationParameters);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param operationParameters
     */
    ns.unlinkFromADFS = function (userId, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        return ns._unlinkFromProvider('ADFS', userId, operationParameters);
    };

    /**
     * Log in a user using a LiveID access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a LiveID access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @param operationParameters
     */
    ns.loginWithLiveID = function (accessToken, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return ns._loginWithProvider(identity, operationParameters);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a LiveId access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The LiveID access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a LiveId access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The LiveID access token that will be linked to the {{site.bs}} user account.
     * @param operationParameters
     */
    ns.linkWithLiveID = function (userId, accessToken, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, operationParameters);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the LiveID access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the LiveID access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param operationParameters
     */
    ns.unlinkFromLiveID = function (userId, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        return ns._unlinkFromProvider('LiveID', userId, operationParameters);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @param operationParameters
     */
    ns.loginWithGoogle = function (accessToken, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        var identity = {
            Provider: 'Google',
            Token: accessToken
        };

        return ns._loginWithProvider(identity, operationParameters);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @param operationParameters
     */
    ns.linkWithGoogle = function (userId, accessToken, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        var identity = {
            Provider: 'Google',
            Token: accessToken
        };

        return ns._linkWithProvider(identity, userId, operationParameters);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param operationParameters
     */
    ns.unlinkFromGoogle = function (userId, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        return ns._unlinkFromProvider('Google', userId, operationParameters);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param operationParameters
     */
    ns.loginWithTwitter = function (token, tokenSecret, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return ns._loginWithProvider(identity, operationParameters);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.         * Links a Backend Services user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @param operationParameters
     */
    ns.linkWithTwitter = function (userId, token, tokenSecret, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return ns._linkWithProvider(identity, userId, operationParameters);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param operationParameters
     */
    ns.unlinkFromTwitter = function (userId, operationParameters) {
        operationParameters = this._getOperationParameters(arguments);

        return ns._unlinkFromProvider('Twitter', userId, operationParameters);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Users.prototype
     * @method setAuthorization
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     */
    ns.setAuthorization = function setAuthorization(token, tokenType) {
        this.setup.token = token;
        this.setup.tokenType = tokenType;
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the current authorization token is not invalidated.
     * @method clearAuthorization
     * @memberOf Users.prototype
     */
    ns.clearAuthorization = function clearAuthorization() {
        this.setAuthorization(null, null);
    };
};
},{"../Request":58,"../common":60,"../query/DataQuery":69,"../utils":77}],77:[function(require,module,exports){
var EverliveError = require('./EverliveError').EverliveError;
var AuthStatus = require('./constants').AuthStatus;
var _ = require('./common')._;
var utils = {};

utils.guardUnset = function guardUnset(value, name, message) {
    if (!message) {
        message = 'The ' + name + ' is required';
    }
    if (typeof value === 'undefined' || value === null) {
        throw new EverliveError(message);
    }
};

utils.parseUtilities = {
    getReviver: function (parseOnlyCompleteDateTimeString) {
        var dateParser;
        if (parseOnlyCompleteDateTimeString) {
            dateParser = utils.parseUtilities.parseIsoDateString;
        } else {
            dateParser = utils.parseUtilities.parseOnlyCompleteDateTimeString;
        }

        return function (key, value) {
            if (typeof value === 'string') {
                var date = dateParser(value);
                if (date) {
                    value = date;
                }
            }

            return value;
        }
    },

    parseIsoDateString: function (string) {
        var match;
        if (match = string.match(/^(\d{4})(-(\d{2})(-(\d{2})(T(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2}))))?))$/)) {
            // DateTime
            var secondParts = match[12];
            if (secondParts) {
                if (secondParts.length > 3) {
                    secondParts = Math.round(Number(secondParts.substr(0, 3) + '.' + secondParts.substr(3)));
                }
                else if (secondParts.length < 3) {
                    // if the secondParts are one or two characters then two or one zeros should be appended
                    // in order to have the correct number for milliseconds ('.67' means 670ms not 67ms)
                    secondParts += secondParts.length === 2 ? '0' : '00';
                }
            }
            var date = new Date(
                Date.UTC(
                    Number(match[1]), // year
                    (Number(match[3]) - 1) || 0, // month
                    Number(match[5]) || 0, // day
                    Number(match[7]) || 0, // hour
                    Number(match[8]) || 0, // minute
                    Number(match[10]) || 0, // second
                    Number(secondParts) || 0
                )
            );

            if (match[13] && match[13] !== "Z") {
                var h = Number(match[16]) || 0,
                    m = Number(match[17]) || 0;

                h *= 3600000;
                m *= 60000;

                var offset = h + m;
                if (match[15] === "+")
                    offset = -offset;

                date = new Date(date.valueOf() + offset);
            }

            return date;
        } else {
            return null;
        }
    },

    parseOnlyCompleteDateTimeString: function (string) {
        if (/^\d{4}-\d{2}-\d{2}$/.test(string)) {
            // Date
            return null;
        }

        if (/^(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2})))?$/.test(string)) {
            // Time
            return null;
        }

        return utils.parseUtilities.parseIsoDateString(string);
    },

    traverse: function (obj, func) {
        var key, value, newValue;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                value = obj[key];
                newValue = func(key, value);
                obj[key] = newValue;
                if (value === newValue && typeof value === 'object') {
                    utils.parseUtilities.traverse(value, func);
                }
            }
        }
    },

    traverseAndRevive: function (data, reviver) {
        if (!reviver) {
            reviver = utils.parseUtilities.getReviver();
        }

        utils.parseUtilities.traverse(data, reviver);
    },

    parseError: function (reviver, error) {
        if (typeof error === 'string' && error.length > 0) {
            try {
                error = JSON.parse(error);
                return {message: error.message, code: error.errorCode};
            } catch (e) {
                return error;
            }
        } else {
            return error;
        }
    },

    _parseInternal: function (reviver, data) {
        if (typeof data === 'string' && data.length > 0) {
            data = JSON.parse(data, reviver);
        } else if (typeof data === 'object') {
            utils.parseUtilities.traverseAndRevive(data, reviver);
        }

        return data;
    },

    _transformResult: function (data, additionalProperties) {
        if (data) {
            var result = {result: data.Result};
            _.extend(result, additionalProperties);
            return result;
        } else {
            return data;
        }
    },

    parseResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, {count: data.Count});
    },

    parseSingleResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data);
    },

    parseUpdateResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, {ModifiedAt: data.ModifiedAt});
    }
};

utils.buildPromise = function buildPromise(operation, success, error) {
    var callbacks = Everlive.getCallbacks(success, error);
    operation(callbacks.success, callbacks.error);
    return callbacks.promise;
};

utils.buildAuthHeader = function buildAuthHeader(setup, options) {
    var authHeaderValue = null;
    if (options && options.authHeaders === false) {
        return authHeaderValue;
    }
    if (setup.token) {
        authHeaderValue = (setup.tokenType || 'bearer') + ' ' + setup.token;
    }
    else if (setup.masterKey) {
        authHeaderValue = 'masterkey ' + setup.masterKey;
    }
    if (authHeaderValue) {
        return {Authorization: authHeaderValue};
    } else {
        return null;
    }
};

utils.getAuthInfo = function getAuthInfo(setup, getUser, success, error) {
    if (setup.masterKey) {
        return utils.buildPromise(function (success, error) {
            success({status: AuthStatus.masterKey});
        }, success, error);
    }
    if (!setup.token) {
        return utils.buildPromise(function (success, error) {
            success({status: AuthStatus.unauthenticated});
        }, success, error);
    }

    var errorcb = null;
    if (success) {
        errorcb = function (err) {
            if (err && err.code === 601) { // invalid request, i.e. the access token is invalid or missing
                success({status: AuthStatus.invalidAuthentication});
            }
            else {
                error(err);
            }
        };
    }
    var promise = getUser(success, errorcb);
    if (promise) {
        promise = promise.then(function (res) {
            return {status: AuthStatus.authenticated, user: res.result};
        }, function (err) {
            if (err && err.code === 601) { // invalid request, i.e. the access token is invalid or missing
                return {status: AuthStatus.invalidAuthentication};
            }
            else {
                throw err;
            }
        });
    }
    return promise;
};

utils.DeviceRegistrationResult = function DeviceRegistrationResult(token) {
    this.token = token;
};

utils.cloneDate = function (date) {
    return new Date(date);
};

utils.buildUrl = function (setup) {
    var url = '';
    if (typeof setup.scheme === 'string') {
        url += setup.scheme + ':';
    }
    url += setup.url;
    if (setup.apiKey) {
        url += setup.apiKey + '/';
    }
    return url;
};

utils.getDbOperators = function (expression, shallow) {
    var dbOperators = [];

    if (typeof expression === 'string') {
        return dbOperators;
    }

    var modifierKeys = Object.keys(expression);
    _.each(modifierKeys, function (key) {
        if (key.indexOf('$') === 0) {
            dbOperators.push(key);
        } else if (typeof expression[key] === 'object' && !shallow) {
            dbOperators = dbOperators.concat(utils.getDbOperators(expression[key]));
        }
    });

    return dbOperators;
};


var unsupportedDbOperators = [
    '$geoWithin',
    '$geoIntersects',
    '$near',
    '$within',
    '$nearSphere'
];

utils.getUnsupportedOperators = function (filter) {
    var dbOperators = utils.getDbOperators(filter);
    return _.intersection(dbOperators, unsupportedDbOperators);
};

module.exports = utils;

},{"./EverliveError":53,"./common":60,"./constants":61}]},{},[63])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2pzdGltZXpvbmVkZXRlY3QvanN0ei5qcyIsIm5vZGVfbW9kdWxlcy9taW5nby9taW5nby5qcyIsIm5vZGVfbW9kdWxlcy9tb25nby1xdWVyeS9maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbW9kcy5qcyIsIm5vZGVfbW9kdWxlcy9tb25nby1xdWVyeS9ub2RlX21vZHVsZXMvY29tcG9uZW50LXR5cGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kZWJ1Zy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2RvdC1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2RvdC1jb21wb25lbnQvbm9kZV9tb2R1bGVzL3R5cGUtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9tb25nby1lcWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL29iamVjdC1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvb3BzLmpzIiwibm9kZV9tb2R1bGVzL3JlcXdlc3QvcmVxd2VzdC5qcyIsIm5vZGVfbW9kdWxlcy9yc3ZwL2Rpc3QvcnN2cC5qcyIsIm5vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9ybmctYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL3V1aWQuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvQ29uc3RhbnRzLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL0V4ZWN1dGlvblRyZWUuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvUHJvY2Vzc29yLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL1JlbGF0aW9uTm9kZS5qcyIsInNjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3Nvci9SZWxhdGlvblRyZWVCdWlsZGVyLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL25vZGVfbW9kdWxlcy9hc3luYy9saWIvYXN5bmMuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3Ivbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsInNyYy9DdXJyZW50RGV2aWNlLmpzIiwic3JjL0V2ZXJsaXZlLmpzIiwic3JjL0V2ZXJsaXZlRXJyb3IuanMiLCJzcmMvRXhwYW5kUHJvY2Vzc29yLmpzIiwic3JjL0V4cHJlc3Npb24uanMiLCJzcmMvR2VvUG9pbnQuanMiLCJzcmMvUHVzaC5qcyIsInNyYy9SZXF1ZXN0LmpzIiwic3JjL1NldHVwLmpzIiwic3JjL2NvbW1vbi5qcyIsInNyYy9jb25zdGFudHMuanMiLCJzcmMvZXZlcmxpdmUucGxhdGZvcm0uanMiLCJzcmMvaW5kZXguanMiLCJzcmMva2VuZG8va2VuZG8uZXZlcmxpdmUuanMiLCJzcmMvb2ZmbGluZS9PZmZsaW5lU3RvcmFnZU1vZHVsZS5qcyIsInNyYy9vZmZsaW5lL29mZmxpbmUuanMiLCJzcmMvb2ZmbGluZS9vZmZsaW5lUGVyc2lzdGVycy5qcyIsInNyYy9vZmZsaW5lL29mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuanMiLCJzcmMvcXVlcnkvRGF0YVF1ZXJ5LmpzIiwic3JjL3F1ZXJ5L1F1ZXJ5LmpzIiwic3JjL3F1ZXJ5L1F1ZXJ5QnVpbGRlci5qcyIsInNyYy9xdWVyeS9SZXF1ZXN0T3B0aW9uc0J1aWxkZXIuanMiLCJzcmMvcXVlcnkvV2hlcmVRdWVyeS5qcyIsInNyYy90eXBlcy9EYXRhLmpzIiwic3JjL3R5cGVzL0ZpbGVzLmpzIiwic3JjL3R5cGVzL1VzZXJzLmpzIiwic3JjL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ256Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2N0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUdBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdm1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDelpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNubUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2dkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIixudWxsLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG52YXIgcm9vdFBhcmVudCA9IHt9XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBCdWZmZXIpKSByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG4gIHZhciBsZW5ndGhcblxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBsZW5ndGggPSArc3ViamVjdFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkge1xuICAgIC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSkgc3ViamVjdCA9IHN1YmplY3QuZGF0YVxuICAgIGxlbmd0aCA9ICtzdWJqZWN0Lmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmIChsZW5ndGggPiBrTWF4TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHgnICtcbiAgICAgIGtNYXhMZW5ndGgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkgbGVuZ3RoID0gMFxuICBlbHNlIGxlbmd0aCA+Pj49IDAgLy8gY29lcmNlIHRvIHVpbnQzMlxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBzZWxmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBzZWxmLmxlbmd0aCA9IGxlbmd0aFxuICAgIHNlbGYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBzZWxmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VsZi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCA+IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSkgc2VsZi5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW4gJiYgYVtpXSA9PT0gYltpXTsgaSsrKSB7fVxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCA+Pj4gMVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG5cbiAgaWYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICBpZiAobmV3QnVmLmxlbmd0aCkgbmV3QnVmLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXNcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgPj4+IDAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpID4+PiAwICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSW50KFxuICAgICAgdGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCxcbiAgICAgIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSkgLSAxLFxuICAgICAgLU1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcbiAgICApXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJbnQoXG4gICAgICB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLFxuICAgICAgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKSAtIDEsXG4gICAgICAtTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuICAgIClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldF9zdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XFwtXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG4gIHZhciBpID0gMFxuXG4gIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICBjb2RlUG9pbnQgPSBsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwIHwgMHgxMDAwMFxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG5cbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDIwMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnID0gcmVxdWlyZSgndXRpbCcpO1xuaWYgKGRlYnVnICYmIGRlYnVnLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWcuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGNodW5rKSAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udClcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQpXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAoaXNOYU4obikgfHwgdXRpbC5pc051bGwobikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICghdXRpbC5pc051bWJlcihuKSB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH1cblxuICBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmICh1dGlsLmlzTnVsbChyZXQpKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmICghdXRpbC5pc051bGwocmV0KSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJlxuICAgICAgICAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsXG4gICAgICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgLy8gSWYgbGlzdGVuaW5nIHRvIGRhdGEsIGFuZCBpdCBoYXMgbm90IGV4cGxpY2l0bHkgYmVlbiBwYXVzZWQsXG4gIC8vIHRoZW4gY2FsbCByZXN1bWUgdG8gc3RhcnQgdGhlIGZsb3cgb2YgZGF0YSBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiBmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgICAgICAgICBzZWxmLnJlYWQoMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIH1cbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICByZXN1bWVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgIGlmICghY2h1bmsgfHwgIXN0YXRlLm9iamVjdE1vZGUgJiYgIWNodW5rLmxlbmd0aClcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oc3RyZWFtW2ldKSAmJiB1dGlsLmlzVW5kZWZpbmVkKHRoaXNbaV0pKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbihlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChkYXRhKSlcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBpZiAoY2IpXG4gICAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24odGhpcy5fZmx1c2gpKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbCh0cy53cml0ZWNodW5rKSAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oY2IpKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB1dGlsLmlzU3RyaW5nKGNodW5rKSkge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZClcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2Uge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVyKTtcbiAgfVxuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoID4gMSkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgY2JzID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspXG4gICAgICBjYnMucHVzaChzdGF0ZS5idWZmZXJbY10uY2FsbGJhY2spO1xuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gICAgc3RhdGUuYnVmZmVyID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBjKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG5cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlXG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYXJnKTtcbn1cbmV4cG9ydHMuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIilcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLyoqXG4gKiBUaGlzIHNjcmlwdCBnaXZlcyB5b3UgdGhlIHpvbmUgaW5mbyBrZXkgcmVwcmVzZW50aW5nIHlvdXIgZGV2aWNlJ3MgdGltZSB6b25lIHNldHRpbmcuXG4gKlxuICogQG5hbWUganNUaW1lem9uZURldGVjdFxuICogQHZlcnNpb24gMS4wLjVcbiAqIEBhdXRob3IgSm9uIE55bGFuZGVyXG4gKiBAbGljZW5zZSBNSVQgTGljZW5zZSAtIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogRm9yIHVzYWdlIGFuZCBleGFtcGxlcywgdmlzaXQ6XG4gKiBodHRwOi8vcGVsbGVwaW0uYml0YnVja2V0Lm9yZy9qc3R6L1xuICpcbiAqIENvcHlyaWdodCAoYykgSm9uIE55bGFuZGVyXG4gKi9cblxuLypqc2xpbnQgdW5kZWY6IHRydWUgKi9cbi8qZ2xvYmFsIGNvbnNvbGUsIGV4cG9ydHMqL1xuXG4oZnVuY3Rpb24ocm9vdCkge1xuICAvKipcbiAgICogTmFtZXNwYWNlIHRvIGhvbGQgYWxsIHRoZSBjb2RlIGZvciB0aW1lem9uZSBkZXRlY3Rpb24uXG4gICAqL1xuICB2YXIganN0eiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG4gICAgICB2YXIgSEVNSVNQSEVSRV9TT1VUSCA9ICdzJyxcbiAgICAgICAgICBcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBHZXRzIHRoZSBvZmZzZXQgaW4gbWludXRlcyBmcm9tIFVUQyBmb3IgYSBjZXJ0YWluIGRhdGUuXG4gICAgICAgICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBnZXRfZGF0ZV9vZmZzZXQgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIChvZmZzZXQgIT09IG51bGwgPyBvZmZzZXQgOiAwKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0X2RhdGUgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgsIGRhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICBpZiAoeWVhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkLnNldE1vbnRoKG1vbnRoKTtcbiAgICAgICAgICAgICAgZC5zZXREYXRlKGRhdGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0X2phbnVhcnlfb2Zmc2V0ID0gZnVuY3Rpb24gKHllYXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldF9kYXRlX29mZnNldChnZXRfZGF0ZSh5ZWFyLCAwICwyKSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldF9qdW5lX29mZnNldCA9IGZ1bmN0aW9uICh5ZWFyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRfZGF0ZV9vZmZzZXQoZ2V0X2RhdGUoeWVhciwgNSwgMikpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBQcml2YXRlIG1ldGhvZC5cbiAgICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGRhdGUgaXMgaW4gZGF5bGlnaHQgc2F2aW5nIHRpbWUuXG4gICAgICAgICAgICogSWYgdGhlIGRhdGUgc3VwcGxpZWQgaXMgYWZ0ZXIgYXVndXN0LCB3ZSBhc3N1bWUgdGhhdCB3ZSdyZSBjaGVja2luZ1xuICAgICAgICAgICAqIGZvciBzb3V0aGVybiBoZW1pc3BoZXJlIERTVC5cbiAgICAgICAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBkYXRlX2lzX2RzdCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAgIHZhciBpc19zb3V0aGVybiA9IGRhdGUuZ2V0TW9udGgoKSA+IDcsXG4gICAgICAgICAgICAgICAgICBiYXNlX29mZnNldCA9IGlzX3NvdXRoZXJuID8gZ2V0X2p1bmVfb2Zmc2V0KGRhdGUuZ2V0RnVsbFllYXIoKSkgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRfamFudWFyeV9vZmZzZXQoZGF0ZS5nZXRGdWxsWWVhcigpKSxcbiAgICAgICAgICAgICAgICAgIGRhdGVfb2Zmc2V0ID0gZ2V0X2RhdGVfb2Zmc2V0KGRhdGUpLFxuICAgICAgICAgICAgICAgICAgaXNfd2VzdCA9IGJhc2Vfb2Zmc2V0IDwgMCxcbiAgICAgICAgICAgICAgICAgIGRzdF9vZmZzZXQgPSBiYXNlX29mZnNldCAtIGRhdGVfb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmICghaXNfd2VzdCAmJiAhaXNfc291dGhlcm4pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkc3Rfb2Zmc2V0IDwgMDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBkc3Rfb2Zmc2V0ICE9PSAwO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgc29tZSBiYXNpYyBjYWxjdWxhdGlvbnMgdG8gY3JlYXRlIGluZm9ybWF0aW9uIGFib3V0XG4gICAgICAgICAgICogdGhlIHVzZXIncyB0aW1lem9uZS4gSXQgdXNlcyBSRUZFUkVOQ0VfWUVBUiBhcyBhIHNvbGlkIHllYXIgZm9yIHdoaWNoXG4gICAgICAgICAgICogdGhlIHNjcmlwdCBoYXMgYmVlbiB0ZXN0ZWQgcmF0aGVyIHRoYW4gZGVwZW5kIG9uIHRoZSB5ZWFyIHNldCBieSB0aGVcbiAgICAgICAgICAgKiBjbGllbnQgZGV2aWNlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogUmV0dXJucyBhIGtleSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRvIGxvb2t1cHMgaW4ganN0ei5vbHNvbi50aW1lem9uZXMuXG4gICAgICAgICAgICogZWc6IFwiNzIwLDEsMlwiLiBcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBsb29rdXBfa2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgamFudWFyeV9vZmZzZXQgPSBnZXRfamFudWFyeV9vZmZzZXQoKSxcbiAgICAgICAgICAgICAgICAgIGp1bmVfb2Zmc2V0ID0gZ2V0X2p1bmVfb2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgICBkaWZmID0gamFudWFyeV9vZmZzZXQgLSBqdW5lX29mZnNldDtcblxuICAgICAgICAgICAgICBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBqYW51YXJ5X29mZnNldCArIFwiLDFcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGp1bmVfb2Zmc2V0ICsgXCIsMSxcIiArIEhFTUlTUEhFUkVfU09VVEg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gamFudWFyeV9vZmZzZXQgKyBcIiwwXCI7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZXMgZ2V0X3RpbWV6b25lX2luZm8oKSB0byBmb3JtdWxhdGUgYSBrZXkgdG8gdXNlIGluIHRoZSBvbHNvbi50aW1lem9uZXMgZGljdGlvbmFyeS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFJldHVybnMgYSBwcmltaXRpdmUgb2JqZWN0IG9uIHRoZSBmb3JtYXQ6XG4gICAgICAgICAgICogeyd0aW1lem9uZSc6IFRpbWVab25lLCAna2V5JyA6ICd0aGUga2V5IHVzZWQgdG8gZmluZCB0aGUgVGltZVpvbmUgb2JqZWN0J31cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZXR1cm5zIE9iamVjdFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGRldGVybWluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGxvb2t1cF9rZXkoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBqc3R6LlRpbWVab25lKGpzdHoub2xzb24udGltZXpvbmVzW2tleV0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGlzIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBvbiB3aGVuIGRheWxpZ2h0IHNhdmluZ3Mgc3RhcnRzIGZvclxuICAgICAgICAgICAqIGRpZmZlcmVudCB0aW1lem9uZXMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGUgbGlzdCBpcyBzaG9ydCBmb3IgYSByZWFzb24uIE9mdGVuIHdlIGRvIG5vdCBoYXZlIHRvIGJlIHZlcnkgc3BlY2lmaWNcbiAgICAgICAgICAgKiB0byBzaW5nbGUgb3V0IHRoZSBjb3JyZWN0IHRpbWV6b25lLiBCdXQgd2hlbiB3ZSBkbywgdGhpcyBsaXN0IGNvbWVzIGluXG4gICAgICAgICAgICogaGFuZHkuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBFYWNoIHZhbHVlIGlzIGEgZGF0ZSBkZW5vdGluZyB3aGVuIGRheWxpZ2h0IHNhdmluZ3Mgc3RhcnRzIGZvciB0aGF0IHRpbWV6b25lLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGRzdF9zdGFydF9mb3IgPSBmdW5jdGlvbiAodHpfbmFtZSkge1xuXG4gICAgICAgICAgICB2YXIgcnVfcHJlX2RzdF9jaGFuZ2UgPSBuZXcgRGF0ZSgyMDEwLCA2LCAxNSwgMSwgMCwgMCwgMCksIC8vIEluIDIwMTAgUnVzc2lhIGhhZCBEU1QsIHRoaXMgYWxsb3dzIHVzIHRvIGRldGVjdCBSdXNzaWEgOilcbiAgICAgICAgICAgICAgICBkc3Rfc3RhcnRzID0ge1xuICAgICAgICAgICAgICAgICAgICAnQW1lcmljYS9EZW52ZXInOiBuZXcgRGF0ZSgyMDExLCAyLCAxMywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL01hemF0bGFuJzogbmV3IERhdGUoMjAxMSwgMywgMywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0NoaWNhZ28nOiBuZXcgRGF0ZSgyMDExLCAyLCAxMywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL01leGljb19DaXR5JzogbmV3IERhdGUoMjAxMSwgMywgMywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0FzdW5jaW9uJzogbmV3IERhdGUoMjAxMiwgOSwgNywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL1NhbnRpYWdvJzogbmV3IERhdGUoMjAxMiwgOSwgMywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0NhbXBvX0dyYW5kZSc6IG5ldyBEYXRlKDIwMTIsIDksIDIxLCA1LCAwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0FtZXJpY2EvTW9udGV2aWRlbyc6IG5ldyBEYXRlKDIwMTEsIDksIDIsIDMsIDAsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQW1lcmljYS9TYW9fUGF1bG8nOiBuZXcgRGF0ZSgyMDExLCA5LCAxNiwgNSwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0xvc19BbmdlbGVzJzogbmV3IERhdGUoMjAxMSwgMiwgMTMsIDgsIDAsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQW1lcmljYS9TYW50YV9Jc2FiZWwnOiBuZXcgRGF0ZSgyMDExLCAzLCA1LCA4LCAwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0FtZXJpY2EvSGF2YW5hJzogbmV3IERhdGUoMjAxMiwgMiwgMTAsIDIsIDAsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQW1lcmljYS9OZXdfWW9yayc6IG5ldyBEYXRlKDIwMTIsIDIsIDEwLCA3LCAwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0V1cm9wZS9IZWxzaW5raSc6IG5ldyBEYXRlKDIwMTMsIDIsIDMxLCA1LCAwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ1BhY2lmaWMvQXVja2xhbmQnOiBuZXcgRGF0ZSgyMDExLCA4LCAyNiwgNywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0hhbGlmYXgnOiBuZXcgRGF0ZSgyMDExLCAyLCAxMywgNiwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0dvb3NlX0JheSc6IG5ldyBEYXRlKDIwMTEsIDIsIDEzLCAyLCAxLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0FtZXJpY2EvTWlxdWVsb24nOiBuZXcgRGF0ZSgyMDExLCAyLCAxMywgNSwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0dvZHRoYWInOiBuZXcgRGF0ZSgyMDExLCAyLCAyNywgMSwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdFdXJvcGUvTW9zY293JzogcnVfcHJlX2RzdF9jaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICdBc2lhL0FtbWFuJzogbmV3IERhdGUoMjAxMywgMiwgMjksIDEsIDAsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9CZWlydXQnOiBuZXcgRGF0ZSgyMDEzLCAyLCAzMSwgMiwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBc2lhL0RhbWFzY3VzJzogbmV3IERhdGUoMjAxMywgMywgNiwgMiwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBc2lhL0plcnVzYWxlbSc6IG5ldyBEYXRlKDIwMTMsIDIsIDI5LCA1LCAwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0FzaWEvWWVrYXRlcmluYnVyZyc6IHJ1X3ByZV9kc3RfY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9PbXNrJzogcnVfcHJlX2RzdF9jaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICdBc2lhL0tyYXNub3lhcnNrJzogcnVfcHJlX2RzdF9jaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICdBc2lhL0lya3V0c2snOiBydV9wcmVfZHN0X2NoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgJ0FzaWEvWWFrdXRzayc6IHJ1X3ByZV9kc3RfY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9WbGFkaXZvc3Rvayc6IHJ1X3ByZV9kc3RfY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9CYWt1JzogbmV3IERhdGUoMjAxMywgMiwgMzEsIDQsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9ZZXJldmFuJzogbmV3IERhdGUoMjAxMywgMiwgMzEsIDMsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9LYW1jaGF0a2EnOiBydV9wcmVfZHN0X2NoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgJ0FzaWEvR2F6YSc6IG5ldyBEYXRlKDIwMTAsIDIsIDI3LCA0LCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0FmcmljYS9DYWlybyc6IG5ldyBEYXRlKDIwMTAsIDQsIDEsIDMsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnRXVyb3BlL01pbnNrJzogcnVfcHJlX2RzdF9jaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICdQYWNpZmljL0FwaWEnOiBuZXcgRGF0ZSgyMDEwLCAxMCwgMSwgMSwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdQYWNpZmljL0ZpamknOiBuZXcgRGF0ZSgyMDEwLCAxMSwgMSwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBdXN0cmFsaWEvUGVydGgnOiBuZXcgRGF0ZSgyMDA4LCAxMCwgMSwgMSwgMCwgMCwgMClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHJldHVybiBkc3Rfc3RhcnRzW3R6X25hbWVdO1xuICAgICAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGV0ZXJtaW5lOiBkZXRlcm1pbmUsXG4gICAgICAgICAgZGF0ZV9pc19kc3Q6IGRhdGVfaXNfZHN0LFxuICAgICAgICAgIGRzdF9zdGFydF9mb3I6IGRzdF9zdGFydF9mb3IgXG4gICAgICB9O1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBTaW1wbGUgb2JqZWN0IHRvIHBlcmZvcm0gYW1iaWd1aXR5IGNoZWNrIGFuZCB0byByZXR1cm4gbmFtZSBvZiB0aW1lIHpvbmUuXG4gICAqL1xuICBqc3R6LlRpbWVab25lID0gZnVuY3Rpb24gKHR6X25hbWUpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBrZXlzIGluIHRoaXMgb2JqZWN0IGFyZSB0aW1lem9uZXMgdGhhdCB3ZSBrbm93IG1heSBiZSBhbWJpZ3VvdXMgYWZ0ZXJcbiAgICAgICAgICogYSBwcmVsaW1pbmFyeSBzY2FuIHRocm91Z2ggdGhlIG9sc29uX3R6IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGFycmF5IG9mIHRpbWV6b25lcyB0byBjb21wYXJlIG11c3QgYmUgaW4gdGhlIG9yZGVyIHRoYXQgZGF5bGlnaHQgc2F2aW5nc1xuICAgICAgICAgKiBzdGFydHMgZm9yIHRoZSByZWdpb25zLlxuICAgICAgICAgKi9cbiAgICAgIHZhciBBTUJJR1VJVElFUyA9IHtcbiAgICAgICAgICAgICAgJ0FtZXJpY2EvRGVudmVyJzogICAgICAgWydBbWVyaWNhL0RlbnZlcicsICdBbWVyaWNhL01hemF0bGFuJ10sXG4gICAgICAgICAgICAgICdBbWVyaWNhL0NoaWNhZ28nOiAgICAgIFsnQW1lcmljYS9DaGljYWdvJywgJ0FtZXJpY2EvTWV4aWNvX0NpdHknXSxcbiAgICAgICAgICAgICAgJ0FtZXJpY2EvU2FudGlhZ28nOiAgICAgWydBbWVyaWNhL1NhbnRpYWdvJywgJ0FtZXJpY2EvQXN1bmNpb24nLCAnQW1lcmljYS9DYW1wb19HcmFuZGUnXSxcbiAgICAgICAgICAgICAgJ0FtZXJpY2EvTW9udGV2aWRlbyc6ICAgWydBbWVyaWNhL01vbnRldmlkZW8nLCAnQW1lcmljYS9TYW9fUGF1bG8nXSxcbiAgICAgICAgICAgICAgJ0FzaWEvQmVpcnV0JzogICAgICAgICAgWydBc2lhL0FtbWFuJywgJ0FzaWEvSmVydXNhbGVtJywgJ0FzaWEvQmVpcnV0JywgJ0V1cm9wZS9IZWxzaW5raScsJ0FzaWEvRGFtYXNjdXMnXSxcbiAgICAgICAgICAgICAgJ1BhY2lmaWMvQXVja2xhbmQnOiAgICAgWydQYWNpZmljL0F1Y2tsYW5kJywgJ1BhY2lmaWMvRmlqaSddLFxuICAgICAgICAgICAgICAnQW1lcmljYS9Mb3NfQW5nZWxlcyc6ICBbJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnLCAnQW1lcmljYS9TYW50YV9Jc2FiZWwnXSxcbiAgICAgICAgICAgICAgJ0FtZXJpY2EvTmV3X1lvcmsnOiAgICAgWydBbWVyaWNhL0hhdmFuYScsICdBbWVyaWNhL05ld19Zb3JrJ10sXG4gICAgICAgICAgICAgICdBbWVyaWNhL0hhbGlmYXgnOiAgICAgIFsnQW1lcmljYS9Hb29zZV9CYXknLCAnQW1lcmljYS9IYWxpZmF4J10sXG4gICAgICAgICAgICAgICdBbWVyaWNhL0dvZHRoYWInOiAgICAgIFsnQW1lcmljYS9NaXF1ZWxvbicsICdBbWVyaWNhL0dvZHRoYWInXSxcbiAgICAgICAgICAgICAgJ0FzaWEvRHViYWknOiAgICAgICAgICAgWydFdXJvcGUvTW9zY293J10sXG4gICAgICAgICAgICAgICdBc2lhL0RoYWthJzogICAgICAgICAgIFsnQXNpYS9ZZWthdGVyaW5idXJnJ10sXG4gICAgICAgICAgICAgICdBc2lhL0pha2FydGEnOiAgICAgICAgIFsnQXNpYS9PbXNrJ10sXG4gICAgICAgICAgICAgICdBc2lhL1NoYW5naGFpJzogICAgICAgIFsnQXNpYS9LcmFzbm95YXJzaycsICdBdXN0cmFsaWEvUGVydGgnXSxcbiAgICAgICAgICAgICAgJ0FzaWEvVG9reW8nOiAgICAgICAgICAgWydBc2lhL0lya3V0c2snXSxcbiAgICAgICAgICAgICAgJ0F1c3RyYWxpYS9CcmlzYmFuZSc6ICAgWydBc2lhL1lha3V0c2snXSxcbiAgICAgICAgICAgICAgJ1BhY2lmaWMvTm91bWVhJzogICAgICAgWydBc2lhL1ZsYWRpdm9zdG9rJ10sXG4gICAgICAgICAgICAgICdQYWNpZmljL1RhcmF3YSc6ICAgICAgIFsnQXNpYS9LYW1jaGF0a2EnLCAnUGFjaWZpYy9GaWppJ10sXG4gICAgICAgICAgICAgICdQYWNpZmljL1RvbmdhdGFwdSc6ICAgIFsnUGFjaWZpYy9BcGlhJ10sXG4gICAgICAgICAgICAgICdBc2lhL0JhZ2hkYWQnOiAgICAgICAgIFsnRXVyb3BlL01pbnNrJ10sXG4gICAgICAgICAgICAgICdBc2lhL0Jha3UnOiAgICAgICAgICAgIFsnQXNpYS9ZZXJldmFuJywnQXNpYS9CYWt1J10sXG4gICAgICAgICAgICAgICdBZnJpY2EvSm9oYW5uZXNidXJnJzogIFsnQXNpYS9HYXphJywgJ0FmcmljYS9DYWlybyddXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHRpbWV6b25lX25hbWUgPSB0el9uYW1lLFxuICAgICAgICAgIFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENoZWNrcyBpZiBhIHRpbWV6b25lIGhhcyBwb3NzaWJsZSBhbWJpZ3VpdGllcy4gSS5lIHRpbWV6b25lcyB0aGF0IGFyZSBzaW1pbGFyLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBwcmVsaW1pbmFyeSBzY2FuIGRldGVybWluZXMgdGhhdCB3ZSdyZSBpbiBBbWVyaWNhL0RlbnZlci5cbiAgICAgICAgICAgKiBXZSBkb3VibGUgY2hlY2sgaGVyZSB0aGF0IHdlJ3JlIHJlYWxseSB0aGVyZSBhbmQgbm90IGluIEFtZXJpY2EvTWF6YXRsYW4uXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIGlzIGRvbmUgYnkgY2hlY2tpbmcga25vd24gZGF0ZXMgZm9yIHdoZW4gZGF5bGlnaHQgc2F2aW5ncyBzdGFydCBmb3IgZGlmZmVyZW50XG4gICAgICAgICAgICogdGltZXpvbmVzIGR1cmluZyAyMDEwIGFuZCAyMDExLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGFtYmlndWl0eV9jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGFtYmlndWl0eV9saXN0ID0gQU1CSUdVSVRJRVNbdGltZXpvbmVfbmFtZV0sXG4gICAgICAgICAgICAgICAgICBsZW5ndGggPSBhbWJpZ3VpdHlfbGlzdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgIHR6ID0gYW1iaWd1aXR5X2xpc3RbMF07XG5cbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgdHogPSBhbWJpZ3VpdHlfbGlzdFtpXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGpzdHouZGF0ZV9pc19kc3QoanN0ei5kc3Rfc3RhcnRfZm9yKHR6KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZV9uYW1lID0gdHo7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENoZWNrcyBpZiBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSB0aW1lem9uZSBpcyBhbWJpZ3VvdXMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgaXNfYW1iaWd1b3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIChBTUJJR1VJVElFU1t0aW1lem9uZV9uYW1lXSkgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgIH07XG5cbiAgICAgIGlmIChpc19hbWJpZ3VvdXMoKSkge1xuICAgICAgICAgIGFtYmlndWl0eV9jaGVjaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRpbWV6b25lX25hbWU7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfTtcblxuICBqc3R6Lm9sc29uID0ge307XG5cbiAgLypcbiAgICogVGhlIGtleXMgaW4gdGhpcyBkaWN0aW9uYXJ5IGFyZSBjb21tYSBzZXBhcmF0ZWQgYXMgc3VjaDpcbiAgICpcbiAgICogRmlyc3QgdGhlIG9mZnNldCBjb21wYXJlZCB0byBVVEMgdGltZSBpbiBtaW51dGVzLlxuICAgKlxuICAgKiBUaGVuIGEgZmxhZyB3aGljaCBpcyAwIGlmIHRoZSB0aW1lem9uZSBkb2VzIG5vdCB0YWtlIGRheWxpZ2h0IHNhdmluZ3MgaW50byBhY2NvdW50IGFuZCAxIGlmIGl0XG4gICAqIGRvZXMuXG4gICAqXG4gICAqIFRoaXJkbHkgYW4gb3B0aW9uYWwgJ3MnIHNpZ25pZmllcyB0aGF0IHRoZSB0aW1lem9uZSBpcyBpbiB0aGUgc291dGhlcm4gaGVtaXNwaGVyZSxcbiAgICogb25seSBpbnRlcmVzdGluZyBmb3IgdGltZXpvbmVzIHdpdGggRFNULlxuICAgKlxuICAgKiBUaGUgbWFwcGVkIGFycmF5cyBpcyB1c2VkIGZvciBjb25zdHJ1Y3RpbmcgdGhlIGpzdHouVGltZVpvbmUgb2JqZWN0IGZyb20gd2l0aGluXG4gICAqIGpzdHouZGV0ZXJtaW5lX3RpbWV6b25lKCk7XG4gICAqL1xuICBqc3R6Lm9sc29uLnRpbWV6b25lcyA9IHtcbiAgICAgICctNzIwLDAnICAgOiAnUGFjaWZpYy9NYWp1cm8nLFxuICAgICAgJy02NjAsMCcgICA6ICdQYWNpZmljL1BhZ29fUGFnbycsXG4gICAgICAnLTYwMCwxJyAgIDogJ0FtZXJpY2EvQWRhaycsXG4gICAgICAnLTYwMCwwJyAgIDogJ1BhY2lmaWMvSG9ub2x1bHUnLFxuICAgICAgJy01NzAsMCcgICA6ICdQYWNpZmljL01hcnF1ZXNhcycsXG4gICAgICAnLTU0MCwwJyAgIDogJ1BhY2lmaWMvR2FtYmllcicsXG4gICAgICAnLTU0MCwxJyAgIDogJ0FtZXJpY2EvQW5jaG9yYWdlJyxcbiAgICAgICctNDgwLDEnICAgOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycsXG4gICAgICAnLTQ4MCwwJyAgIDogJ1BhY2lmaWMvUGl0Y2Fpcm4nLFxuICAgICAgJy00MjAsMCcgICA6ICdBbWVyaWNhL1Bob2VuaXgnLFxuICAgICAgJy00MjAsMScgICA6ICdBbWVyaWNhL0RlbnZlcicsXG4gICAgICAnLTM2MCwwJyAgIDogJ0FtZXJpY2EvR3VhdGVtYWxhJyxcbiAgICAgICctMzYwLDEnICAgOiAnQW1lcmljYS9DaGljYWdvJyxcbiAgICAgICctMzYwLDEscycgOiAnUGFjaWZpYy9FYXN0ZXInLFxuICAgICAgJy0zMDAsMCcgICA6ICdBbWVyaWNhL0JvZ290YScsXG4gICAgICAnLTMwMCwxJyAgIDogJ0FtZXJpY2EvTmV3X1lvcmsnLFxuICAgICAgJy0yNzAsMCcgICA6ICdBbWVyaWNhL0NhcmFjYXMnLFxuICAgICAgJy0yNDAsMScgICA6ICdBbWVyaWNhL0hhbGlmYXgnLFxuICAgICAgJy0yNDAsMCcgICA6ICdBbWVyaWNhL1NhbnRvX0RvbWluZ28nLFxuICAgICAgJy0yNDAsMSxzJyA6ICdBbWVyaWNhL1NhbnRpYWdvJyxcbiAgICAgICctMjEwLDEnICAgOiAnQW1lcmljYS9TdF9Kb2hucycsXG4gICAgICAnLTE4MCwxJyAgIDogJ0FtZXJpY2EvR29kdGhhYicsXG4gICAgICAnLTE4MCwwJyAgIDogJ0FtZXJpY2EvQXJnZW50aW5hL0J1ZW5vc19BaXJlcycsXG4gICAgICAnLTE4MCwxLHMnIDogJ0FtZXJpY2EvTW9udGV2aWRlbycsXG4gICAgICAnLTEyMCwwJyAgIDogJ0FtZXJpY2EvTm9yb25oYScsXG4gICAgICAnLTEyMCwxJyAgIDogJ0FtZXJpY2EvTm9yb25oYScsXG4gICAgICAnLTYwLDEnICAgIDogJ0F0bGFudGljL0F6b3JlcycsXG4gICAgICAnLTYwLDAnICAgIDogJ0F0bGFudGljL0NhcGVfVmVyZGUnLFxuICAgICAgJzAsMCcgICAgICA6ICdVVEMnLFxuICAgICAgJzAsMScgICAgICA6ICdFdXJvcGUvTG9uZG9uJyxcbiAgICAgICc2MCwxJyAgICAgOiAnRXVyb3BlL0JlcmxpbicsXG4gICAgICAnNjAsMCcgICAgIDogJ0FmcmljYS9MYWdvcycsXG4gICAgICAnNjAsMSxzJyAgIDogJ0FmcmljYS9XaW5kaG9laycsXG4gICAgICAnMTIwLDEnICAgIDogJ0FzaWEvQmVpcnV0JyxcbiAgICAgICcxMjAsMCcgICAgOiAnQWZyaWNhL0pvaGFubmVzYnVyZycsXG4gICAgICAnMTgwLDAnICAgIDogJ0FzaWEvQmFnaGRhZCcsXG4gICAgICAnMTgwLDEnICAgIDogJ0V1cm9wZS9Nb3Njb3cnLFxuICAgICAgJzIxMCwxJyAgICA6ICdBc2lhL1RlaHJhbicsXG4gICAgICAnMjQwLDAnICAgIDogJ0FzaWEvRHViYWknLFxuICAgICAgJzI0MCwxJyAgICA6ICdBc2lhL0Jha3UnLFxuICAgICAgJzI3MCwwJyAgICA6ICdBc2lhL0thYnVsJyxcbiAgICAgICczMDAsMScgICAgOiAnQXNpYS9ZZWthdGVyaW5idXJnJyxcbiAgICAgICczMDAsMCcgICAgOiAnQXNpYS9LYXJhY2hpJyxcbiAgICAgICczMzAsMCcgICAgOiAnQXNpYS9Lb2xrYXRhJyxcbiAgICAgICczNDUsMCcgICAgOiAnQXNpYS9LYXRobWFuZHUnLFxuICAgICAgJzM2MCwwJyAgICA6ICdBc2lhL0RoYWthJyxcbiAgICAgICczNjAsMScgICAgOiAnQXNpYS9PbXNrJyxcbiAgICAgICczOTAsMCcgICAgOiAnQXNpYS9SYW5nb29uJyxcbiAgICAgICc0MjAsMScgICAgOiAnQXNpYS9LcmFzbm95YXJzaycsXG4gICAgICAnNDIwLDAnICAgIDogJ0FzaWEvSmFrYXJ0YScsXG4gICAgICAnNDgwLDAnICAgIDogJ0FzaWEvU2hhbmdoYWknLFxuICAgICAgJzQ4MCwxJyAgICA6ICdBc2lhL0lya3V0c2snLFxuICAgICAgJzUyNSwwJyAgICA6ICdBdXN0cmFsaWEvRXVjbGEnLFxuICAgICAgJzUyNSwxLHMnICA6ICdBdXN0cmFsaWEvRXVjbGEnLFxuICAgICAgJzU0MCwxJyAgICA6ICdBc2lhL1lha3V0c2snLFxuICAgICAgJzU0MCwwJyAgICA6ICdBc2lhL1Rva3lvJyxcbiAgICAgICc1NzAsMCcgICAgOiAnQXVzdHJhbGlhL0RhcndpbicsXG4gICAgICAnNTcwLDEscycgIDogJ0F1c3RyYWxpYS9BZGVsYWlkZScsXG4gICAgICAnNjAwLDAnICAgIDogJ0F1c3RyYWxpYS9CcmlzYmFuZScsXG4gICAgICAnNjAwLDEnICAgIDogJ0FzaWEvVmxhZGl2b3N0b2snLFxuICAgICAgJzYwMCwxLHMnICA6ICdBdXN0cmFsaWEvU3lkbmV5JyxcbiAgICAgICc2MzAsMSxzJyAgOiAnQXVzdHJhbGlhL0xvcmRfSG93ZScsXG4gICAgICAnNjYwLDEnICAgIDogJ0FzaWEvS2FtY2hhdGthJyxcbiAgICAgICc2NjAsMCcgICAgOiAnUGFjaWZpYy9Ob3VtZWEnLFxuICAgICAgJzY5MCwwJyAgICA6ICdQYWNpZmljL05vcmZvbGsnLFxuICAgICAgJzcyMCwxLHMnICA6ICdQYWNpZmljL0F1Y2tsYW5kJyxcbiAgICAgICc3MjAsMCcgICAgOiAnUGFjaWZpYy9UYXJhd2EnLFxuICAgICAgJzc2NSwxLHMnICA6ICdQYWNpZmljL0NoYXRoYW0nLFxuICAgICAgJzc4MCwwJyAgICA6ICdQYWNpZmljL1RvbmdhdGFwdScsXG4gICAgICAnNzgwLDEscycgIDogJ1BhY2lmaWMvQXBpYScsXG4gICAgICAnODQwLDAnICAgIDogJ1BhY2lmaWMvS2lyaXRpbWF0aSdcbiAgfTtcblxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5qc3R6ID0ganN0ejtcbiAgfSBlbHNlIHtcbiAgICByb290LmpzdHogPSBqc3R6O1xuICB9XG59KSh0aGlzKTtcblxuIiwiLy8gTWluZ28uanMgMC40LjBcclxuLy8gQ29weXJpZ2h0IChjKSAyMDE1IEZyYW5jaXMgQXNhbnRlIDxrb2ZyYXNhQGdtYWlsLmNvbT5cclxuLy8gTUlUXHJcblxyXG4oZnVuY3Rpb24gKHJvb3QsIHVuZGVmaW5lZCkge1xyXG5cclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgLy8gZ2xvYmFsIG9uIHRoZSBzZXJ2ZXIsIHdpbmRvdyBpbiB0aGUgYnJvd3NlclxyXG4gIHZhciBNaW5nbyA9IHt9LCBwcmV2aW91c01pbmdvO1xyXG4gIHZhciBfO1xyXG5cclxuICAvLyBiYWNrdXAgcHJldmlvdXMgTWluZ29cclxuICBpZiAocm9vdCAhPSBudWxsKSB7XHJcbiAgICBwcmV2aW91c01pbmdvID0gcm9vdC5NaW5nbztcclxuICB9XHJcblxyXG4gIE1pbmdvLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByb290Lk1pbmdvID0gcHJldmlvdXNNaW5nbztcclxuICAgIHJldHVybiBNaW5nbztcclxuICB9O1xyXG5cclxuICB2YXIgbmF0aXZlU2NyaXB0RW5hYmxlZCA9IEJvb2xlYW4oKCh0eXBlb2YgYW5kcm9pZCAhPT0gJ3VuZGVmaW5lZCcgJiYgYW5kcm9pZCAmJiBhbmRyb2lkLndpZGdldCAmJiBhbmRyb2lkLndpZGdldC5CdXR0b24pXHJcbiAgICB8fCAodHlwZW9mIFVJQnV0dG9uICE9PSAndW5kZWZpbmVkJyAmJiBVSUJ1dHRvbikpKTtcclxuXHJcbiAgdmFyIG5vZGVFbmFibGVkID0gKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgZXhwb3J0cyAmJiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHJlcXVpcmUgJiYgIW5hdGl2ZVNjcmlwdEVuYWJsZWQpO1xyXG5cclxuXHJcbiAgLy8gRXhwb3J0IHRoZSBNaW5nbyBvYmplY3QgZm9yIE5vZGUuanNcclxuICBpZiAobm9kZUVuYWJsZWQgfHwgbmF0aXZlU2NyaXB0RW5hYmxlZCkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE1pbmdvO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXhwb3J0cyA9IE1pbmdvO1xyXG4gICAgfVxyXG4gICAgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpOyAvLyBnZXQgYSByZWZlcmVuY2UgdG8gdW5kZXJzY29yZVxyXG4gIH0gZWxzZSB7XHJcbiAgICByb290Lk1pbmdvID0gTWluZ287XHJcbiAgICBfID0gcm9vdC5fOyAvLyBnZXQgYSByZWZlcmVuY2UgdG8gdW5kZXJzY29yZVxyXG4gIH1cclxuXHJcbiAgLy8gcXVpY2sgcmVmZXJlbmNlIGZvclxyXG4gIHZhciBwcmltaXRpdmVzID0gW1xyXG4gICAgXy5pc1N0cmluZywgXy5pc0Jvb2xlYW4sIF8uaXNOdW1iZXIsIF8uaXNEYXRlLCBfLmlzTnVsbCwgXy5pc1JlZ0V4cFxyXG4gIF07XHJcblxyXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShleHByKSB7XHJcbiAgICAvLyBub3JtYWxpemVkIHByaW1pdGl2ZXNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpbWl0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAocHJpbWl0aXZlc1tpXShleHByKSkge1xyXG4gICAgICAgIGlmIChfLmlzUmVnRXhwKGV4cHIpKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1wiJHJlZ2V4XCI6IGV4cHJ9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4ge1wiJGVxXCI6IGV4cHJ9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbm9ybWFsaXplIG9iamVjdCBleHByZXNzaW9uXHJcbiAgICBpZiAoXy5pc09iamVjdChleHByKSkge1xyXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhleHByKTtcclxuICAgICAgdmFyIG5vdFF1ZXJ5ID0gXy5pbnRlcnNlY3Rpb24oT3BzLnF1ZXJ5T3BlcmF0b3JzLCBrZXlzKS5sZW5ndGggPT09IDA7XHJcblxyXG4gICAgICAvLyBubyB2YWxpZCBxdWVyeSBvcGVyYXRvciBmb3VuZCwgc28gd2UgZG8gc2ltcGxlIGNvbXBhcmlzb25cclxuICAgICAgaWYgKG5vdFF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcIiRlcVwiOiBleHByfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZW5zdXJlIHZhbGlkIHJlZ2V4XHJcbiAgICAgIGlmIChfLmNvbnRhaW5zKGtleXMsIFwiJHJlZ2V4XCIpKSB7XHJcbiAgICAgICAgdmFyIHJlZ2V4ID0gZXhwclsnJHJlZ2V4J107XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHByWyckb3B0aW9ucyddIHx8IFwiXCI7XHJcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IFwiXCI7XHJcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcocmVnZXgpKSB7XHJcbiAgICAgICAgICBtb2RpZmllcnMgKz0gKHJlZ2V4Lmlnbm9yZUNhc2UgfHwgb3B0aW9ucy5pbmRleE9mKFwiaVwiKSA+PSAwKSA/IFwiaVwiIDogXCJcIjtcclxuICAgICAgICAgIG1vZGlmaWVycyArPSAocmVnZXgubXVsdGlsaW5lIHx8IG9wdGlvbnMuaW5kZXhPZihcIm1cIikgPj0gMCkgPyBcIm1cIiA6IFwiXCI7XHJcbiAgICAgICAgICBtb2RpZmllcnMgKz0gKHJlZ2V4Lmdsb2JhbCB8fCBvcHRpb25zLmluZGV4T2YoXCJnXCIpID49IDApID8gXCJnXCIgOiBcIlwiO1xyXG4gICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4LCBtb2RpZmllcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHByWyckcmVnZXgnXSA9IHJlZ2V4O1xyXG4gICAgICAgIGRlbGV0ZSBleHByWyckb3B0aW9ucyddO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV4cHI7XHJcbiAgfVxyXG5cclxuICAvLyBTZXR0aW5ncyB1c2VkIGJ5IE1pbmdvIGludGVybmFsbHlcclxuICB2YXIgc2V0dGluZ3MgPSB7XHJcbiAgICBrZXk6IFwiX2lkXCJcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXR1cCBkZWZhdWx0IHNldHRpbmdzIGZvciBNaW5nb1xyXG4gICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICovXHJcbiAgTWluZ28uc2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgXy5leHRlbmQoc2V0dGluZ3MsIG9wdGlvbnMgfHwge30pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBRdWVyeSBvYmplY3QgdG8gdGVzdCBjb2xsZWN0aW9uIGVsZW1lbnRzIHdpdGhcclxuICAgKiBAcGFyYW0gY3JpdGVyaWEgdGhlIHBhc3MgY3JpdGVyaWEgZm9yIHRoZSBxdWVyeVxyXG4gICAqIEBwYXJhbSBwcm9qZWN0aW9uIG9wdGlvbmFsIHByb2plY3Rpb24gc3BlY2lmaWVyc1xyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqL1xyXG4gIE1pbmdvLlF1ZXJ5ID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBwcm9qZWN0aW9uKSB7XHJcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWluZ28uUXVlcnkpKVxyXG4gICAgICByZXR1cm4gbmV3IE1pbmdvLlF1ZXJ5KGNyaXRlcmlhLCBwcm9qZWN0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9jcml0ZXJpYSA9IGNyaXRlcmlhO1xyXG4gICAgdGhpcy5fcHJvamVjdGlvbiA9IHByb2plY3Rpb247XHJcbiAgICB0aGlzLl9jb21waWxlZCA9IFtdO1xyXG4gICAgdGhpcy5fY29tcGlsZSgpO1xyXG4gIH07XHJcblxyXG4gIE1pbmdvLlF1ZXJ5LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBfY29tcGlsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgaWYgKF8uaXNFbXB0eSh0aGlzLl9jcml0ZXJpYSkpIHJldHVybjtcclxuXHJcbiAgICAgIGlmIChfLmlzQXJyYXkodGhpcy5fY3JpdGVyaWEpIHx8IF8uaXNGdW5jdGlvbih0aGlzLl9jcml0ZXJpYSkgfHwgIV8uaXNPYmplY3QodGhpcy5fY3JpdGVyaWEpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlIGZvciBjcml0ZXJpYVwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5fY3JpdGVyaWEpIHtcclxuICAgICAgICBpZiAodGhpcy5fY3JpdGVyaWEuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XHJcbiAgICAgICAgICB2YXIgZXhwciA9IHRoaXMuX2NyaXRlcmlhW2ZpZWxkXTtcclxuICAgICAgICAgIGlmIChfLmNvbnRhaW5zKFsnJGFuZCcsICckb3InLCAnJG5vcicsICckd2hlcmUnXSwgZmllbGQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NPcGVyYXRvcihmaWVsZCwgZmllbGQsIGV4cHIpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgZXhwciA9IG5vcm1hbGl6ZShleHByKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgb3AgaW4gZXhwcikge1xyXG4gICAgICAgICAgICAgIGlmIChleHByLmhhc093blByb3BlcnR5KG9wKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc09wZXJhdG9yKGZpZWxkLCBvcCwgZXhwcltvcF0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfcHJvY2Vzc09wZXJhdG9yOiBmdW5jdGlvbiAoZmllbGQsIG9wZXJhdG9yLCB2YWx1ZSkge1xyXG4gICAgICB2YXIgY29tcGlsZWRTZWxlY3RvcjtcclxuICAgICAgaWYgKF8uY29udGFpbnMoT3BzLnNpbXBsZU9wZXJhdG9ycywgb3BlcmF0b3IpKSB7XHJcbiAgICAgICAgY29tcGlsZWRTZWxlY3RvciA9IHtcclxuICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgdmFyIGFjdHVhbFZhbHVlID0gcmVzb2x2ZShvYmosIGZpZWxkKTtcclxuICAgICAgICAgICAgLy8gdmFsdWUgb2Ygb3BlcmF0b3IgbXVzdCBhbHJlYWR5IGJlIGZ1bGx5IHJlc29sdmVkLlxyXG4gICAgICAgICAgICByZXR1cm4gc2ltcGxlT3BlcmF0b3JzW29wZXJhdG9yXShhY3R1YWxWYWx1ZSwgdmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZWxzZSBpZiAoXy5jb250YWlucyhPcHMuY29tcG91bmRPcGVyYXRvcnMsIG9wZXJhdG9yKSkge1xyXG4gICAgICAgIGNvbXBpbGVkU2VsZWN0b3IgPSBjb21wb3VuZE9wZXJhdG9yc1tvcGVyYXRvcl0oZmllbGQsIHZhbHVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHF1ZXJ5IG9wZXJhdG9yICdcIiArIG9wZXJhdG9yICsgXCInIGRldGVjdGVkXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NvbXBpbGVkLnB1c2goY29tcGlsZWRTZWxlY3Rvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBvYmplY3QgcGFzc2VzIHRoZSBxdWVyeSBjcml0ZXJpYS4gUmV0dXJucyB0cnVlIGlmIHNvLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGVzdDogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbXBpbGVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlZFtpXS50ZXN0KG9iaikpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBxdWVyeSBvbiBhIGNvbGxlY3Rpb24gYW5kIHJldHVybnMgYSBjdXJzb3Igb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBwcm9qZWN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7TWluZ28uQ3Vyc29yfVxyXG4gICAgICovXHJcbiAgICBmaW5kOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgcHJvamVjdGlvbikge1xyXG4gICAgICByZXR1cm4gbmV3IE1pbmdvLkN1cnNvcihjb2xsZWN0aW9uLCB0aGlzLCBwcm9qZWN0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgbWF0Y2hlZCBkb2N1bWVudHMgZnJvbSB0aGUgY29sbGVjdGlvbiByZXR1cm5pbmcgdGhlIHJlbWFpbmRlclxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghdGhpcy50ZXN0KGNvbGxlY3Rpb25baV0pKSB7XHJcbiAgICAgICAgICBhcnIucHVzaChjb2xsZWN0aW9uW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBpZiAobm9kZUVuYWJsZWQpIHtcclxuXHJcbiAgICB2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG4gICAgTWluZ28uUXVlcnkucHJvdG90eXBlLnN0cmVhbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiBuZXcgTWluZ28uU3RyZWFtKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIFRyYW5zZm9ybSBjbGFzc1xyXG4gICAgICogQHBhcmFtIHF1ZXJ5XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge01pbmdvLlN0cmVhbX1cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBNaW5nby5TdHJlYW0gPSBmdW5jdGlvbiAocXVlcnksIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNaW5nby5TdHJlYW0pKVxyXG4gICAgICAgIHJldHVybiBuZXcgTWluZ28uU3RyZWFtKHF1ZXJ5LCBvcHRpb25zKTtcclxuXHJcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICBfLmV4dGVuZChvcHRpb25zLCB7b2JqZWN0TW9kZTogdHJ1ZX0pO1xyXG4gICAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgLy8gcXVlcnkgZm9yIHRoaXMgc3RyZWFtXHJcbiAgICAgIHRoaXMuX3F1ZXJ5ID0gcXVlcnk7XHJcbiAgICB9O1xyXG4gICAgLy8gZXh0ZW5kIFRyYW5zZm9ybVxyXG4gICAgdXRpbC5pbmhlcml0cyhNaW5nby5TdHJlYW0sIFRyYW5zZm9ybSk7XHJcblxyXG4gICAgTWluZ28uU3RyZWFtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xyXG4gICAgICBpZiAoXy5pc09iamVjdChjaHVuaykgJiYgdGhpcy5fcXVlcnkudGVzdChjaHVuaykpIHtcclxuICAgICAgICBpZiAoXy5pc0VtcHR5KHRoaXMuX3F1ZXJ5Ll9wcm9qZWN0aW9uKSkge1xyXG4gICAgICAgICAgdGhpcy5wdXNoKGNodW5rKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGN1cnNvciA9IG5ldyBNaW5nby5DdXJzb3IoW2NodW5rXSwgdGhpcy5fcXVlcnkpO1xyXG4gICAgICAgICAgaWYgKGN1cnNvci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKGN1cnNvci5uZXh0KCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBkb25lKCk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3Vyc29yIHRvIGl0ZXJhdGUgYW5kIHBlcmZvcm0gZmlsdGVyaW5nIG9uIG1hdGNoZWQgb2JqZWN0c1xyXG4gICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICogQHBhcmFtIHF1ZXJ5XHJcbiAgICogQHBhcmFtIHByb2plY3Rpb25cclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKi9cclxuICBNaW5nby5DdXJzb3IgPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgcXVlcnksIHByb2plY3Rpb24pIHtcclxuXHJcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWluZ28uQ3Vyc29yKSlcclxuICAgICAgcmV0dXJuIG5ldyBNaW5nby5DdXJzb3IoY29sbGVjdGlvbiwgcXVlcnksIHByb2plY3Rpb24pO1xyXG5cclxuICAgIHRoaXMuX3F1ZXJ5ID0gcXVlcnk7XHJcbiAgICB0aGlzLl9jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcclxuICAgIHRoaXMuX3Byb2plY3Rpb24gPSBwcm9qZWN0aW9uIHx8IHF1ZXJ5Ll9wcm9qZWN0aW9uO1xyXG4gICAgdGhpcy5fb3BlcmF0b3JzID0ge307XHJcbiAgICB0aGlzLl9yZXN1bHQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3Bvc2l0aW9uID0gMDtcclxuICB9O1xyXG5cclxuICBNaW5nby5DdXJzb3IucHJvdG90eXBlID0ge1xyXG5cclxuICAgIF9mZXRjaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAodGhpcy5fcmVzdWx0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGluamVjdCBwcm9qZWN0aW9uIG9wZXJhdG9yXHJcbiAgICAgIGlmIChfLmlzT2JqZWN0KHRoaXMuX3Byb2plY3Rpb24pKSB7XHJcbiAgICAgICAgXy5leHRlbmQodGhpcy5fb3BlcmF0b3JzLCB7XCIkcHJvamVjdFwiOiB0aGlzLl9wcm9qZWN0aW9ufSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghXy5pc0FycmF5KHRoaXMuX2NvbGxlY3Rpb24pICYmICFfLmlzT2JqZWN0KHRoaXMuX2NvbGxlY3Rpb24pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgY29sbGVjdGlvbiBpcyBub3Qgb2YgdmFsaWQgdHlwZS4gTXVzdCBiZSBhbiBBcnJheS5cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZpbHRlciBjb2xsZWN0aW9uXHJcbiAgICAgIHRoaXMuX3Jlc3VsdCA9IF8uZmlsdGVyKHRoaXMuX2NvbGxlY3Rpb24sIHRoaXMuX3F1ZXJ5LnRlc3QsIHRoaXMuX3F1ZXJ5KTtcclxuICAgICAgdmFyIHBpcGVsaW5lID0gW107XHJcblxyXG4gICAgICBfLmVhY2goWyckc29ydCcsICckc2tpcCcsICckbGltaXQnLCAnJHByb2plY3QnXSwgZnVuY3Rpb24gKG9wKSB7XHJcbiAgICAgICAgaWYgKF8uaGFzKHNlbGYuX29wZXJhdG9ycywgb3ApKSB7XHJcbiAgICAgICAgICBwaXBlbGluZS5wdXNoKF8ucGljayhzZWxmLl9vcGVyYXRvcnMsIG9wKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChwaXBlbGluZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIGFnZ3JlZ2F0b3IgPSBuZXcgTWluZ28uQWdncmVnYXRvcihwaXBlbGluZSk7XHJcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gYWdncmVnYXRvci5ydW4odGhpcy5fcmVzdWx0LCB0aGlzLl9xdWVyeSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaCBhbmQgcmV0dXJuIGFsbCBtYXRjaGVkIHJlc3VsdHNcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgYWxsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9mZXRjaCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoIGFuZCByZXR1cm4gdGhlIGZpcnN0IG1hdGNoaW5nIHJlc3VsdFxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgZmlyc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY291bnQoKSA+IDAgPyB0aGlzLl9mZXRjaCgpWzBdIDogbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaCBhbmQgcmV0dXJuIHRoZSBsYXN0IG1hdGNoaW5nIG9iamVjdCBmcm9tIHRoZSByZXN1bHRcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGxhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY291bnQoKSA+IDAgPyB0aGlzLl9mZXRjaCgpW3RoaXMuY291bnQoKSAtIDFdIDogbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBtYXRjaGVkIG9iamVjdHMgZm91bmRcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGNvdW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9mZXRjaCgpLmxlbmd0aDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY3Vyc29yIHRoYXQgYmVnaW5zIHJldHVybmluZyByZXN1bHRzIG9ubHkgYWZ0ZXIgcGFzc2luZyBvciBza2lwcGluZyBhIG51bWJlciBvZiBkb2N1bWVudHMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gc2tpcC5cclxuICAgICAqIEByZXR1cm4ge01pbmdvLkN1cnNvcn0gUmV0dXJucyB0aGUgY3Vyc29yLCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cclxuICAgICAqL1xyXG4gICAgc2tpcDogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgXy5leHRlbmQodGhpcy5fb3BlcmF0b3JzLCB7XCIkc2tpcFwiOiBufSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cmFpbnMgdGhlIHNpemUgb2YgYSBjdXJzb3IncyByZXN1bHQgc2V0LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gdGhlIG51bWJlciBvZiByZXN1bHRzIHRvIGxpbWl0IHRvLlxyXG4gICAgICogQHJldHVybiB7TWluZ28uQ3Vyc29yfSBSZXR1cm5zIHRoZSBjdXJzb3IsIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxyXG4gICAgICovXHJcbiAgICBsaW1pdDogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgXy5leHRlbmQodGhpcy5fb3BlcmF0b3JzLCB7XCIkbGltaXRcIjogbn0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHJlc3VsdHMgb3JkZXJlZCBhY2NvcmRpbmcgdG8gYSBzb3J0IHNwZWNpZmljYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kaWZpZXIgYW4gb2JqZWN0IG9mIGtleSBhbmQgdmFsdWVzIHNwZWNpZnlpbmcgdGhlIHNvcnQgb3JkZXIuIDEgZm9yIGFzY2VuZGluZyBhbmQgLTEgZm9yIGRlc2NlbmRpbmdcclxuICAgICAqIEByZXR1cm4ge01pbmdvLkN1cnNvcn0gUmV0dXJucyB0aGUgY3Vyc29yLCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cclxuICAgICAqL1xyXG4gICAgc29ydDogZnVuY3Rpb24gKG1vZGlmaWVyKSB7XHJcbiAgICAgIF8uZXh0ZW5kKHRoaXMuX29wZXJhdG9ycywge1wiJHNvcnRcIjogbW9kaWZpZXJ9KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBkb2N1bWVudCBpbiBhIGN1cnNvci5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3QgfCBCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLmhhc05leHQoKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaCgpW3RoaXMuX3Bvc2l0aW9uKytdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3Vyc29yIGhhcyBkb2N1bWVudHMgYW5kIGNhbiBiZSBpdGVyYXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBoYXNOZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvdW50KCkgPiB0aGlzLl9wb3NpdGlvbjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGV4Y2x1c2l2ZSB1cHBlciBib3VuZCBmb3IgYSBzcGVjaWZpYyBmaWVsZFxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIG1heDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgcmV0dXJuIGdyb3VwT3BlcmF0b3JzLiRtYXgodGhpcy5fZmV0Y2goKSwgZXhwcik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHRoZSBpbmNsdXNpdmUgbG93ZXIgYm91bmQgZm9yIGEgc3BlY2lmaWMgZmllbGRcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBtaW46IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgIHJldHVybiBncm91cE9wZXJhdG9ycy4kbWluKHRoaXMuX2ZldGNoKCksIGV4cHIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGRvY3VtZW50IGluIGEgY3Vyc29yIGFuZCBjb2xsZWN0cyB0aGUgcmV0dXJuIHZhbHVlcyBpbiBhbiBhcnJheS5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBtYXA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gXy5tYXAodGhpcy5fZmV0Y2goKSwgY2FsbGJhY2spO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSBKYXZhU2NyaXB0IGZ1bmN0aW9uIGZvciBldmVyeSBkb2N1bWVudCBpbiBhIGN1cnNvci5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgXy5lYWNoKHRoaXMuX2ZldGNoKCksIGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWdncmVnYXRvciBmb3IgZGVmaW5pbmcgZmlsdGVyIHVzaW5nIG1vbmdvREIgYWdncmVnYXRpb24gcGlwZWxpbmUgc3ludGF4XHJcbiAgICogQHBhcmFtIG9wZXJhdG9ycyBhbiBBcnJheSBvZiBwaXBlbGluZSBvcGVyYXRvcnNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKi9cclxuICBNaW5nby5BZ2dyZWdhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9ycykge1xyXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1pbmdvLkFnZ3JlZ2F0b3IpKVxyXG4gICAgICByZXR1cm4gbmV3IE1pbmdvLkFnZ3JlZ2F0b3Iob3BlcmF0b3JzKTtcclxuXHJcbiAgICB0aGlzLl9vcGVyYXRvcnMgPSBvcGVyYXRvcnM7XHJcbiAgfTtcclxuXHJcbiAgTWluZ28uQWdncmVnYXRvci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0aGUgcGlwZWxpbmUgb3BlcmF0aW9ucyBvdmVyIHRoZSBjb2xsZWN0aW9uIGJ5IG9yZGVyIG9mIHRoZSBzZXF1ZW5jZSBhZGRlZFxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb24gYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBwcm9jZXNzXHJcbiAgICAgKiBAcGFyYW0gcXVlcnkgdGhlIGBNaW5nby5RdWVyeWAgb2JqZWN0IHRvIHVzZSBhcyBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHJ1bjogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIHF1ZXJ5KSB7XHJcbiAgICAgIGlmICghXy5pc0VtcHR5KHRoaXMuX29wZXJhdG9ycykpIHtcclxuICAgICAgICAvLyBydW4gYWdncmVnYXRpb24gcGlwZWxpbmVcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29wZXJhdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5fb3BlcmF0b3JzW2ldO1xyXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRvci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgTWluZ28uUXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBwaXBlbGluZU9wZXJhdG9yc1trZXldLmNhbGwocXVlcnksIGNvbGxlY3Rpb24sIG9wZXJhdG9yW2tleV0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gcGlwZWxpbmVPcGVyYXRvcnNba2V5XShjb2xsZWN0aW9uLCBvcGVyYXRvcltrZXldKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmUgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4ga2V5IG9uIGFuIG9iamVjdFxyXG4gICAqIEBwYXJhbSBvYmpcclxuICAgKiBAcGFyYW0gZmllbGRcclxuICAgKiBAcmV0dXJucyB7Kn1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iaiwgZmllbGQpIHtcclxuICAgIHJldHVybiBfLnJlc3VsdChvYmosIGZpZWxkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc29sdmUgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCAoZG90IHNlcGFyYXRlZCkgb24gdGhlIGdpdmVuIG9iamVjdFxyXG4gICAqIEBwYXJhbSBvYmpcclxuICAgKiBAcGFyYW0gZmllbGRcclxuICAgKiBAcmV0dXJucyB7Kn1cclxuICAgKi9cclxuICBmdW5jdGlvbiByZXNvbHZlKG9iaiwgZmllbGQpIHtcclxuICAgIGlmICghZmllbGQpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHZhciBuYW1lcyA9IGZpZWxkLnNwbGl0KFwiLlwiKTtcclxuICAgIHZhciB2YWx1ZSA9IG9iajtcclxuICAgIHZhciBpc1RleHQ7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpc1RleHQgPSBuYW1lc1tpXS5tYXRjaCgvXlxcZCskLykgPT09IG51bGw7XHJcblxyXG4gICAgICBpZiAoaXNUZXh0ICYmIF8uaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgXy5lYWNoKHZhbHVlLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgaWYgKF8uaXNPYmplY3QoaXRlbSkpIHtcclxuICAgICAgICAgICAgcmVzLnB1c2gocmVzb2x2ZShpdGVtLCBuYW1lc1tpXSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhbHVlID0gcmVzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gZ2V0VmFsdWUodmFsdWUsIG5hbWVzW2ldKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm1zIGEgcXVlcnkgb24gYSBjb2xsZWN0aW9uIGFuZCByZXR1cm5zIGEgY3Vyc29yIG9iamVjdC5cclxuICAgKiBAcGFyYW0gY29sbGVjdGlvblxyXG4gICAqIEBwYXJhbSBjcml0ZXJpYVxyXG4gICAqIEBwYXJhbSBwcm9qZWN0aW9uXHJcbiAgICogQHJldHVybnMge01pbmdvLkN1cnNvcn1cclxuICAgKi9cclxuICBNaW5nby5maW5kID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNyaXRlcmlhLCBwcm9qZWN0aW9uKSB7XHJcbiAgICByZXR1cm4gKG5ldyBNaW5nby5RdWVyeShjcml0ZXJpYSkpLmZpbmQoY29sbGVjdGlvbiwgcHJvamVjdGlvbik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyBhcnJheSB3aXRob3V0IG9iamVjdHMgd2hpY2ggbWF0Y2ggdGhlIGNyaXRlcmlhXHJcbiAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgKiBAcGFyYW0gY3JpdGVyaWFcclxuICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICovXHJcbiAgTWluZ28ucmVtb3ZlID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNyaXRlcmlhKSB7XHJcbiAgICByZXR1cm4gKG5ldyBNaW5nby5RdWVyeShjcml0ZXJpYSkpLnJlbW92ZShjb2xsZWN0aW9uKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHJlc3VsdCBjb2xsZWN0aW9uIGFmdGVyIHJ1bm5pbmcgdGhlIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lIGZvciB0aGUgZ2l2ZW4gY29sbGVjdGlvblxyXG4gICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICogQHBhcmFtIHBpcGVsaW5lXHJcbiAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAqL1xyXG4gIE1pbmdvLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBwaXBlbGluZSkge1xyXG4gICAgaWYgKCFfLmlzQXJyYXkocGlwZWxpbmUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFnZ3JlZ2F0aW9uIHBpcGVsaW5lIG11c3QgYmUgYW4gYXJyYXlcIilcclxuICAgIH1cclxuICAgIHJldHVybiAobmV3IE1pbmdvLkFnZ3JlZ2F0b3IocGlwZWxpbmUpKS5ydW4oY29sbGVjdGlvbik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTWl4aW4gZm9yIEJhY2tib25lLkNvbGxlY3Rpb24gb2JqZWN0c1xyXG4gICAqL1xyXG4gIE1pbmdvLkNvbGxlY3Rpb25NaXhpbiA9IHtcclxuICAgIC8qKlxyXG4gICAgICogUnVucyBhIHF1ZXJ5IGFuZCByZXR1cm5zIGEgY3Vyc29yIHRvIHRoZSByZXN1bHRcclxuICAgICAqIEBwYXJhbSBjcml0ZXJpYVxyXG4gICAgICogQHBhcmFtIHByb2plY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtNaW5nby5DdXJzb3J9XHJcbiAgICAgKi9cclxuICAgIHF1ZXJ5OiBmdW5jdGlvbiAoY3JpdGVyaWEsIHByb2plY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIE1pbmdvLmZpbmQodGhpcy50b0pTT04oKSwgY3JpdGVyaWEsIHByb2plY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdGhlIGdpdmVuIGFnZ3JlZ2F0aW9uIG9wZXJhdG9ycyBvbiB0aGlzIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbXMgcGlwZWxpbmVcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgYWdncmVnYXRlOiBmdW5jdGlvbiAocGlwZWxpbmUpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBbdGhpcy50b0pTT04oKSwgcGlwZWxpbmVdO1xyXG4gICAgICByZXR1cm4gTWluZ28uYWdncmVnYXRlLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBwaXBlbGluZU9wZXJhdG9ycyA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwcyBkb2N1bWVudHMgdG9nZXRoZXIgZm9yIHRoZSBwdXJwb3NlIG9mIGNhbGN1bGF0aW5nIGFnZ3JlZ2F0ZSB2YWx1ZXMgYmFzZWQgb24gYSBjb2xsZWN0aW9uIG9mIGRvY3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgJGdyb3VwOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgZXhwcikge1xyXG4gICAgICAvLyBsb29rdXAga2V5IGZvciBncm91cGluZ1xyXG4gICAgICB2YXIgaWRLZXkgPSBleHByW3NldHRpbmdzLmtleV07XHJcbiAgICAgIHZhciBpbmRleGVzID0gW107XHJcbiAgICAgIC8vIGdyb3VwIGNvbGxlY3Rpb24gYnkga2V5XHJcbiAgICAgIHZhciBncm91cHMgPSBfLmdyb3VwQnkoY29sbGVjdGlvbiwgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHZhciBrZXkgPSBjb21wdXRlVmFsdWUob2JqLCBpZEtleSwgaWRLZXkpO1xyXG4gICAgICAgIGluZGV4ZXMucHVzaChrZXkpO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gZ3JvdXAgaW5kZXhlc1xyXG4gICAgICBpbmRleGVzID0gXy51bmlxKGluZGV4ZXMpO1xyXG5cclxuICAgICAgLy8gcmVtb3ZlIHRoZSBncm91cCBrZXlcclxuICAgICAgZXhwciA9IF8ub21pdChleHByLCBzZXR0aW5ncy5rZXkpO1xyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICBfLmVhY2goaW5kZXhlcywgZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xyXG4gICAgICAgIG9ialtzZXR0aW5ncy5rZXldID0gaW5kZXg7XHJcbiAgICAgICAgLy8gY29tcHV0ZSByZW1haW5pbmcga2V5cyBpbiBleHByZXNzaW9uXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGV4cHIpIHtcclxuICAgICAgICAgIGlmIChleHByLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgb2JqW2tleV0gPSBhY2N1bXVsYXRlKGdyb3Vwc1tpbmRleF0sIGtleSwgZXhwcltrZXldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnB1c2gob2JqKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbHRlcnMgdGhlIGRvY3VtZW50IHN0cmVhbSwgYW5kIG9ubHkgYWxsb3dzIG1hdGNoaW5nIGRvY3VtZW50cyB0byBwYXNzIGludG8gdGhlIG5leHQgcGlwZWxpbmUgc3RhZ2UuXHJcbiAgICAgKiAkbWF0Y2ggdXNlcyBzdGFuZGFyZCBNb25nb0RCIHF1ZXJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8Kn1cclxuICAgICAqL1xyXG4gICAgJG1hdGNoOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgZXhwcikge1xyXG4gICAgICByZXR1cm4gKG5ldyBNaW5nby5RdWVyeShleHByKSkuZmluZChjb2xsZWN0aW9uKS5hbGwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNoYXBlcyBhIGRvY3VtZW50IHN0cmVhbS5cclxuICAgICAqICRwcm9qZWN0IGNhbiByZW5hbWUsIGFkZCwgb3IgcmVtb3ZlIGZpZWxkcyBhcyB3ZWxsIGFzIGNyZWF0ZSBjb21wdXRlZCB2YWx1ZXMgYW5kIHN1Yi1kb2N1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgICRwcm9qZWN0OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgZXhwcikge1xyXG5cclxuICAgICAgaWYgKF8uaXNFbXB0eShleHByKSkge1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZXN1bHQgY29sbGVjdGlvblxyXG4gICAgICB2YXIgcHJvamVjdGVkID0gW107XHJcbiAgICAgIHZhciBvYmpLZXlzID0gXy5rZXlzKGV4cHIpO1xyXG5cclxuICAgICAgaWYgKF8uY29udGFpbnMob2JqS2V5cywgc2V0dGluZ3Mua2V5KSkge1xyXG4gICAgICAgIHZhciBpZCA9IGV4cHJbc2V0dGluZ3Mua2V5XTtcclxuICAgICAgICBpZiAoaWQgPT09IDAgfHwgaWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICBvYmpLZXlzID0gXy53aXRob3V0KG9iaktleXMsIHNldHRpbmdzLmtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIG5vdCBzcGVjaWZpZWQgdGhlIGFkZCB0aGUgSUQgZmllbGRcclxuICAgICAgICBvYmpLZXlzLnB1c2goc2V0dGluZ3Mua2V5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IGNvbGxlY3Rpb25baV07XHJcbiAgICAgICAgdmFyIGNsb25lT2JqID0ge307XHJcbiAgICAgICAgdmFyIGZvdW5kU2xpY2UgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZHJvcEtleXMgPSBbXTtcclxuXHJcbiAgICAgICAgXy5lYWNoKG9iaktleXMsIGZ1bmN0aW9uIChrZXkpIHtcclxuXHJcbiAgICAgICAgICB2YXIgc3ViRXhwciA9IGV4cHJba2V5XTtcclxuICAgICAgICAgIHZhciBuZXdWYWx1ZTtcclxuXHJcbiAgICAgICAgICAvLyB0aW55IG9wdGltaXphdGlvbiBoZXJlIHRvIHNraXAgb3ZlciBpZFxyXG4gICAgICAgICAgaWYgKGtleSA9PT0gc2V0dGluZ3Mua2V5ICYmIF8uaXNFbXB0eShzdWJFeHByKSkge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHN1YkV4cHIpKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29tcHV0ZVZhbHVlKG9iaiwgc3ViRXhwciwga2V5KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3ViRXhwciA9PT0gMSB8fCBzdWJFeHByID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gXy5yZXN1bHQob2JqLCBrZXkpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHN1YkV4cHIpKSB7XHJcbiAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IF8ua2V5cyhzdWJFeHByKTtcclxuICAgICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5sZW5ndGggPiAxID8gZmFsc2UgOiBvcGVyYXRvclswXTtcclxuICAgICAgICAgICAgaWYgKG9wZXJhdG9yICE9PSBmYWxzZSAmJiBfLmNvbnRhaW5zKE9wcy5wcm9qZWN0aW9uT3BlcmF0b3JzLCBvcGVyYXRvcikpIHtcclxuICAgICAgICAgICAgICAvLyBhcHBseSB0aGUgcHJvamVjdGlvbiBvcGVyYXRvciBvbiB0aGUgb3BlcmF0b3IgZXhwcmVzc2lvbiBmb3IgdGhlIGtleVxyXG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gcHJvamVjdGlvbk9wZXJhdG9yc1tvcGVyYXRvcl0ob2JqLCBzdWJFeHByW29wZXJhdG9yXSwga2V5KTtcclxuICAgICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodGVtcCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGVtcDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09ICckc2xpY2UnKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZFNsaWNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSBzdWIgZXhwcmVzc2lvbiBmb3IgdGhlIGtleVxyXG4gICAgICAgICAgICAgIG5ld1ZhbHVlID0gY29tcHV0ZVZhbHVlKG9iaiwgc3ViRXhwciwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZHJvcEtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNsb25lT2JqW2tleV0gPSBfLmlzT2JqZWN0KG5ld1ZhbHVlKSA/IF8uY2xvbmUobmV3VmFsdWUpIDogbmV3VmFsdWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGlmIHByb2plY3Rpb24gaW5jbHVkZWQgJHNsaWNlIG9wZXJhdG9yXHJcbiAgICAgICAgLy8gaW5jbHVkZSBrZXlzIHRoYXQgd2VyZSBub3QgZXhwbGljaXRseSBleGNsdWRlZFxyXG4gICAgICAgIGlmIChmb3VuZFNsaWNlKSB7XHJcbiAgICAgICAgICBjbG9uZU9iaiA9IF8uZGVmYXVsdHMoY2xvbmVPYmosIF8ub21pdChvYmosIGRyb3BLZXlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb2plY3RlZC5wdXNoKGNsb25lT2JqKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHByb2plY3RlZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN0cmljdHMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgaW4gYW4gYWdncmVnYXRpb24gcGlwZWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge09iamVjdHwqfVxyXG4gICAgICovXHJcbiAgICAkbGltaXQ6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCB2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gXy5maXJzdChjb2xsZWN0aW9uLCB2YWx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2tpcHMgb3ZlciBhIHNwZWNpZmllZCBudW1iZXIgb2YgZG9jdW1lbnRzIGZyb20gdGhlIHBpcGVsaW5lIGFuZCByZXR1cm5zIHRoZSByZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICAkc2tpcDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBfLnJlc3QoY29sbGVjdGlvbiwgdmFsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGFuIGFycmF5IG9mIGRvY3VtZW50cyBhbmQgcmV0dXJucyB0aGVtIGFzIGEgc3RyZWFtIG9mIGRvY3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgJHVud2luZDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGV4cHIpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICB2YXIgZmllbGQgPSBleHByLnN1YnN0cigxKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IGNvbGxlY3Rpb25baV07XHJcbiAgICAgICAgLy8gbXVzdCB0aHJvdyBhbiBlcnJvciBpZiB2YWx1ZSBpcyBub3QgYW4gYXJyYXlcclxuICAgICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmosIGZpZWxkKTtcclxuICAgICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgXy5lYWNoKHZhbHVlLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICB2YXIgdG1wID0gXy5jbG9uZShvYmopO1xyXG4gICAgICAgICAgICB0bXBbZmllbGRdID0gaXRlbTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godG1wKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQgZmllbGQgJ1wiICsgZmllbGQgKyBcIicgaXMgbm90IG9mIHR5cGUgQXJyYXkuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGFsbCBpbnB1dCBkb2N1bWVudHMgYW5kIHJldHVybnMgdGhlbSBpbiBhIHN0cmVhbSBvZiBzb3J0ZWQgZG9jdW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gc29ydEtleXNcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICAkc29ydDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIHNvcnRLZXlzKSB7XHJcbiAgICAgIGlmICghXy5pc0VtcHR5KHNvcnRLZXlzKSAmJiBfLmlzT2JqZWN0KHNvcnRLZXlzKSkge1xyXG4gICAgICAgIHZhciBtb2RpZmllcnMgPSBfLmtleXMoc29ydEtleXMpO1xyXG4gICAgICAgIG1vZGlmaWVycy5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICB2YXIgaW5kZXhlcyA9IFtdO1xyXG4gICAgICAgICAgdmFyIGdyb3VwZWQgPSBfLmdyb3VwQnkoY29sbGVjdGlvbiwgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByZXNvbHZlKG9iaiwga2V5KTtcclxuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBpbmRleGVzID0gXy5zb3J0QnkoXy51bmlxKGluZGV4ZXMpLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgaWYgKHNvcnRLZXlzW2tleV0gPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGluZGV4ZXMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29sbGVjdGlvbiA9IFtdO1xyXG4gICAgICAgICAgXy5lYWNoKGluZGV4ZXMsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNvbGxlY3Rpb24sIGdyb3VwZWRbaXRlbV0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNvbXBvdW5kT3BlcmF0b3JzID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSm9pbnMgcXVlcnkgY2xhdXNlcyB3aXRoIGEgbG9naWNhbCBBTkQgcmV0dXJucyBhbGwgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlIGNvbmRpdGlvbnMgb2YgYm90aCBjbGF1c2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWxlY3RvclxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7e3Rlc3Q6IEZ1bmN0aW9ufX1cclxuICAgICAqL1xyXG4gICAgJGFuZDogZnVuY3Rpb24gKHNlbGVjdG9yLCB2YWx1ZSkge1xyXG4gICAgICBpZiAoIV8uaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGV4cHJlc3Npb24gZm9yICRhbmQgY3JpdGVyaWFcIik7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHF1ZXJpZXMgPSBbXTtcclxuICAgICAgXy5lYWNoKHZhbHVlLCBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgIHF1ZXJpZXMucHVzaChuZXcgTWluZ28uUXVlcnkoZXhwcikpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghcXVlcmllc1tpXS50ZXN0KG9iaikpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBKb2lucyBxdWVyeSBjbGF1c2VzIHdpdGggYSBsb2dpY2FsIE9SIHJldHVybnMgYWxsIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoZSBjb25kaXRpb25zIG9mIGVpdGhlciBjbGF1c2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHt7dGVzdDogRnVuY3Rpb259fVxyXG4gICAgICovXHJcbiAgICAkb3I6IGZ1bmN0aW9uIChzZWxlY3RvciwgdmFsdWUpIHtcclxuICAgICAgaWYgKCFfLmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBleHByZXNzaW9uIGZvciAkb3IgY3JpdGVyaWFcIik7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHF1ZXJpZXMgPSBbXTtcclxuICAgICAgXy5lYWNoKHZhbHVlLCBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgIHF1ZXJpZXMucHVzaChuZXcgTWluZ28uUXVlcnkoZXhwcikpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChxdWVyaWVzW2ldLnRlc3Qob2JqKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEpvaW5zIHF1ZXJ5IGNsYXVzZXMgd2l0aCBhIGxvZ2ljYWwgTk9SIHJldHVybnMgYWxsIGRvY3VtZW50cyB0aGF0IGZhaWwgdG8gbWF0Y2ggYm90aCBjbGF1c2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWxlY3RvclxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7e3Rlc3Q6IEZ1bmN0aW9ufX1cclxuICAgICAqL1xyXG4gICAgJG5vcjogZnVuY3Rpb24gKHNlbGVjdG9yLCB2YWx1ZSkge1xyXG4gICAgICBpZiAoIV8uaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGV4cHJlc3Npb24gZm9yICRub3IgY3JpdGVyaWFcIik7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy4kb3IoXCIkb3JcIiwgdmFsdWUpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgIHJldHVybiAhcXVlcnkudGVzdChvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZlcnRzIHRoZSBlZmZlY3Qgb2YgYSBxdWVyeSBleHByZXNzaW9uIGFuZCByZXR1cm5zIGRvY3VtZW50cyB0aGF0IGRvIG5vdCBtYXRjaCB0aGUgcXVlcnkgZXhwcmVzc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3JcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge3t0ZXN0OiBGdW5jdGlvbn19XHJcbiAgICAgKi9cclxuICAgICRub3Q6IGZ1bmN0aW9uIChzZWxlY3RvciwgdmFsdWUpIHtcclxuICAgICAgdmFyIGNyaXRlcmlhID0ge307XHJcbiAgICAgIGNyaXRlcmlhW3NlbGVjdG9yXSA9IG5vcm1hbGl6ZSh2YWx1ZSk7XHJcbiAgICAgIHZhciBxdWVyeSA9IG5ldyBNaW5nby5RdWVyeShjcml0ZXJpYSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgcmV0dXJuICFxdWVyeS50ZXN0KG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hdGNoZXMgZG9jdW1lbnRzIHRoYXQgc2F0aXNmeSBhIEphdmFTY3JpcHQgZXhwcmVzc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3JcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge3t0ZXN0OiB0ZXN0fX1cclxuICAgICAqL1xyXG4gICAgJHdoZXJlOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHZhbHVlKSB7XHJcbiAgICAgIGlmICghXy5pc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsgdmFsdWUgKyBcIjtcIik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWUuY2FsbChvYmopID09PSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgfTtcclxuXHJcbiAgdmFyIHNpbXBsZU9wZXJhdG9ycyA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGF0IHR3byB2YWx1ZXMgYXJlIGVxdWFsLiBQc2V1ZG8gb3BlcmF0b3IgaW50cm9kdWNlZCBmb3IgY29udmVuaWVuY2UgYW5kIGNvbnNpc3RlbmN5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFcclxuICAgICAqIEBwYXJhbSBiXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgJGVxOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICBhID0gXy5pc0FycmF5KGEpID8gYSA6IFthXTtcclxuICAgICAgYSA9IF8uZmluZChhLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uaXNFcXVhbCh2YWwsIGIpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGEgIT09IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRjaGVzIGFsbCB2YWx1ZXMgdGhhdCBhcmUgbm90IGVxdWFsIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgICRuZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLiRlcShhLCBiKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRjaGVzIGFueSBvZiB0aGUgdmFsdWVzIHRoYXQgZXhpc3QgaW4gYW4gYXJyYXkgc3BlY2lmaWVkIGluIHRoZSBxdWVyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYVxyXG4gICAgICogQHBhcmFtIGJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICAkaW46IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIGEgPSBfLmlzQXJyYXkoYSkgPyBhIDogW2FdO1xyXG4gICAgICByZXR1cm4gXy5pbnRlcnNlY3Rpb24oYSwgYikubGVuZ3RoID4gMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRjaGVzIHZhbHVlcyB0aGF0IGRvIG5vdCBleGlzdCBpbiBhbiBhcnJheSBzcGVjaWZpZWQgdG8gdGhlIHF1ZXJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgJG5pbjogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgcmV0dXJuIF8uaXNVbmRlZmluZWQoYSkgfHwgIXRoaXMuJGluKGEsIGIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hdGNoZXMgdmFsdWVzIHRoYXQgYXJlIGxlc3MgdGhhbiB0aGUgdmFsdWUgc3BlY2lmaWVkIGluIHRoZSBxdWVyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYVxyXG4gICAgICogQHBhcmFtIGJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICAkbHQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIGEgPSBfLmlzQXJyYXkoYSkgPyBhIDogW2FdO1xyXG4gICAgICBhID0gXy5maW5kKGEsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICByZXR1cm4gdmFsIDwgYlxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGEgIT09IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRjaGVzIHZhbHVlcyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIHNwZWNpZmllZCBpbiB0aGUgcXVlcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFcclxuICAgICAqIEBwYXJhbSBiXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgJGx0ZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgYSA9IF8uaXNBcnJheShhKSA/IGEgOiBbYV07XHJcbiAgICAgIGEgPSBfLmZpbmQoYSwgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIHJldHVybiB2YWwgPD0gYlxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGEgIT09IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRjaGVzIHZhbHVlcyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIHNwZWNpZmllZCBpbiB0aGUgcXVlcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFcclxuICAgICAqIEBwYXJhbSBiXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgJGd0OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICBhID0gXy5pc0FycmF5KGEpID8gYSA6IFthXTtcclxuICAgICAgYSA9IF8uZmluZChhLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCA+IGJcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBhICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF0Y2hlcyB2YWx1ZXMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgICRndGU6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIGEgPSBfLmlzQXJyYXkoYSkgPyBhIDogW2FdO1xyXG4gICAgICBhID0gXy5maW5kKGEsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICByZXR1cm4gdmFsID49IGJcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBhICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBtb2R1bG8gb3BlcmF0aW9uIG9uIHRoZSB2YWx1ZSBvZiBhIGZpZWxkIGFuZCBzZWxlY3RzIGRvY3VtZW50cyB3aXRoIGEgc3BlY2lmaWVkIHJlc3VsdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYVxyXG4gICAgICogQHBhcmFtIGJcclxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW58Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgJG1vZDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgYSA9IF8uaXNBcnJheShhKSA/IGEgOiBbYV07XHJcbiAgICAgIGEgPSBfLmZpbmQoYSwgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIHJldHVybiBfLmlzTnVtYmVyKHZhbCkgJiYgXy5pc0FycmF5KGIpICYmIGIubGVuZ3RoID09PSAyICYmICh2YWwgJSBiWzBdKSA9PT0gYlsxXTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBhICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0cyBkb2N1bWVudHMgd2hlcmUgdmFsdWVzIG1hdGNoIGEgc3BlY2lmaWVkIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYVxyXG4gICAgICogQHBhcmFtIGJcclxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XHJcbiAgICAgKi9cclxuICAgICRyZWdleDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgYSA9IF8uaXNBcnJheShhKSA/IGEgOiBbYV07XHJcbiAgICAgIGEgPSBfLmZpbmQoYSwgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIHJldHVybiBfLmlzU3RyaW5nKHZhbCkgJiYgXy5pc1JlZ0V4cChiKSAmJiAoISF2YWwubWF0Y2goYikpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGEgIT09IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRjaGVzIGRvY3VtZW50cyB0aGF0IGhhdmUgdGhlIHNwZWNpZmllZCBmaWVsZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYVxyXG4gICAgICogQHBhcmFtIGJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufCp8Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgJGV4aXN0czogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgcmV0dXJuIChiID09PSBmYWxzZSAmJiBfLmlzVW5kZWZpbmVkKGEpKSB8fCAoYiA9PT0gdHJ1ZSAmJiAhXy5pc1VuZGVmaW5lZChhKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF0Y2hlcyBhcnJheXMgdGhhdCBjb250YWluIGFsbCBlbGVtZW50cyBzcGVjaWZpZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMgYm9vbGVhblxyXG4gICAgICovXHJcbiAgICAkYWxsOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XHJcbiAgICAgIGlmIChfLmlzQXJyYXkoYSkgJiYgXy5pc0FycmF5KGIpKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoXy5pc09iamVjdChiW2ldKSAmJiBfLmNvbnRhaW5zKF8ua2V5cyhiW2ldKSwgXCIkZWxlbU1hdGNoXCIpKSB7XHJcbiAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaGVkIHx8IHNlbGYuJGVsZW1NYXRjaChhLCBiW2ldLiRlbGVtTWF0Y2gpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gb3JkZXIgb2YgYXJndW1lbnRzIG1hdHRlci4gdW5kZXJzY29yZSBtYWludGFpbnMgb3JkZXIgYWZ0ZXIgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgIHJldHVybiBfLmludGVyc2VjdGlvbihiLCBhKS5sZW5ndGggPT09IGIubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWF0Y2hlZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3RzIGRvY3VtZW50cyBpZiB0aGUgYXJyYXkgZmllbGQgaXMgYSBzcGVjaWZpZWQgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYVxyXG4gICAgICogQHBhcmFtIGJcclxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XHJcbiAgICAgKi9cclxuICAgICRzaXplOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICByZXR1cm4gXy5pc0FycmF5KGEpICYmIF8uaXNOdW1iZXIoYikgJiYgKGEubGVuZ3RoID09PSBiKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3RzIGRvY3VtZW50cyBpZiBlbGVtZW50IGluIHRoZSBhcnJheSBmaWVsZCBtYXRjaGVzIGFsbCB0aGUgc3BlY2lmaWVkICRlbGVtTWF0Y2ggY29uZGl0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICovXHJcbiAgICAkZWxlbU1hdGNoOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICBpZiAoXy5pc0FycmF5KGEpICYmICFfLmlzRW1wdHkoYSkpIHtcclxuICAgICAgICB2YXIgcXVlcnkgPSBuZXcgTWluZ28uUXVlcnkoYik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAocXVlcnkudGVzdChhW2ldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdHMgZG9jdW1lbnRzIGlmIGEgZmllbGQgaXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgICR0eXBlOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICBzd2l0Y2ggKGIpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICByZXR1cm4gXy5pc051bWVyaWMoYSkgJiYgKGEgKyBcIlwiKS5pbmRleE9mKFwiLlwiKSAhPT0gLTE7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgIHJldHVybiBfLmlzU3RyaW5nKGEpO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIHJldHVybiBfLmlzT2JqZWN0KGEpO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIHJldHVybiBfLmlzQXJyYXkoYSk7XHJcbiAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgcmV0dXJuIF8uaXNCb29sZWFuKGEpO1xyXG4gICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgIHJldHVybiBfLmlzRGF0ZShhKTtcclxuICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgcmV0dXJuIF8uaXNOdWxsKGEpO1xyXG4gICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgICByZXR1cm4gXy5pc1JlZ0V4cChhKTtcclxuICAgICAgICBjYXNlIDE2OlxyXG4gICAgICAgICAgcmV0dXJuIF8uaXNOdW1lcmljKGEpICYmIGEgPD0gMjE0NzQ4MzY0NyAmJiAoYSArIFwiXCIpLmluZGV4T2YoXCIuXCIpID09PSAtMTtcclxuICAgICAgICBjYXNlIDE4OlxyXG4gICAgICAgICAgcmV0dXJuIF8uaXNOdW1lcmljKGEpICYmIGEgPiAyMTQ3NDgzNjQ3ICYmIGEgPD0gOTIyMzM3MjAzNjg1NDc3NTgwNyAmJiAoYSArIFwiXCIpLmluZGV4T2YoXCIuXCIpID09PSAtMTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIH07XHJcblxyXG4gIHZhciBwcm9qZWN0aW9uT3BlcmF0b3JzID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvamVjdHMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYW4gYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeSBjb25kaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGZpZWxkXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkOiBmdW5jdGlvbiAob2JqLCBleHByLCBmaWVsZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCIkIG5vdCBpbXBsZW1lbnRlZFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9qZWN0cyBvbmx5IHRoZSBmaXJzdCBlbGVtZW50IGZyb20gYW4gYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgJGVsZW1NYXRjaCBjb25kaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGZpZWxkXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgICRlbGVtTWF0Y2g6IGZ1bmN0aW9uIChvYmosIGV4cHIsIGZpZWxkKSB7XHJcbiAgICAgIHZhciBhcnJheSA9IHJlc29sdmUob2JqLCBmaWVsZCk7XHJcbiAgICAgIHZhciBxdWVyeSA9IG5ldyBNaW5nby5RdWVyeShleHByKTtcclxuXHJcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGFycmF5KSB8fCAhXy5pc0FycmF5KGFycmF5KSkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocXVlcnkudGVzdChhcnJheVtpXSkpIHtcclxuICAgICAgICAgIHJldHVybiBbYXJyYXlbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW1pdHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBwcm9qZWN0ZWQgZnJvbSBhbiBhcnJheS4gU3VwcG9ydHMgc2tpcCBhbmQgbGltaXQgc2xpY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBmaWVsZFxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJHNsaWNlOiBmdW5jdGlvbiAob2JqLCBleHByLCBmaWVsZCkge1xyXG4gICAgICB2YXIgYXJyYXkgPSByZXNvbHZlKG9iaiwgZmllbGQpO1xyXG5cclxuICAgICAgaWYgKCFfLmlzQXJyYXkoYXJyYXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghXy5pc0FycmF5KGV4cHIpKSB7XHJcbiAgICAgICAgaWYgKCFfLmlzTnVtYmVyKGV4cHIpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHR5cGUgZm9yICRzbGljZSBvcGVyYXRvclwiKTtcclxuICAgICAgfVxyXG4gICAgICAgIGV4cHIgPSBleHByIDwgMCA/IFtleHByXSA6IFswLCBleHByXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBNb25nb0RCICRzbGljZSB3b3JrcyBhIGJpdCBkaWZmZXJlbnRseSBmcm9tIEFycmF5LnNsaWNlXHJcbiAgICAgICAgLy8gVXNlcyBzaW5nbGUgYXJndW1lbnQgZm9yICdsaW1pdCcgYW5kIGFycmF5IGFyZ3VtZW50IFtza2lwLCBsaW1pdF1cclxuICAgICAgICB2YXIgc2tpcCA9IChleHByWzBdIDwgMCkgPyBhcnJheS5sZW5ndGggKyBleHByWzBdIDogZXhwcjtcclxuICAgICAgICB2YXIgbGltaXQgPSBza2lwICsgZXhwclsxXTtcclxuICAgICAgICBleHByID0gW3NraXAsIGxpbWl0XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheSwgZXhwcik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGdyb3VwT3BlcmF0b3JzID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIHVuaXF1ZSB2YWx1ZXMgZm9yIHRoZSBzZWxlY3RlZCBmaWVsZCBhbW9uZyBmb3IgZWFjaCBkb2N1bWVudCBpbiB0aGF0IGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgICRhZGRUb1NldDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGV4cHIpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IF8ubWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gXy51bmlxKHJlc3VsdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB0aGUgdmFsdWVzIGluIGEgZ3JvdXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgJHN1bTogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGV4cHIpIHtcclxuICAgICAgaWYgKF8uaXNOdW1iZXIoZXhwcikpIHtcclxuICAgICAgICAvLyB0YWtlIGEgc2hvcnQgY3V0IGlmIGV4cHIgaXMgbnVtYmVyIGxpdGVyYWxcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5sZW5ndGggKiBleHByO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfLnJlZHVjZShjb2xsZWN0aW9uLCBmdW5jdGlvbiAoYWNjLCBvYmopIHtcclxuICAgICAgICAvLyBwYXNzIGVtcHR5IGZpZWxkIHRvIGF2b2lkIG5hbWluZyBjb25mbGljdHMgd2l0aCBmaWVsZHMgb24gZG9jdW1lbnRzXHJcbiAgICAgICAgcmV0dXJuIGFjYyArIGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICB9LCAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBoaWdoZXN0IHZhbHVlIGluIGEgZ3JvdXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgJG1heDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGV4cHIpIHtcclxuICAgICAgdmFyIG9iaiA9IF8ubWF4KGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbG93ZXN0IHZhbHVlIGluIGEgZ3JvdXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgJG1pbjogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGV4cHIpIHtcclxuICAgICAgdmFyIG9iaiA9IF8ubWluKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhdmVyYWdlIG9mIGFsbCB0aGUgdmFsdWVzIGluIGEgZ3JvdXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICAkYXZnOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgZXhwcikge1xyXG4gICAgICByZXR1cm4gdGhpcy4kc3VtKGNvbGxlY3Rpb24sIGV4cHIpIC8gKGNvbGxlY3Rpb24ubGVuZ3RoIHx8IDEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHZhbHVlcyBmb3IgdGhlIHNlbGVjdGVkIGZpZWxkIGFtb25nIGZvciBlYWNoIGRvY3VtZW50IGluIHRoYXQgZ3JvdXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8Kn1cclxuICAgICAqL1xyXG4gICAgJHB1c2g6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBleHByKSB7XHJcbiAgICAgIHJldHVybiBfLm1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiBhIGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgICRmaXJzdDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGV4cHIpIHtcclxuICAgICAgcmV0dXJuIChjb2xsZWN0aW9uLmxlbmd0aCA+IDApID8gY29tcHV0ZVZhbHVlKGNvbGxlY3Rpb25bMF0sIGV4cHIpIDogdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgdmFsdWUgaW4gYSBncm91cC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICAkbGFzdDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGV4cHIpIHtcclxuICAgICAgcmV0dXJuIChjb2xsZWN0aW9uLmxlbmd0aCA+IDApID8gY29tcHV0ZVZhbHVlKGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSwgZXhwcikgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vLy8vLy8vLy8vIENvbW1vbiBBZ2dyZWdhdGlvbiBPcGVyYXRvcnMgLy8vLy8vLy8vLy9cclxuXHJcbiAgdmFyIGFyaXRobWV0aWNPcGVyYXRvcnMgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgICRhZGQ6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIF8ucmVkdWNlKGFyZ3MsIGZ1bmN0aW9uIChtZW1vLCBudW0pIHtcclxuICAgICAgICByZXR1cm4gbWVtbyArIG51bTtcclxuICAgICAgfSwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0d28gbnVtYmVycyBvciB0d28gZGF0ZXMgYW5kIHN1YnRyYWN0cyB0aGUgc2Vjb25kIHZhbHVlIGZyb20gdGhlIGZpcnN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICAkc3VidHJhY3Q6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIGFyZ3NbMF0gLSBhcmdzWzFdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIHR3byBudW1iZXJzIGFuZCBkaXZpZGVzIHRoZSBmaXJzdCBudW1iZXIgYnkgdGhlIHNlY29uZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgJGRpdmlkZTogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gYXJnc1swXSAvIGFyZ3NbMV07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIHByb2R1Y3Qgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgJG11bHRpcGx5OiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLnJlZHVjZShhcmdzLCBmdW5jdGlvbiAobWVtbywgbnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lbW8gKiBudW07XHJcbiAgICAgIH0sIDEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIHR3byBudW1iZXJzIGFuZCBjYWxjdWxhdGVzIHRoZSBtb2R1bG8gb2YgdGhlIGZpcnN0IG51bWJlciBkaXZpZGVkIGJ5IHRoZSBzZWNvbmQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgICRtb2Q6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIGFyZ3NbMF0gJSBhcmdzWzFdO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBzdHJpbmdPcGVyYXRvcnMgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25jYXRlbmF0ZXMgdHdvIHN0cmluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8Kn1cclxuICAgICAqL1xyXG4gICAgJGNvbmNhdDogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICAvLyBkb2VzIG5vdCBhbGxvdyBjb25jYXRlbmF0aW9uIHdpdGggbnVsbHNcclxuICAgICAgaWYgKF8uY29udGFpbnMoYXJncywgbnVsbCkgfHwgXy5jb250YWlucyhhcmdzLCB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFyZ3Muam9pbihcIlwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0d28gc3RyaW5ncyBhbmQgcmV0dXJucyBhbiBpbnRlZ2VyIHRoYXQgcmVmbGVjdHMgdGhlIGNvbXBhcmlzb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgICRzdHJjYXNlY21wOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIGFyZ3NbMF0gPSBfLmlzRW1wdHkoYXJnc1swXSkgPyBcIlwiIDogYXJnc1swXS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICBhcmdzWzFdID0gXy5pc0VtcHR5KGFyZ3NbMV0pID8gXCJcIiA6IGFyZ3NbMV0udG9VcHBlckNhc2UoKTtcclxuICAgICAgaWYgKGFyZ3NbMF0gPiBhcmdzWzFdKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIChhcmdzWzBdIDwgYXJnc1sxXSkgPyAtMSA6IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHN1YnN0cmluZyBvZiBhIHN0cmluZywgc3RhcnRpbmcgYXQgYSBzcGVjaWZpZWQgaW5kZXggcG9zaXRpb24gYW5kIGluY2x1ZGluZyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxyXG4gICAgICogVGhlIGluZGV4IGlzIHplcm8tYmFzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgICRzdWJzdHI6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgaWYgKF8uaXNTdHJpbmcoYXJnc1swXSkpIHtcclxuICAgICAgICBpZiAoYXJnc1sxXSA8IDApIHtcclxuICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXJnc1syXSA8IDApIHtcclxuICAgICAgICAgIHJldHVybiBhcmdzWzBdLnN1YnN0cihhcmdzWzFdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGFyZ3NbMF0uc3Vic3RyKGFyZ3NbMV0sIGFyZ3NbMl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gXCJcIjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBsb3dlcmNhc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgICR0b0xvd2VyOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5pc0VtcHR5KHZhbHVlKSA/IFwiXCIgOiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIHVwcGVyY2FzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgJHRvVXBwZXI6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIHZhbHVlID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLmlzRW1wdHkodmFsdWUpID8gXCJcIiA6IHZhbHVlLnRvVXBwZXJDYXNlKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGRhdGVPcGVyYXRvcnMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRheSBvZiB0aGUgeWVhciBmb3IgYSBkYXRlIGFzIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgMzY2IChsZWFwIHllYXIpLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJGRheU9mWWVhcjogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgZCA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICBpZiAoXy5pc0RhdGUodmFsdWUpKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAwKTtcclxuICAgICAgICB2YXIgZGlmZiA9IGQgLSBzdGFydDtcclxuICAgICAgICB2YXIgb25lRGF5ID0gMTAwMCAqIDYwICogNjAgKiAyNDtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChkaWZmIC8gb25lRGF5KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRheSBvZiB0aGUgbW9udGggZm9yIGEgZGF0ZSBhcyBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDMxLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJGRheU9mTW9udGg6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGQgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIF8uaXNEYXRlKGQpID8gZC5nZXREYXRlKCkgOiB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGF5IG9mIHRoZSB3ZWVrIGZvciBhIGRhdGUgYXMgYSBudW1iZXIgYmV0d2VlbiAxIChTdW5kYXkpIGFuZCA3IChTYXR1cmRheSkuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkZGF5T2ZXZWVrOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBkID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLmlzRGF0ZShkKSA/IGQuZ2V0RGF5KCkgKyAxIDogdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHllYXIgZm9yIGEgZGF0ZSBhcyBhIG51bWJlciAoZS5nLiAyMDE0KS5cclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICR5ZWFyOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBkID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLmlzRGF0ZShkKSA/IGQuZ2V0RnVsbFllYXIoKSArIDEgOiB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbW9udGggZm9yIGEgZGF0ZSBhcyBhIG51bWJlciBiZXR3ZWVuIDEgKEphbnVhcnkpIGFuZCAxMiAoRGVjZW1iZXIpLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJG1vbnRoOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBkID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLmlzRGF0ZShkKSA/IGQuZ2V0TW9udGgoKSArIDEgOiB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgd2VlayBudW1iZXIgZm9yIGEgZGF0ZSBhcyBhIG51bWJlciBiZXR3ZWVuIDBcclxuICAgICAqICh0aGUgcGFydGlhbCB3ZWVrIHRoYXQgcHJlY2VkZXMgdGhlIGZpcnN0IFN1bmRheSBvZiB0aGUgeWVhcikgYW5kIDUzIChsZWFwIHllYXIpLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJHdlZWs6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGQgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgLy8gVE9ET1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgSW1wbGVtZW50ZWRcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaG91ciBmb3IgYSBkYXRlIGFzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMjMuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkaG91cjogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgZCA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5pc0RhdGUoZCkgPyBkLmdldEhvdXJzKCkgOiB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWludXRlIGZvciBhIGRhdGUgYXMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OS5cclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICRtaW51dGU6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGQgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIF8uaXNEYXRlKGQpID8gZC5nZXRNaW51dGVzKCkgOiB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2Vjb25kcyBmb3IgYSBkYXRlIGFzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNjAgKGxlYXAgc2Vjb25kcykuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkc2Vjb25kOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBkID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLmlzRGF0ZShkKSA/IGQuZ2V0U2Vjb25kcygpIDogdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1pbGxpc2Vjb25kcyBvZiBhIGRhdGUgYXMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTkuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkbWlsbGlzZWNvbmQ6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGQgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIF8uaXNEYXRlKGQpID8gZC5nZXRNaWxsaXNlY29uZHMoKSA6IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRlIGFzIGEgZm9ybWF0dGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICRkYXRlVG9TdHJpbmc6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGZtdCA9IGV4cHJbJ2Zvcm1hdCddO1xyXG4gICAgICB2YXIgZGF0ZSA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHJbJ2RhdGUnXSk7XHJcbiAgICAgIC8vIFRPRE86IHVzZSBweXRob24tc3R5bGUgZGF0ZSBmb3JtYXR0aW5nXHJcbiAgICAgIC8qXHJcbiAgICAgICAlWVx0WWVhciAoNCBkaWdpdHMsIHplcm8gcGFkZGVkKVx0MDAwMC05OTk5XHJcbiAgICAgICAlbVx0TW9udGggKDIgZGlnaXRzLCB6ZXJvIHBhZGRlZClcdDAxLTEyXHJcbiAgICAgICAlZFx0RGF5IG9mIE1vbnRoICgyIGRpZ2l0cywgemVybyBwYWRkZWQpXHQwMS0zMVxyXG4gICAgICAgJUhcdEhvdXIgKDIgZGlnaXRzLCB6ZXJvIHBhZGRlZCwgMjQtaG91ciBjbG9jaylcdDAwLTIzXHJcbiAgICAgICAlTVx0TWludXRlICgyIGRpZ2l0cywgemVybyBwYWRkZWQpXHQwMC01OVxyXG4gICAgICAgJVNcdFNlY29uZCAoMiBkaWdpdHMsIHplcm8gcGFkZGVkKVx0MDAtNjBcclxuICAgICAgICVMXHRNaWxsaXNlY29uZCAoMyBkaWdpdHMsIHplcm8gcGFkZGVkKVx0MDAwLTk5OVxyXG4gICAgICAgJWpcdERheSBvZiB5ZWFyICgzIGRpZ2l0cywgemVybyBwYWRkZWQpXHQwMDEtMzY2XHJcbiAgICAgICAld1x0RGF5IG9mIHdlZWsgKDEtU3VuZGF5LCA3LVNhdHVyZGF5KVx0MS03XHJcbiAgICAgICAlVVx0V2VlayBvZiB5ZWFyICgyIGRpZ2l0cywgemVybyBwYWRkZWQpXHQwMC01M1xyXG4gICAgICAgJSVcdFBlcmNlbnQgQ2hhcmFjdGVyIGFzIGEgTGl0ZXJhbFx0JVxyXG4gICAgICAgKi9cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IEltcGxlbWVudGVkXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBzZXRPcGVyYXRvcnMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0d28gc2V0cyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJHNldEVxdWFsczogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICB2YXIgZmlyc3QgPSBfLnVuaXEoYXJnc1swXSk7XHJcbiAgICAgIHZhciBzZWNvbmQgPSBfLnVuaXEoYXJnc1sxXSk7XHJcbiAgICAgIGlmIChmaXJzdC5sZW5ndGggIT09IHNlY29uZC5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIF8uZGlmZmVyZW5jZShmaXJzdCwgc2Vjb25kKS5sZW5ndGggPT0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21tb24gZWxlbWVudHMgb2YgdGhlIGlucHV0IHNldHMuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkc2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLmludGVyc2VjdGlvbihhcmdzWzBdLCBhcmdzWzFdKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGVsZW1lbnRzIG9mIGEgc2V0IHRoYXQgZG8gbm90IGFwcGVhciBpbiBhIHNlY29uZCBzZXQuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkc2V0RGlmZmVyZW5jZTogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFyZ3NbMF0sIGFyZ3NbMV0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzZXQgdGhhdCBob2xkcyBhbGwgZWxlbWVudHMgb2YgdGhlIGlucHV0IHNldHMuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkc2V0VW5pb246IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIF8udW5pb24oYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCBlbGVtZW50cyBvZiBhIHNldCBhcHBlYXIgaW4gYSBzZWNvbmQgc2V0LlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJHNldElzU3Vic2V0OiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLmludGVyc2VjdGlvbihhcmdzWzBdLCBhcmdzWzFdKS5sZW5ndGggPT09IGFyZ3NbMF0ubGVuZ3RoO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbnkgZWxlbWVudHMgb2YgYSBzZXQgZXZhbHVhdGUgdG8gdHJ1ZSwgYW5kIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICRhbnlFbGVtZW50VHJ1ZTogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICAvLyBtb25nb2RiIG5lc3RzIHRoZSBhcnJheSBleHByZXNzaW9uIGluIGFub3RoZXJcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKVswXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCEhYXJnc1tpXSlcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIGVsZW1lbnRzIG9mIGEgc2V0IGV2YWx1YXRlIHRvIHRydWUsIGFuZCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkYWxsRWxlbWVudHNUcnVlOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIC8vIG1vbmdvZGIgbmVzdHMgdGhlIGFycmF5IGV4cHJlc3Npb24gaW4gYW5vdGhlclxyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpWzBdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoIWFyZ3NbaV0pXHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNvbmRpdGlvbmFsT3BlcmF0b3JzID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB0ZXJuYXJ5IG9wZXJhdG9yIHRoYXQgZXZhbHVhdGVzIG9uZSBleHByZXNzaW9uLFxyXG4gICAgICogYW5kIGRlcGVuZGluZyBvbiB0aGUgcmVzdWx0IHJldHVybnMgdGhlIHZhbHVlIG9mIG9uZSBmb2xsb3dpbmcgZXhwcmVzc2lvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJGNvbmQ6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGlmRXhwciwgdGhlbkV4cHIsIGVsc2VFeHByO1xyXG4gICAgICBpZiAoXy5pc0FycmF5KGV4cHIpKSB7XHJcbiAgICAgICAgaWYgKGV4cHIubGVuZ3RoICE9IDMpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciAkY29uZCBvcGVyYXRvclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWZFeHByID0gZXhwclswXTtcclxuICAgICAgICB0aGVuRXhwciA9IGV4cHJbMV07XHJcbiAgICAgICAgZWxzZUV4cHIgPSBleHByWzJdO1xyXG4gICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZXhwcikpIHtcclxuICAgICAgICBpZkV4cHIgPSBleHByWydpZiddO1xyXG4gICAgICAgIHRoZW5FeHByID0gZXhwclsndGhlbiddO1xyXG4gICAgICAgIGVsc2VFeHByID0gZXhwclsnZWxzZSddO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjb25kaXRpb24gPSBjb21wdXRlVmFsdWUob2JqLCBpZkV4cHIpO1xyXG4gICAgICByZXR1cm4gY29uZGl0aW9uID8gY29tcHV0ZVZhbHVlKG9iaiwgdGhlbkV4cHIpIDogY29tcHV0ZVZhbHVlKG9iaiwgZWxzZUV4cHIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV2YWx1YXRlcyBhbiBleHByZXNzaW9uIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBleHByZXNzaW9uIGlmIGl0IGV2YWx1YXRlcyB0byBhIG5vbi1udWxsIHZhbHVlLlxyXG4gICAgICogT3RoZXJ3aXNlLCAkaWZOdWxsIHJldHVybnMgdGhlIHNlY29uZCBleHByZXNzaW9uJ3MgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICAkaWZOdWxsOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIGlmICghXy5pc0FycmF5KGV4cHIpIHx8IGV4cHIubGVuZ3RoICE9IDIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgJGlmTnVsbCBvcGVyYXRvclwiKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gKGFyZ3NbMF0gPT09IG51bGwgfHwgYXJnc1swXSA9PT0gdW5kZWZpbmVkKSA/IGFyZ3NbMV0gOiBhcmdzWzBdO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBjb21wYXJpc29uT3BlcmF0b3JzID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGNvbXBhcmlzb24gYXMgYW4gaW50ZWdlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgJGNtcDogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICBpZiAoYXJnc1swXSA+IGFyZ3NbMV0pIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gKGFyZ3NbMF0gPCBhcmdzWzFdKSA/IC0xIDogMDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBjb21iaW5lIGFnZ3JlZ2F0ZSBvcGVyYXRvcnNcclxuICB2YXIgYWdncmVnYXRlT3BlcmF0b3JzID0gXy5leHRlbmQoXHJcbiAgICAgIHt9LFxyXG4gICAgICBhcml0aG1ldGljT3BlcmF0b3JzLFxyXG4gICAgICBjb21wYXJpc29uT3BlcmF0b3JzLFxyXG4gICAgICBjb25kaXRpb25hbE9wZXJhdG9ycyxcclxuICAgICAgZGF0ZU9wZXJhdG9ycyxcclxuICAgICAgc2V0T3BlcmF0b3JzLFxyXG4gICAgICBzdHJpbmdPcGVyYXRvcnNcclxuICAgICk7XHJcblxyXG4gIC8vIG1peGluIGNvbXBhcmlzb24gb3BlcmF0b3JzXHJcbiAgXy5lYWNoKFtcIiRlcVwiLCBcIiRuZVwiLCBcIiRndFwiLCBcIiRndGVcIiwgXCIkbHRcIiwgXCIkbHRlXCJdLCBmdW5jdGlvbiAob3ApIHtcclxuICAgIGFnZ3JlZ2F0ZU9wZXJhdG9yc1tvcF0gPSBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBzaW1wbGVPcGVyYXRvcnNbb3BdKGFyZ3NbMF0sIGFyZ3NbMV0pO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgdmFyIE9wcyA9IHtcclxuICAgIHNpbXBsZU9wZXJhdG9yczogXy5rZXlzKHNpbXBsZU9wZXJhdG9ycyksXHJcbiAgICBjb21wb3VuZE9wZXJhdG9yczogXy5rZXlzKGNvbXBvdW5kT3BlcmF0b3JzKSxcclxuICAgIGFnZ3JlZ2F0ZU9wZXJhdG9yczogXy5rZXlzKGFnZ3JlZ2F0ZU9wZXJhdG9ycyksXHJcbiAgICBncm91cE9wZXJhdG9yczogXy5rZXlzKGdyb3VwT3BlcmF0b3JzKSxcclxuICAgIHBpcGVsaW5lT3BlcmF0b3JzOiBfLmtleXMocGlwZWxpbmVPcGVyYXRvcnMpLFxyXG4gICAgcHJvamVjdGlvbk9wZXJhdG9yczogXy5rZXlzKHByb2plY3Rpb25PcGVyYXRvcnMpXHJcbiAgfTtcclxuICBPcHMucXVlcnlPcGVyYXRvcnMgPSBfLnVuaW9uKE9wcy5zaW1wbGVPcGVyYXRvcnMsIE9wcy5jb21wb3VuZE9wZXJhdG9ycyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIGEgJGdyb3VwIG9wZXJhdGlvbiBvdmVyIGEgY29sbGVjdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgKiBAcGFyYW0gZmllbGQgdGhlIG5hbWUgb2YgdGhlIGFnZ3JlZ2F0ZSBvcGVyYXRvciBvciBmaWVsZFxyXG4gICAqIEBwYXJhbSBleHByIHRoZSBleHByZXNzaW9uIG9mIHRoZSBhZ2dyZWdhdGUgb3BlcmF0b3IgZm9yIHRoZSBmaWVsZFxyXG4gICAqIEByZXR1cm5zIHsqfVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFjY3VtdWxhdGUoY29sbGVjdGlvbiwgZmllbGQsIGV4cHIpIHtcclxuICAgIGlmIChfLmNvbnRhaW5zKE9wcy5ncm91cE9wZXJhdG9ycywgZmllbGQpKSB7XHJcbiAgICAgIHJldHVybiBncm91cE9wZXJhdG9yc1tmaWVsZF0oY29sbGVjdGlvbiwgZXhwcik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKF8uaXNPYmplY3QoZXhwcikpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXhwcikge1xyXG4gICAgICAgIGlmIChleHByLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgIHJlc3VsdFtrZXldID0gYWNjdW11bGF0ZShjb2xsZWN0aW9uLCBrZXksIGV4cHJba2V5XSk7XHJcbiAgICAgICAgICAvLyBtdXN0IHJ1biBPTkxZIG9uZSBncm91cCBvcGVyYXRvciBwZXIgZXhwcmVzc2lvblxyXG4gICAgICAgICAgLy8gaWYgc28sIHJldHVybiByZXN1bHQgb2YgdGhlIGNvbXB1dGVkIHZhbHVlXHJcbiAgICAgICAgICBpZiAoXy5jb250YWlucyhPcHMuZ3JvdXBPcGVyYXRvcnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0W2tleV07XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIGtleXMgaW4gZXhwcmVzc2lvbiB0aGlzIGlzIGJhZFxyXG4gICAgICAgICAgICBpZiAoXy5rZXlzKGV4cHIpLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkICRncm91cCBleHByZXNzaW9uICdcIiArIEpTT04uc3RyaW5naWZ5KGV4cHIpICsgXCInXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlcyB0aGUgYWN0dWFsIHZhbHVlIG9mIHRoZSBleHByZXNzaW9uIHVzaW5nIHRoZSBnaXZlbiBvYmplY3QgYXMgY29udGV4dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9iaiB0aGUgY3VycmVudCBvYmplY3QgZnJvbSB0aGUgY29sbGVjdGlvblxyXG4gICAqIEBwYXJhbSBleHByIHRoZSBleHByZXNzaW9uIGZvciB0aGUgZ2l2ZW4gZmllbGRcclxuICAgKiBAcGFyYW0gZmllbGQgdGhlIGZpZWxkIG5hbWUgKG1heSBhbHNvIGJlIGFuIGFnZ3JlZ2F0ZSBvcGVyYXRvcilcclxuICAgKiBAcmV0dXJucyB7Kn1cclxuICAgKi9cclxuICBmdW5jdGlvbiBjb21wdXRlVmFsdWUob2JqLCBleHByLCBmaWVsZCkge1xyXG5cclxuICAgIC8vIGlmIHRoZSBmaWVsZCBvZiB0aGUgb2JqZWN0IGlzIGEgdmFsaWQgb3BlcmF0b3JcclxuICAgIGlmIChfLmNvbnRhaW5zKE9wcy5hZ2dyZWdhdGVPcGVyYXRvcnMsIGZpZWxkKSkge1xyXG4gICAgICByZXR1cm4gYWdncmVnYXRlT3BlcmF0b3JzW2ZpZWxkXShvYmosIGV4cHIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIGV4cHIgaXMgYSB2YXJpYWJsZSBmb3IgYW4gb2JqZWN0IGZpZWxkXHJcbiAgICAvLyBmaWVsZCBub3QgdXNlZCBpbiB0aGlzIGNhc2VcclxuICAgIGlmIChfLmlzU3RyaW5nKGV4cHIpICYmIGV4cHIubGVuZ3RoID4gMCAmJiBleHByWzBdID09PSBcIiRcIikge1xyXG4gICAgICByZXR1cm4gcmVzb2x2ZShvYmosIGV4cHIuc2xpY2UoMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgaWYgKF8uaXNBcnJheShleHByKSkge1xyXG4gICAgICByZXN1bHQgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goY29tcHV0ZVZhbHVlKG9iaiwgZXhwcltpXSwgbnVsbCkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZXhwcikpIHtcclxuICAgICAgcmVzdWx0ID0ge307XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBleHByKSB7XHJcbiAgICAgICAgaWYgKGV4cHIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBjb21wdXRlVmFsdWUob2JqLCBleHByW2tleV0sIGtleSk7XHJcblxyXG4gICAgICAgICAgLy8gbXVzdCBydW4gT05MWSBvbmUgYWdncmVnYXRlIG9wZXJhdG9yIHBlciBleHByZXNzaW9uXHJcbiAgICAgICAgICAvLyBpZiBzbywgcmV0dXJuIHJlc3VsdCBvZiB0aGUgY29tcHV0ZWQgdmFsdWVcclxuICAgICAgICAgIGlmIChfLmNvbnRhaW5zKE9wcy5hZ2dyZWdhdGVPcGVyYXRvcnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0W2tleV07XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIGtleXMgaW4gZXhwcmVzc2lvbiB0aGlzIGlzIGJhZFxyXG4gICAgICAgICAgICBpZiAoXy5rZXlzKGV4cHIpLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFnZ3JlZ2F0aW9uIGV4cHJlc3Npb24gJ1wiICsgSlNPTi5zdHJpbmdpZnkoZXhwcikgKyBcIidcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBjaGVjayBhbmQgcmV0dXJuIHZhbHVlIGlmIGFscmVhZHkgaW4gYSByZXNvbHZlZCBzdGF0ZVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW1pdGl2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocHJpbWl0aXZlc1tpXShleHByKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGV4cHI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG59KHRoaXMpKTsiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgb3BzID0gcmVxdWlyZSgnLi9vcHMnKTtcbnZhciBlcWwgPSByZXF1aXJlKCdtb25nby1lcWwnKTtcbnZhciBkb3QgPSByZXF1aXJlKCdkb3QtY29tcG9uZW50Jyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWNvbXBvbmVudCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9uZ28tcXVlcnknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmaWx0ZXI7XG5leHBvcnRzLm9wcyA9IG9wcztcblxuLyoqXG4gKiBGaWx0ZXJzIGFuIGBvYmpgIGJ5IHRoZSBnaXZlbiBgcXVlcnlgIGZvciBzdWJkb2N1bWVudHMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fEJvb2xlYW59IGZhbHNlIGlmIG5vIG1hdGNoLCBvciBtYXRjaGVkIHN1YmRvY3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZmlsdGVyKG9iaiwgcXVlcnkpe1xuICBvYmogPSBvYmogfHwge307XG4gIHZhciByZXQgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gcXVlcnkpIHtcbiAgICBpZiAoIXF1ZXJ5Lmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xuXG4gICAgLy8gc2VhcmNoIHZhbHVlXG4gICAgdmFyIHZhbCA9IHF1ZXJ5W2tleV07XG5cbiAgICAvLyBzcGxpdCB0aGUga2V5IGludG8gcHJlZml4IGFuZCBzdWZmaXhcbiAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgIHZhciB0YXJnZXQgPSBvYmo7XG4gICAgdmFyIHByZWZpeCwgc2VhcmNoO1xuICAgIHZhciBtYXRjaGVzID0gW107XG5cbiAgICB3YWxrX2tleXM6XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRba2V5c1tpXV07XG5cbiAgICAgIHN3aXRjaCAodHlwZSh0YXJnZXQpKSB7XG4gICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAvLyBpZiBpdCdzIGFuIGFycmF5IHN1YmRvY3VtZW50IHNlYXJjaCB3ZSBzdG9wIGhlcmVcbiAgICAgICAgICBwcmVmaXggPSBrZXlzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICAgICAgc2VhcmNoID0ga2V5cy5zbGljZShpICsgMSkuam9pbignLicpO1xuXG4gICAgICAgICAgZGVidWcoJ3NlYXJjaGluZyBhcnJheSBcIiVzXCInLCBwcmVmaXgpO1xuXG4gICAgICAgICAgLy8gd2Ugc3BlY2lhbCBjYXNlIG9wZXJhdG9ycyB0aGF0IGRvbid0IHdhbGsgdGhlIGFycmF5XG4gICAgICAgICAgaWYgKHZhbC4kc2l6ZSAmJiAhc2VhcmNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUodmFsLCB0YXJnZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHdhbGsgc3ViZG9jc1xuICAgICAgICAgIHZhciBzdWJzZXQgPSByZXRbcHJlZml4XSB8fCB0YXJnZXQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc3Vic2V0Lmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHEgPSB7fTtcbiAgICAgICAgICAgICAgcVtzZWFyY2hdID0gdmFsO1xuICAgICAgICAgICAgICBpZiAoJ29iamVjdCcgPT0gdHlwZShzdWJzZXRbaWldKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHN1YmRvYyBzZWFyY2ggd2l0aCBxdWVyeSAlaicsIHEpO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIoc3Vic2V0W2lpXSwgcSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGlnbm9yZSB0aGUgcmV0IHZhbHVlIG9mIGZpbHRlclxuICAgICAgICAgICAgICAgICAgaWYgKCFyZXRbcHJlZml4XSB8fCAhfnJldFtwcmVmaXhdLmluZGV4T2Yoc3Vic2V0W2lpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHN1YnNldFtpaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVidWcoJ3BlcmZvcm1pbmcgc2ltcGxlIGFycmF5IGl0ZW0gc2VhcmNoJyk7XG4gICAgICAgICAgICAgIGlmIChjb21wYXJlKHZhbCwgc3Vic2V0W2lpXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJldFtwcmVmaXhdIHx8ICF+cmV0W3ByZWZpeF0uaW5kZXhPZihzdWJzZXRbaWldKSkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHN1YnNldFtpaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0W3ByZWZpeF0gPSByZXRbcHJlZml4XSB8fCBbXTtcbiAgICAgICAgICAgIHJldFtwcmVmaXhdLnB1c2guYXBwbHkocmV0W3ByZWZpeF0sIG1hdGNoZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHdlIGRvbid0IGNvbnRpbnVlIHRoZSBrZXkgc2VhcmNoXG4gICAgICAgICAgYnJlYWsgd2Fsa19rZXlzO1xuXG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmluZCB0aGUga2V5XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgaWYgKG51bGwgIT0ga2V5c1tpICsgMV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXBhcmUodmFsLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFjb21wYXJlKHZhbCwgdGFyZ2V0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIGdpdmVuIG1hdGNoZXIgd2l0aCB0aGUgZG9jdW1lbnQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbWF0Y2hlclxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBhcmUobWF0Y2hlciwgdmFsKXtcbiAgaWYgKCdvYmplY3QnICE9IHR5cGUobWF0Y2hlcikpIHtcbiAgICByZXR1cm4gZXFsKG1hdGNoZXIsIHZhbCk7XG4gIH1cblxuICB2YXIga2V5cyA9IG9iamVjdC5rZXlzKG1hdGNoZXIpO1xuICBpZiAoJyQnID09IGtleXNbMF1bMF0pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igc3ViLW9iamVjdCBtYXRjaGluZ1xuICAgICAgaWYgKCckZWxlbU1hdGNoJyA9PSBrZXlzW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZSAhPT0gZmlsdGVyKHZhbCwgbWF0Y2hlci4kZWxlbU1hdGNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghb3BzW2tleXNbaV1dKG1hdGNoZXJba2V5c1tpXV0sIHZhbCkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVxbChtYXRjaGVyLCB2YWwpO1xuICB9XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgbW9kcyA9IHJlcXVpcmUoJy4vbW9kcycpO1xudmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIgZG90ID0gcmVxdWlyZSgnZG90LWNvbXBvbmVudCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCdjb21wb25lbnQtdHlwZScpO1xudmFyIG9iamVjdCA9IHJlcXVpcmUoJ29iamVjdC1jb21wb25lbnQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vbmdvLXF1ZXJ5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gcXVlcnk7XG5cbi8qKlxuICogRXhwb3J0IGZpbHRlciBoZWxwZXIuXG4gKi9cblxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG5cbi8qKlxuICogRXhwb3J0IG1vZGlmaWVycy5cbiAqL1xuXG5leHBvcnRzLm1vZHMgPSBtb2RzO1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBxdWVyeS5cbiAqXG4gKiBPcHRpb25zOlxuICogIC0gYHN0cmljdGAgb25seSBtb2RpZnkgaWYgcXVlcnkgbWF0Y2hlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gYWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBxdWVyeSB0byBmaWx0ZXIgbW9kaWZpY2F0aW9ucyBieVxuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gcXVlcnkob2JqLCBxdWVyeSwgdXBkYXRlLCBvcHRzKXtcbiAgb2JqID0gb2JqIHx8IHt9O1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgcXVlcnkgPSBxdWVyeSB8fCB7fTtcbiAgdXBkYXRlID0gdXBkYXRlIHx8IHt9O1xuXG4gIC8vIHN0cmljdCBtb2RlXG4gIHZhciBzdHJpY3QgPSAhIW9wdHMuc3RyaWN0O1xuXG4gIHZhciBtYXRjaDtcbiAgdmFyIGxvZyA9IFtdO1xuXG4gIGlmIChvYmplY3QubGVuZ3RoKHF1ZXJ5KSkge1xuICAgIG1hdGNoID0gZmlsdGVyKG9iaiwgcXVlcnkpO1xuICB9XG5cbiAgaWYgKCFzdHJpY3QgfHwgZmFsc2UgIT09IG1hdGNoKSB7XG4gICAgdmFyIGtleXMgPSBvYmplY3Qua2V5cyh1cGRhdGUpO1xuICAgIHZhciB0cmFuc2FjdGlvbnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChtb2RzW2tleXNbaV1dKSB7XG4gICAgICAgIGRlYnVnKCdmb3VuZCBtb2RpZmllciBcIiVzXCInLCBrZXlzW2ldKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHVwZGF0ZVtrZXlzW2ldXSkge1xuICAgICAgICAgIHZhciBwb3MgPSBrZXkuaW5kZXhPZignLiQuJyk7XG5cbiAgICAgICAgICBpZiAofnBvcykge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGtleS5zdWJzdHIoMCwgcG9zKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBrZXkuc3Vic3RyKHBvcyArIDMpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hbcHJlZml4XSkge1xuICAgICAgICAgICAgICBkZWJ1ZygnZXhlY3V0aW5nIFwiJXNcIiAlcyBvbiBmaXJzdCBtYXRjaCB3aXRoaW4gXCIlc1wiJywga2V5LCBrZXlzW2ldLCBwcmVmaXgpO1xuICAgICAgICAgICAgICB2YXIgZm4gPSBtb2RzW2tleXNbaV1dKG1hdGNoW3ByZWZpeF1bMF0sIHN1ZmZpeCwgdXBkYXRlW2tleXNbaV1dW2tleV0pO1xuICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWNlIGEga2V5IG5hbWUgcmVwbGFjaW5nICQgd2l0aCB0aGUgYWN0dWFsIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyB1bm5lY2Vzc2FyaWx5IGV4cGVuc2l2ZVxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGRvdC5nZXQob2JqLCBwcmVmaXgpLmluZGV4T2YobWF0Y2hbcHJlZml4XVswXSk7XG4gICAgICAgICAgICAgICAgZm4ua2V5ID0gcHJlZml4ICsgJy4nICsgaW5kZXggKyAnLicgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgZm4ub3AgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKGZuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVidWcoJ2lnbm9yaW5nIFwiJXNcIiAlcyAtIG5vIG1hdGNoZXMgd2l0aGluIFwiJXNcIicsIGtleSwga2V5c1tpXSwgcHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZuID0gbW9kc1trZXlzW2ldXShvYmosIGtleSwgdXBkYXRlW2tleXNbaV1dW2tleV0pO1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgIGZuLmtleSA9IGtleTtcbiAgICAgICAgICAgICAgZm4ub3AgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMucHVzaChmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1Zygnc2tpcHBpbmcgdW5rbm93biBtb2RpZmllciBcIiVzXCInLCBrZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCkge1xuICAgICAgLy8gaWYgd2UgZ290IGhlcmUgZXJyb3IgZnJlZSB3ZSBwcm9jZXNzIGFsbCB0cmFuc2FjdGlvbnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmbiA9IHRyYW5zYWN0aW9uc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IGZuKCk7XG4gICAgICAgIGxvZy5wdXNoKHsgb3A6IGZuLm9wLCBrZXk6IGZuLmtleSwgdmFsdWU6IHZhbCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ25vIG1hdGNoZXMgZm9yIHF1ZXJ5ICVqJywgcXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIGxvZztcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlcWwgPSByZXF1aXJlKCdtb25nby1lcWwnKTtcbnZhciBkb3QgPSByZXF1aXJlKCdkb3QtY29tcG9uZW50Jyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1jb21wb25lbnQnKS5rZXlzO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9uZ28tcXVlcnknKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkc2V0YC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kc2V0ID0gZnVuY3Rpb24gJHNldChvYmosIHBhdGgsIHZhbCl7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoIWVxbChvYmpba2V5XSwgdmFsKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAobnVtZXJpYyhrZXkpKSB7XG4gICAgICAgIGlmICghZXFsKG9ialtrZXldLCB2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGFwcGVuZCB0byBhcnJheSB1c2luZyBzdHJpbmcgZmllbGQgbmFtZSBbJyArIGtleSArICddJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJyRzZXQgb25seSBzdXBwb3J0cyBvYmplY3Qgbm90ICcgKyB0eXBlKG9iaikpO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGFuIGAkdW5zZXRgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiR1bnNldCA9IGZ1bmN0aW9uICR1bnNldChvYmosIHBhdGgpe1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCk7XG5cbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAvLyByZW1pbmRlcjogYGRlbGV0ZSBhcnJbMV1gID09PSBgZGVsZXRlIGFyclsnMSddYCBbIV1cbiAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBmYWlsIHNpbGVudGx5XG4gICAgICAgIGRlYnVnKCdpZ25vcmluZyB1bnNldCBvZiBpbmV4aXN0aW5nIGtleScpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRyZW5hbWVgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRyZW5hbWUgPSBmdW5jdGlvbiAkcmVuYW1lKG9iaiwgcGF0aCwgbmV3S2V5KXtcbiAgLy8gdGFyZ2V0ID0gc291cmNlXG4gIGlmIChwYXRoID09IG5ld0tleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignJHJlbmFtZSBzb3VyY2UgbXVzdCBkaWZmZXIgZnJvbSB0YXJnZXQnKTtcbiAgfVxuXG4gIC8vIHRhcmdldCBpcyBwYXJlbnQgb2Ygc291cmNlXG4gIGlmICgwID09PSBwYXRoLmluZGV4T2YobmV3S2V5ICsgJy4nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignJHJlbmFtZSB0YXJnZXQgbWF5IG5vdCBiZSBhIHBhcmVudCBvZiBzb3VyY2UnKTtcbiAgfVxuXG4gIHZhciBwID0gZG90LnBhcmVudChvYmosIHBhdGgpO1xuICB2YXIgdCA9IHR5cGUocCk7XG5cbiAgaWYgKCdvYmplY3QnID09IHQpIHtcbiAgICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gICAgaWYgKHAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB2YWwgPSBwW2tleV07XG4gICAgICAgIGRlbGV0ZSBwW2tleV07XG5cbiAgICAgICAgLy8gdGFyZ2V0IGRvZXMgaW5pdGlhbGl6ZSB0aGUgcGF0aFxuICAgICAgICB2YXIgbmV3cCA9IGRvdC5wYXJlbnQob2JqLCBuZXdLZXksIHRydWUpO1xuXG4gICAgICAgIC8vIGFuZCBhbHNvIGZhaWxzIHNpbGVudGx5IHVwb24gdHlwZSBtaXNtYXRjaFxuICAgICAgICBpZiAoJ29iamVjdCcgPT0gdHlwZShuZXdwKSkge1xuICAgICAgICAgIG5ld3BbbmV3S2V5LnNwbGl0KCcuJykucG9wKCldID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdpbnZhbGlkICRyZW5hbWUgdGFyZ2V0IHBhdGggdHlwZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgbmV3IGtleVxuICAgICAgICByZXR1cm4gbmV3S2V5O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHJlbmFtZSBmcm9tIGluZXhpc3Rpbmcgc291cmNlJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnICE9IHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyRyZW5hbWUgc291cmNlIGZpZWxkIGludmFsaWQnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhbiBgJGluY2AuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJGluYyA9IGZ1bmN0aW9uICRpbmMob2JqLCBwYXRoLCBpbmMpe1xuICBpZiAoJ251bWJlcicgIT0gdHlwZShpbmMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNb2RpZmllciAkaW5jIGFsbG93ZWQgZm9yIG51bWJlcnMgb25seScpO1xuICB9XG5cbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInICE9IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJGluYyBtb2RpZmllciB0byBub24tbnVtYmVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSArPSBpbmM7XG4gICAgICAgICAgcmV0dXJuIGluYztcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZignb2JqZWN0JyA9PSB0eXBlKG9iaikgfHwgbnVtZXJpYyhrZXkpKXtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSBpbmM7XG4gICAgICAgICAgcmV0dXJuIGluYztcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBhcHBlbmQgdG8gYXJyYXkgdXNpbmcgc3RyaW5nIGZpZWxkIG5hbWUgWycgKyBrZXkgKyAnXScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJGluYyBtb2RpZmllciB0byBub24tbnVtYmVyJyk7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYW4gYCRwb3BgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRwb3AgPSBmdW5jdGlvbiAkcG9wKG9iaiwgcGF0aCwgdmFsKXtcbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gIC8vIHdlIG1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IGp1c3QgdGhlIHBhcmVudCBvZiB0aGUgbWFpbiBrZXlcbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgaWYgKG9ialtrZXldLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBpZiAoLTEgPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2tleV0uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gbW9uZ29kYiBhbGxvd3MgYW55IHZhbHVlIHRvIHBvcFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtrZXldLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIGRlYnVnKCdpZ25vcmluZyBwb3AgdG8gaW5leGlzdGluZyBrZXknKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwb3AgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdpZ25vcmluZyBwb3AgdG8gaW5leGlzdGluZyBrZXknKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb3AgdG8gaW5leGlzdGluZyBrZXknKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRwdXNoYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0byBwdXNoXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHB1c2ggPSBmdW5jdGlvbiAkcHVzaChvYmosIHBhdGgsIHZhbCl7XG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVzaC8kcHVzaEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVzaC8kcHVzaEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChudW1lcmljKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGFwcGVuZCB0byBhcnJheSB1c2luZyBzdHJpbmcgZmllbGQgbmFtZSBbJyArIGtleSArICddJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkcHVzaEFsbGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgdG8gcHVzaFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRwdXNoQWxsID0gZnVuY3Rpb24gJHB1c2hBbGwob2JqLCBwYXRoLCB2YWwpe1xuICBpZiAoJ2FycmF5JyAhPSB0eXBlKHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGlmaWVyICRwdXNoQWxsL3B1bGxBbGwgYWxsb3dlZCBmb3IgYXJyYXlzIG9ubHknKTtcbiAgfVxuXG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG9ialtrZXldLnB1c2guYXBwbHkob2JqW2tleV0sIHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1c2gvJHB1c2hBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgb2JqW2tleV0ucHVzaC5hcHBseShvYmpba2V5XSwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVzaC8kcHVzaEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChudW1lcmljKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBhcHBlbmQgdG8gYXJyYXkgdXNpbmcgc3RyaW5nIGZpZWxkIG5hbWUgWycgKyBrZXkgKyAnXScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJHB1bGxgLlxuICovXG5cbmV4cG9ydHMuJHB1bGwgPSBmdW5jdGlvbiAkcHVsbChvYmosIHBhdGgsIHZhbCl7XG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgdmFyIHQgPSB0eXBlKG9iaik7XG5cbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHZhciBwdWxsZWQgPSBbXTtcbiAgICAgICAgICB2YXIgc3BsaWNlID0gcHVsbChvYmpba2V5XSwgW3ZhbF0sIHB1bGxlZCk7XG4gICAgICAgICAgaWYgKHB1bGxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBzcGxpY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB1bGxlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdWxsLyRwdWxsQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHZhciBwdWxsZWQgPSBbXTtcbiAgICAgICAgICB2YXIgc3BsaWNlID0gcHVsbChvYmpba2V5XSwgW3ZhbF0sIHB1bGxlZCk7XG4gICAgICAgICAgaWYgKHB1bGxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBzcGxpY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB1bGxlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdWxsLyRwdWxsQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnaWdub3JpbmcgcHVsbCB0byBub24gYXJyYXknKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTEVGVF9TVUJGSUVMRCBvbmx5IHN1cHBvcnRzIE9iamVjdDogaGVsbG8gbm90OiAnICsgdCk7XG4gICAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJHB1bGxBbGxgLlxuICovXG5cbmV4cG9ydHMuJHB1bGxBbGwgPSBmdW5jdGlvbiAkcHVsbEFsbChvYmosIHBhdGgsIHZhbCl7XG4gIGlmICgnYXJyYXknICE9IHR5cGUodmFsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTW9kaWZpZXIgJHB1c2hBbGwvcHVsbEFsbCBhbGxvd2VkIGZvciBhcnJheXMgb25seScpO1xuICB9XG5cbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICB2YXIgdCA9IHR5cGUob2JqKTtcblxuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgdmFyIHB1bGxlZCA9IFtdO1xuICAgICAgICAgIHZhciBzcGxpY2UgPSBwdWxsKG9ialtrZXldLCB2YWwsIHB1bGxlZCk7XG4gICAgICAgICAgaWYgKHB1bGxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBzcGxpY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB1bGxlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdWxsLyRwdWxsQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHZhciBwdWxsZWQgPSBbXTtcbiAgICAgICAgICB2YXIgc3BsaWNlID0gcHVsbChvYmpba2V5XSwgdmFsLCBwdWxsZWQpO1xuICAgICAgICAgIGlmIChwdWxsZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgc3BsaWNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBwdWxsZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVsbC8kcHVsbEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHB1bGwgdG8gbm9uIGFycmF5Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xFRlRfU1VCRklFTEQgb25seSBzdXBwb3J0cyBPYmplY3Q6IGhlbGxvIG5vdDogJyArIHQpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRhZGRUb1NldGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdG8gcHVzaFxuICogQHBhcmFtIHtCb29sZWFufSBpbnRlcm5hbCwgdHJ1ZSBpZiByZWN1cnNpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kYWRkVG9TZXQgPSBmdW5jdGlvbiAkYWRkVG9TZXQob2JqLCBwYXRoLCB2YWwsIHJlY3Vyc2luZyl7XG4gIGlmICghcmVjdXJzaW5nICYmICdhcnJheScgPT0gdHlwZSh2YWwuJGVhY2gpKSB7XG4gICAgdmFyIGZucyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsLiRlYWNoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGZuID0gJGFkZFRvU2V0KG9iaiwgcGF0aCwgdmFsLiRlYWNoW2ldLCB0cnVlKTtcbiAgICAgIGlmIChmbikgZm5zLnB1c2goZm4pO1xuICAgIH1cbiAgICBpZiAoZm5zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHZhbHVlcy5wdXNoKGZuc1tpXSgpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG5cbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgaWYgKCFoYXMob2JqW2tleV0sIHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBvYmpba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkYWRkVG9TZXQgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gW3ZhbF07XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgaWYgKCFoYXMob2JqW2tleV0sIHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBvYmpba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkYWRkVG9TZXQgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobnVtZXJpYyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gW3ZhbF07XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBhcHBlbmQgdG8gYXJyYXkgdXNpbmcgc3RyaW5nIGZpZWxkIG5hbWUgWycgKyBrZXkgKyAnXScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyIGZvciBkZXRlcm1pbmluZyBpZiBhbiBhcnJheSBoYXMgdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzKGFycmF5LCB2YWwpe1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChlcWwodmFsLCBhcnJheVtpXSkpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBcnJheSNmaWx0ZXIgZnVuY3Rpb24gZ2VuZXJhdG9yIGZvciBgJHB1bGxgL2AkcHVsbEFsbGAgb3BlcmF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiB2YWx1ZXMgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IHRvIHBvcHVsYXRlIHdpdGggcmVzdWx0c1xuICogQHJldHVybiB7RnVuY3Rpb259IHRoYXQgc3BsaWNlcyB0aGUgYXJyYXlcbiAqL1xuXG5mdW5jdGlvbiBwdWxsKGFyciwgdmFscywgcHVsbGVkKXtcbiAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICBmb3IgKHZhciBhID0gMDsgYSA8IGFyci5sZW5ndGg7IGErKykge1xuICAgIHZhciB2YWwgPSBhcnJbYV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXRjaGVyID0gdmFsc1tpXTtcbiAgICAgIGlmICgnb2JqZWN0JyA9PSB0eXBlKG1hdGNoZXIpKSB7XG4gICAgICAgIC8vIHdlIG9ubHkgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBvYmogPC0+IG9iaiBjb21wYXJpc29uc1xuICAgICAgICBpZiAoJ29iamVjdCcgPT0gdHlwZSh2YWwpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoa2V5cyhtYXRjaGVyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbWF0Y2hlcikge1xuICAgICAgICAgICAgICBpZiAobWF0Y2hlci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgYXQgbGVhc3Qgb25lIG1hdGNoaW5nIGtleSB0byBwdWxsXG4gICAgICAgICAgICAgICAgaWYgKGVxbChtYXRjaGVyW2ldLCB2YWxbaV0pKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIGEgc2luZ2xlIGtleSBkb2Vzbid0IG1hdGNoIHdlIG1vdmUgb25cbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFrZXlzKHZhbCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBwdWxsIGB7fWAgbWF0Y2hlcyBbe31dXG4gICAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goYSk7XG4gICAgICAgICAgICBwdWxsZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdpZ25vcmluZyBwdWxsIG1hdGNoIGFnYWluc3Qgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlcWwobWF0Y2hlciwgdmFsKSkge1xuICAgICAgICAgIGluZGV4ZXMucHVzaChhKTtcbiAgICAgICAgICBwdWxsZWQucHVzaCh2YWwpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2ldO1xuICAgICAgYXJyLnNwbGljZShpbmRleCAtIGksIDEpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgbnVtZXJpYy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG51bWVyaWNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG51bWVyaWModmFsKXtcbiAgcmV0dXJuICdudW1iZXInID09IHR5cGUodmFsKSB8fCBOdW1iZXIodmFsKSA9PSB2YWw7XG59XG4iLCIvKipcbiAqIHRvU3RyaW5nIHJlZi5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwpe1xuICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOiByZXR1cm4gJ2RhdGUnO1xuICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6IHJldHVybiAncmVnZXhwJztcbiAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOiByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJ2FycmF5JztcbiAgICBjYXNlICdbb2JqZWN0IEVycm9yXSc6IHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgIT09IHZhbCkgcmV0dXJuICduYW4nO1xuICBpZiAodmFsICYmIHZhbC5ub2RlVHlwZSA9PT0gMSkgcmV0dXJuICdlbGVtZW50JztcblxuICB2YWwgPSB2YWwudmFsdWVPZlxuICAgID8gdmFsLnZhbHVlT2YoKVxuICAgIDogT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLmFwcGx5KHZhbClcblxuICByZXR1cm4gdHlwZW9mIHZhbDtcbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXG4vKipcbiAqIFVzZSBjaHJvbWUuc3RvcmFnZS5sb2NhbCBpZiB3ZSBhcmUgaW4gYW4gYXBwXG4gKi9cblxudmFyIHN0b3JhZ2U7XG5cbmlmICh0eXBlb2YgY2hyb21lICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY2hyb21lLnN0b3JhZ2UgIT09ICd1bmRlZmluZWQnKVxuICBzdG9yYWdlID0gY2hyb21lLnN0b3JhZ2UubG9jYWw7XG5lbHNlXG4gIHN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IHN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtY29tcG9uZW50Jyk7XG5cbi8qKlxuICogR2V0cyBhIGNlcnRhaW4gYHBhdGhgIGZyb20gdGhlIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdH0gZm91bmQgb2JqZWN0LCBvciBgdW5kZWZpbmVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoKXtcbiAgaWYgKH5wYXRoLmluZGV4T2YoJy4nKSkge1xuICAgIHZhciBwYXIgPSBwYXJlbnQob2JqLCBwYXRoKTtcbiAgICB2YXIgbWFpbktleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgICB2YXIgdCA9IHR5cGUocGFyKTtcbiAgICBpZiAoJ29iamVjdCcgPT0gdCB8fCAnYXJyYXknID09IHQpIHJldHVybiBwYXJbbWFpbktleV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9ialtwYXRoXTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBnaXZlbiBgcGF0aGAgdG8gYHZhbGAgaW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQFBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoLCB2YWwpe1xuICBpZiAofnBhdGguaW5kZXhPZignLicpKSB7XG4gICAgdmFyIHBhciA9IHBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICAgIHZhciBtYWluS2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICAgIGlmIChwYXIgJiYgJ29iamVjdCcgPT0gdHlwZShwYXIpKSBwYXJbbWFpbktleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgb2JqW3BhdGhdID0gdmFsO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCBvYmplY3QgZm9yIGEgZ2l2ZW4ga2V5IChkb3Qgbm90YXRpb24gYXdhcmUpLlxuICpcbiAqIC0gSWYgYSBwYXJlbnQgb2JqZWN0IGRvZXNuJ3QgZXhpc3QsIGl0J3MgaW5pdGlhbGl6ZWQuXG4gKiAtIEFycmF5IGluZGV4IGxvb2t1cCBpcyBzdXBwb3J0ZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlIGlmIGl0IHNob3VsZCBpbml0aWFsaXplIHRoZSBwYXRoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyZW50ID0gcGFyZW50O1xuXG5mdW5jdGlvbiBwYXJlbnQob2JqLCBrZXksIGluaXQpe1xuICBpZiAofmtleS5pbmRleE9mKCcuJykpIHtcbiAgICB2YXIgcGllY2VzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgdmFyIHJldCA9IG9iajtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgLy8gaWYgdGhlIGtleSBpcyBhIG51bWJlciBzdHJpbmcgYW5kIHBhcmVudCBpcyBhbiBhcnJheVxuICAgICAgaWYgKE51bWJlcihwaWVjZXNbaV0pID09IHBpZWNlc1tpXSAmJiAnYXJyYXknID09IHR5cGUocmV0KSkge1xuICAgICAgICByZXQgPSByZXRbcGllY2VzW2ldXTtcbiAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZShyZXQpKSB7XG4gICAgICAgIGlmIChpbml0ICYmICFyZXQuaGFzT3duUHJvcGVydHkocGllY2VzW2ldKSkge1xuICAgICAgICAgIHJldFtwaWVjZXNbaV1dID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldCkgcmV0ID0gcmV0W3BpZWNlc1tpXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG4iLCJcbi8qKlxuICogdG9TdHJpbmcgcmVmLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0eXBlIG9mIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCl7XG4gIHN3aXRjaCAodG9TdHJpbmcuY2FsbCh2YWwpKSB7XG4gICAgY2FzZSAnW29iamVjdCBGdW5jdGlvbl0nOiByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgICBjYXNlICdbb2JqZWN0IERhdGVdJzogcmV0dXJuICdkYXRlJztcbiAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOiByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgY2FzZSAnW29iamVjdCBBcmd1bWVudHNdJzogcmV0dXJuICdhcmd1bWVudHMnO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzogcmV0dXJuICdhcnJheSc7XG4gIH1cblxuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKHZhbCA9PT0gT2JqZWN0KHZhbCkpIHJldHVybiAnb2JqZWN0JztcblxuICByZXR1cm4gdHlwZW9mIHZhbDtcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBlcWw7XG5cbi8qKlxuICogTW9uZ29EQiBzdHlsZSB2YWx1ZSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hlclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZXkgbWF0Y2hcbiAqL1xuXG5mdW5jdGlvbiBlcWwobWF0Y2hlciwgdmFsKXtcbiAgc3dpdGNoICh0eXBlKG1hdGNoZXIpKSB7XG4gICAgY2FzZSAnbnVsbCc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIC8vIHdlIHRyZWF0IG51bGwgYXMgdW5kZWZpbmVkXG4gICAgICByZXR1cm4gbnVsbCA9PSB2YWw7XG5cbiAgICBjYXNlICdyZWdleHAnOlxuICAgICAgcmV0dXJuIG1hdGNoZXIudGVzdCh2YWwpO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKCdhcnJheScgPT0gdHlwZSh2YWwpICYmIG1hdGNoZXIubGVuZ3RoID09IHZhbC5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFlcWwodmFsW2ldLCBtYXRjaGVyW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgLy8gb2JqZWN0IGNhbiBtYXRjaCBrZXlzIGluIGFueSBvcmRlclxuICAgICAgdmFyIGtleXMgPSB7fTtcblxuICAgICAgLy8gd2UgbWF0Y2ggYWxsIHZhbHVlcyBvZiBgbWF0Y2hlcmAgaW4gYHZhbGBcbiAgICAgIGZvciAodmFyIGkgaW4gbWF0Y2hlcikge1xuICAgICAgICBpZiAobWF0Y2hlci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGlmICghdmFsLmhhc093blByb3BlcnR5KGkpIHx8ICFlcWwobWF0Y2hlcltpXSwgdmFsW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXlzW2ldID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgbWFrZSBzdXJlIGB2YWxgIGRvZXNuJ3QgaGF2ZSBleHRyYSBrZXlzXG4gICAgICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgICAgICBpZiAodmFsLmhhc093blByb3BlcnR5KGkpICYmICFrZXlzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBtYXRjaGVyID09PSB2YWw7XG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBIT1AgcmVmLlxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFJldHVybiBvd24ga2V5cyBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKXtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5cbi8qKlxuICogUmV0dXJuIG93biB2YWx1ZXMgaW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24ob2JqKXtcbiAgdmFyIHZhbHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHMucHVzaChvYmpba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxzO1xufTtcblxuLyoqXG4gKiBNZXJnZSBgYmAgaW50byBgYWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uKGEsIGIpe1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGlmIChoYXMuY2FsbChiLCBrZXkpKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gbGVuZ3RoIG9mIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5sZW5ndGggPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gZXhwb3J0cy5rZXlzKG9iaikubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBlbXB0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmlzRW1wdHkgPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gMCA9PSBleHBvcnRzLmxlbmd0aChvYmopO1xufTsiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZXFsID0gcmVxdWlyZSgnbW9uZ28tZXFsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG5cbi8qKlxuICogJG5lOiBub3QgZXF1YWwuXG4gKi9cblxuZXhwb3J0cy4kbmUgPSBmdW5jdGlvbiAkbmUobWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuICFlcWwobWF0Y2hlciwgdmFsKTtcbn07XG5cbi8qKlxuICogJGd0OiBncmVhdGVyIHRoYW4uXG4gKi9cblxuZXhwb3J0cy4kZ3QgPSBmdW5jdGlvbiAkZ3QobWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuIHR5cGUobWF0Y2hlcikgPT09ICdudW1iZXInICYmIHZhbCA+IG1hdGNoZXI7XG59O1xuXG4vKipcbiAqICRndGU6IGdyZWF0ZXIgdGhhbiBlcXVhbC5cbiAqL1xuXG5leHBvcnRzLiRndGUgPSBmdW5jdGlvbiAkZ3RlKG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiB0eXBlKG1hdGNoZXIpID09PSAnbnVtYmVyJyAmJiB2YWwgPj0gbWF0Y2hlcjtcbn07XG5cbi8qKlxuICogJGx0OiBsZXNzIHRoYW4uXG4gKi9cblxuZXhwb3J0cy4kbHQgPSBmdW5jdGlvbiAkbHQobWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuIHR5cGUobWF0Y2hlcikgPT09ICdudW1iZXInICYmIHZhbCA8IG1hdGNoZXI7XG59O1xuXG4vKipcbiAqICRsdGU6IGxlc3MgdGhhbiBlcXVhbC5cbiAqL1xuXG5leHBvcnRzLiRsdGUgPSBmdW5jdGlvbiAkbHRlKG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiB0eXBlKG1hdGNoZXIpID09PSAnbnVtYmVyJyAmJiB2YWwgPD0gbWF0Y2hlcjtcbn07XG5cbi8qKlxuICogJHJlZ2V4OiBzdXBwbHkgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgYSBzdHJpbmcuXG4gKi9cblxuZXhwb3J0cy4kcmVnZXggPSBmdW5jdGlvbiAkcmVnZXgobWF0Y2hlciwgdmFsKXtcbiAgLy8gVE9ETzogYWRkICRvcHRpb25zIHN1cHBvcnRcbiAgaWYgKCdyZWdleHAnICE9IHR5cGUoJ21hdGNoZXInKSkgbWF0Y2hlciA9IG5ldyBSZWdFeHAobWF0Y2hlcik7XG4gIHJldHVybiBtYXRjaGVyLnRlc3QodmFsKTtcbn07XG5cbi8qKlxuICogJGV4aXN0czoga2V5IGV4aXN0cy5cbiAqL1xuXG5leHBvcnRzLiRleGlzdHMgPSBmdW5jdGlvbiAkZXhpc3RzKG1hdGNoZXIsIHZhbCl7XG4gIGlmIChtYXRjaGVyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAhPT0gdmFsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQgPT09IHZhbDtcbiAgfVxufTtcblxuLyoqXG4gKiAkaW46IHZhbHVlIGluIGFycmF5LlxuICovXG5cbmV4cG9ydHMuJGluID0gZnVuY3Rpb24gJGluKG1hdGNoZXIsIHZhbCl7XG4gIGlmICgnYXJyYXknICE9IHR5cGUobWF0Y2hlcikpIHJldHVybiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGVxbChtYXRjaGVyW2ldLCB2YWwpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqICRuaW46IHZhbHVlIG5vdCBpbiBhcnJheS5cbiAqL1xuXG5leHBvcnRzLiRuaW4gPSBmdW5jdGlvbiAkbmluKG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiAhZXhwb3J0cy4kaW4obWF0Y2hlciwgdmFsKTtcbn07XG5cbi8qKlxuICogQHNpemU6IGFycmF5IGxlbmd0aFxuICovXG5cbmV4cG9ydHMuJHNpemUgPSBmdW5jdGlvbihtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpICYmIG1hdGNoZXIgPT0gdmFsLmxlbmd0aDtcbn07XG4iLCIvKiFcbiAgKiBSZXF3ZXN0ISBBIGdlbmVyYWwgcHVycG9zZSBYSFIgY29ubmVjdGlvbiBtYW5hZ2VyXG4gICogbGljZW5zZSBNSVQgKGMpIER1c3RpbiBEaWF6IDIwMTRcbiAgKiBodHRwczovL2dpdGh1Yi5jb20vZGVkL3JlcXdlc3RcbiAgKi9cblxuIWZ1bmN0aW9uIChuYW1lLCBjb250ZXh0LCBkZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGRlZmluaXRpb24pXG4gIGVsc2UgY29udGV4dFtuYW1lXSA9IGRlZmluaXRpb24oKVxufSgncmVxd2VzdCcsIHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgd2luID0gd2luZG93XG4gICAgLCBkb2MgPSBkb2N1bWVudFxuICAgICwgaHR0cHNSZSA9IC9eaHR0cC9cbiAgICAsIHByb3RvY29sUmUgPSAvKF5cXHcrKTpcXC9cXC8vXG4gICAgLCB0d29IdW5kbyA9IC9eKDIwXFxkfDEyMjMpJC8gLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgICAsIGJ5VGFnID0gJ2dldEVsZW1lbnRzQnlUYWdOYW1lJ1xuICAgICwgcmVhZHlTdGF0ZSA9ICdyZWFkeVN0YXRlJ1xuICAgICwgY29udGVudFR5cGUgPSAnQ29udGVudC1UeXBlJ1xuICAgICwgcmVxdWVzdGVkV2l0aCA9ICdYLVJlcXVlc3RlZC1XaXRoJ1xuICAgICwgaGVhZCA9IGRvY1tieVRhZ10oJ2hlYWQnKVswXVxuICAgICwgdW5pcWlkID0gMFxuICAgICwgY2FsbGJhY2tQcmVmaXggPSAncmVxd2VzdF8nICsgKCtuZXcgRGF0ZSgpKVxuICAgICwgbGFzdFZhbHVlIC8vIGRhdGEgc3RvcmVkIGJ5IHRoZSBtb3N0IHJlY2VudCBKU09OUCBjYWxsYmFja1xuICAgICwgeG1sSHR0cFJlcXVlc3QgPSAnWE1MSHR0cFJlcXVlc3QnXG4gICAgLCB4RG9tYWluUmVxdWVzdCA9ICdYRG9tYWluUmVxdWVzdCdcbiAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG4gICAgLCBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IEFycmF5LmlzQXJyYXlcbiAgICAgICAgOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgIH1cblxuICAgICwgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgICAgICAgJ2NvbnRlbnRUeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbiAgICAgICAgLCAncmVxdWVzdGVkV2l0aCc6IHhtbEh0dHBSZXF1ZXN0XG4gICAgICAgICwgJ2FjY2VwdCc6IHtcbiAgICAgICAgICAgICAgJyonOiAgJ3RleHQvamF2YXNjcmlwdCwgdGV4dC9odG1sLCBhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sLCAqLyonXG4gICAgICAgICAgICAsICd4bWwnOiAgJ2FwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwnXG4gICAgICAgICAgICAsICdodG1sJzogJ3RleHQvaHRtbCdcbiAgICAgICAgICAgICwgJ3RleHQnOiAndGV4dC9wbGFpbidcbiAgICAgICAgICAgICwgJ2pzb24nOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICAgICAgLCAnanMnOiAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCB0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLCB4aHIgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIC8vIGlzIGl0IHgtZG9tYWluXG4gICAgICAgIGlmIChvWydjcm9zc09yaWdpbiddID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHhociA9IHdpblt4bWxIdHRwUmVxdWVzdF0gPyBuZXcgWE1MSHR0cFJlcXVlc3QoKSA6IG51bGxcbiAgICAgICAgICBpZiAoeGhyICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgcmV0dXJuIHhoclxuICAgICAgICAgIH0gZWxzZSBpZiAod2luW3hEb21haW5SZXF1ZXN0XSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGNyb3NzLW9yaWdpbiByZXF1ZXN0cycpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHdpblt4bWxIdHRwUmVxdWVzdF0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICwgZ2xvYmFsU2V0dXBPcHRpb25zID0ge1xuICAgICAgICBkYXRhRmlsdGVyOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgIH1cbiAgICAgIH1cblxuICBmdW5jdGlvbiBzdWNjZWVkKHIpIHtcbiAgICB2YXIgcHJvdG9jb2wgPSBwcm90b2NvbFJlLmV4ZWMoci51cmwpO1xuICAgIHByb3RvY29sID0gKHByb3RvY29sICYmIHByb3RvY29sWzFdKSB8fCB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgcmV0dXJuIGh0dHBzUmUudGVzdChwcm90b2NvbCkgPyB0d29IdW5kby50ZXN0KHIucmVxdWVzdC5zdGF0dXMpIDogISFyLnJlcXVlc3QucmVzcG9uc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSZWFkeVN0YXRlKHIsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHVzZSBfYWJvcnRlZCB0byBtaXRpZ2F0ZSBhZ2FpbnN0IElFIGVyciBjMDBjMDIzZlxuICAgICAgLy8gKGNhbid0IHJlYWQgcHJvcHMgb24gYWJvcnRlZCByZXF1ZXN0IG9iamVjdHMpXG4gICAgICBpZiAoci5fYWJvcnRlZCkgcmV0dXJuIGVycm9yKHIucmVxdWVzdClcbiAgICAgIGlmIChyLl90aW1lZE91dCkgcmV0dXJuIGVycm9yKHIucmVxdWVzdCwgJ1JlcXVlc3QgaXMgYWJvcnRlZDogdGltZW91dCcpXG4gICAgICBpZiAoci5yZXF1ZXN0ICYmIHIucmVxdWVzdFtyZWFkeVN0YXRlXSA9PSA0KSB7XG4gICAgICAgIHIucmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBub29wXG4gICAgICAgIGlmIChzdWNjZWVkKHIpKSBzdWNjZXNzKHIucmVxdWVzdClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVycm9yKHIucmVxdWVzdClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRIZWFkZXJzKGh0dHAsIG8pIHtcbiAgICB2YXIgaGVhZGVycyA9IG9bJ2hlYWRlcnMnXSB8fCB7fVxuICAgICAgLCBoXG5cbiAgICBoZWFkZXJzWydBY2NlcHQnXSA9IGhlYWRlcnNbJ0FjY2VwdCddXG4gICAgICB8fCBkZWZhdWx0SGVhZGVyc1snYWNjZXB0J11bb1sndHlwZSddXVxuICAgICAgfHwgZGVmYXVsdEhlYWRlcnNbJ2FjY2VwdCddWycqJ11cblxuICAgIHZhciBpc0FGb3JtRGF0YSA9IHR5cGVvZiBGb3JtRGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiAob1snZGF0YSddIGluc3RhbmNlb2YgRm9ybURhdGEpO1xuICAgIC8vIGJyZWFrcyBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgd2l0aCBsZWdhY3kgYnJvd3NlcnNcbiAgICBpZiAoIW9bJ2Nyb3NzT3JpZ2luJ10gJiYgIWhlYWRlcnNbcmVxdWVzdGVkV2l0aF0pIGhlYWRlcnNbcmVxdWVzdGVkV2l0aF0gPSBkZWZhdWx0SGVhZGVyc1sncmVxdWVzdGVkV2l0aCddXG4gICAgaWYgKCFoZWFkZXJzW2NvbnRlbnRUeXBlXSAmJiAhaXNBRm9ybURhdGEpIGhlYWRlcnNbY29udGVudFR5cGVdID0gb1snY29udGVudFR5cGUnXSB8fCBkZWZhdWx0SGVhZGVyc1snY29udGVudFR5cGUnXVxuICAgIGZvciAoaCBpbiBoZWFkZXJzKVxuICAgICAgaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoKSAmJiAnc2V0UmVxdWVzdEhlYWRlcicgaW4gaHR0cCAmJiBodHRwLnNldFJlcXVlc3RIZWFkZXIoaCwgaGVhZGVyc1toXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENyZWRlbnRpYWxzKGh0dHAsIG8pIHtcbiAgICBpZiAodHlwZW9mIG9bJ3dpdGhDcmVkZW50aWFscyddICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaHR0cC53aXRoQ3JlZGVudGlhbHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBodHRwLndpdGhDcmVkZW50aWFscyA9ICEhb1snd2l0aENyZWRlbnRpYWxzJ11cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmFsQ2FsbGJhY2soZGF0YSkge1xuICAgIGxhc3RWYWx1ZSA9IGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIHVybGFwcGVuZCAodXJsLCBzKSB7XG4gICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgc1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKSB7XG4gICAgdmFyIHJlcUlkID0gdW5pcWlkKytcbiAgICAgICwgY2JrZXkgPSBvWydqc29ucENhbGxiYWNrJ10gfHwgJ2NhbGxiYWNrJyAvLyB0aGUgJ2NhbGxiYWNrJyBrZXlcbiAgICAgICwgY2J2YWwgPSBvWydqc29ucENhbGxiYWNrTmFtZSddIHx8IHJlcXdlc3QuZ2V0Y2FsbGJhY2tQcmVmaXgocmVxSWQpXG4gICAgICAsIGNicmVnID0gbmV3IFJlZ0V4cCgnKChefFxcXFw/fCYpJyArIGNia2V5ICsgJyk9KFteJl0rKScpXG4gICAgICAsIG1hdGNoID0gdXJsLm1hdGNoKGNicmVnKVxuICAgICAgLCBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgICwgbG9hZGVkID0gMFxuICAgICAgLCBpc0lFMTAgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgMTAuMCcpICE9PSAtMVxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBpZiAobWF0Y2hbM10gPT09ICc/Jykge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShjYnJlZywgJyQxPScgKyBjYnZhbCkgLy8gd2lsZGNhcmQgY2FsbGJhY2sgZnVuYyBuYW1lXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYnZhbCA9IG1hdGNoWzNdIC8vIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmMgbmFtZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cmwgPSB1cmxhcHBlbmQodXJsLCBjYmtleSArICc9JyArIGNidmFsKSAvLyBubyBjYWxsYmFjayBkZXRhaWxzLCBhZGQgJ2VtXG4gICAgfVxuXG4gICAgd2luW2NidmFsXSA9IGdlbmVyYWxDYWxsYmFja1xuXG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICAgIHNjcmlwdC5zcmMgPSB1cmxcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlXG4gICAgaWYgKHR5cGVvZiBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlICE9PSAndW5kZWZpbmVkJyAmJiAhaXNJRTEwKSB7XG4gICAgICAvLyBuZWVkIHRoaXMgZm9yIElFIGR1ZSB0byBvdXQtb2Ytb3JkZXIgb25yZWFkeXN0YXRlY2hhbmdlKCksIGJpbmRpbmcgc2NyaXB0XG4gICAgICAvLyBleGVjdXRpb24gdG8gYW4gZXZlbnQgbGlzdGVuZXIgZ2l2ZXMgdXMgY29udHJvbCBvdmVyIHdoZW4gdGhlIHNjcmlwdFxuICAgICAgLy8gaXMgZXhlY3V0ZWQuIFNlZSBodHRwOi8vamF1Ym91cmcubmV0LzIwMTAvMDcvbG9hZGluZy1zY3JpcHQtYXMtb25jbGljay1oYW5kbGVyLW9mLmh0bWxcbiAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkID0gJ19yZXF3ZXN0XycgKyByZXFJZFxuICAgIH1cblxuICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKChzY3JpcHRbcmVhZHlTdGF0ZV0gJiYgc2NyaXB0W3JlYWR5U3RhdGVdICE9PSAnY29tcGxldGUnICYmIHNjcmlwdFtyZWFkeVN0YXRlXSAhPT0gJ2xvYWRlZCcpIHx8IGxvYWRlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgc2NyaXB0Lm9uY2xpY2sgJiYgc2NyaXB0Lm9uY2xpY2soKVxuICAgICAgLy8gQ2FsbCB0aGUgdXNlciBjYWxsYmFjayB3aXRoIHRoZSBsYXN0IHZhbHVlIHN0b3JlZCBhbmQgY2xlYW4gdXAgdmFsdWVzIGFuZCBzY3JpcHRzLlxuICAgICAgZm4obGFzdFZhbHVlKVxuICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkXG4gICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdClcbiAgICAgIGxvYWRlZCA9IDFcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHNjcmlwdCB0byB0aGUgRE9NIGhlYWRcbiAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcblxuICAgIC8vIEVuYWJsZSBKU09OUCB0aW1lb3V0XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICBlcnIoe30sICdSZXF1ZXN0IGlzIGFib3J0ZWQ6IHRpbWVvdXQnLCB7fSlcbiAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkXG4gICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuICAgICAgICBsb2FkZWQgPSAxXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVxdWVzdChmbiwgZXJyKSB7XG4gICAgdmFyIG8gPSB0aGlzLm9cbiAgICAgICwgbWV0aG9kID0gKG9bJ21ldGhvZCddIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpXG4gICAgICAsIHVybCA9IHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG8gOiBvWyd1cmwnXVxuICAgICAgLy8gY29udmVydCBub24tc3RyaW5nIG9iamVjdHMgdG8gcXVlcnktc3RyaW5nIGZvcm0gdW5sZXNzIG9bJ3Byb2Nlc3NEYXRhJ10gaXMgZmFsc2VcbiAgICAgICwgZGF0YSA9IChvWydwcm9jZXNzRGF0YSddICE9PSBmYWxzZSAmJiBvWydkYXRhJ10gJiYgdHlwZW9mIG9bJ2RhdGEnXSAhPT0gJ3N0cmluZycpXG4gICAgICAgID8gcmVxd2VzdC50b1F1ZXJ5U3RyaW5nKG9bJ2RhdGEnXSlcbiAgICAgICAgOiAob1snZGF0YSddIHx8IG51bGwpXG4gICAgICAsIGh0dHBcbiAgICAgICwgc2VuZFdhaXQgPSBmYWxzZVxuXG4gICAgLy8gaWYgd2UncmUgd29ya2luZyBvbiBhIEdFVCByZXF1ZXN0IGFuZCB3ZSBoYXZlIGRhdGEgdGhlbiB3ZSBzaG91bGQgYXBwZW5kXG4gICAgLy8gcXVlcnkgc3RyaW5nIHRvIGVuZCBvZiBVUkwgYW5kIG5vdCBwb3N0IGRhdGFcbiAgICBpZiAoKG9bJ3R5cGUnXSA9PSAnanNvbnAnIHx8IG1ldGhvZCA9PSAnR0VUJykgJiYgZGF0YSkge1xuICAgICAgdXJsID0gdXJsYXBwZW5kKHVybCwgZGF0YSlcbiAgICAgIGRhdGEgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKG9bJ3R5cGUnXSA9PSAnanNvbnAnKSByZXR1cm4gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKVxuXG4gICAgLy8gZ2V0IHRoZSB4aHIgZnJvbSB0aGUgZmFjdG9yeSBpZiBwYXNzZWRcbiAgICAvLyBpZiB0aGUgZmFjdG9yeSByZXR1cm5zIG51bGwsIGZhbGwtYmFjayB0byBvdXJzXG4gICAgaHR0cCA9IChvLnhociAmJiBvLnhocihvKSkgfHwgeGhyKG8pXG5cbiAgICBodHRwLm9wZW4obWV0aG9kLCB1cmwsIG9bJ2FzeW5jJ10gPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlKVxuICAgIHNldEhlYWRlcnMoaHR0cCwgbylcbiAgICBzZXRDcmVkZW50aWFscyhodHRwLCBvKVxuICAgIGlmICh3aW5beERvbWFpblJlcXVlc3RdICYmIGh0dHAgaW5zdGFuY2VvZiB3aW5beERvbWFpblJlcXVlc3RdKSB7XG4gICAgICAgIGh0dHAub25sb2FkID0gZm5cbiAgICAgICAgaHR0cC5vbmVycm9yID0gZXJyXG4gICAgICAgIC8vIE5PVEU6IHNlZVxuICAgICAgICAvLyBodHRwOi8vc29jaWFsLm1zZG4ubWljcm9zb2Z0LmNvbS9Gb3J1bXMvZW4tVVMvaWV3ZWJkZXZlbG9wbWVudC90aHJlYWQvMzBlZjNhZGQtNzY3Yy00NDM2LWI4YTktZjFjYTE5YjQ4MTJlXG4gICAgICAgIGh0dHAub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge31cbiAgICAgICAgc2VuZFdhaXQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlUmVhZHlTdGF0ZSh0aGlzLCBmbiwgZXJyKVxuICAgIH1cbiAgICBvWydiZWZvcmUnXSAmJiBvWydiZWZvcmUnXShodHRwKVxuICAgIGlmIChzZW5kV2FpdCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0dHAuc2VuZChkYXRhKVxuICAgICAgfSwgMjAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBodHRwLnNlbmQoZGF0YSlcbiAgICB9XG4gICAgcmV0dXJuIGh0dHBcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXdlc3QobywgZm4pIHtcbiAgICB0aGlzLm8gPSBvXG4gICAgdGhpcy5mbiA9IGZuXG5cbiAgICBpbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFR5cGUoaGVhZGVyKSB7XG4gICAgLy8ganNvbiwgamF2YXNjcmlwdCwgdGV4dC9wbGFpbiwgdGV4dC9odG1sLCB4bWxcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCdqc29uJykpIHJldHVybiAnanNvbidcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCdqYXZhc2NyaXB0JykpIHJldHVybiAnanMnXG4gICAgaWYgKGhlYWRlci5tYXRjaCgndGV4dCcpKSByZXR1cm4gJ2h0bWwnXG4gICAgaWYgKGhlYWRlci5tYXRjaCgneG1sJykpIHJldHVybiAneG1sJ1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdChvLCBmbikge1xuXG4gICAgdGhpcy51cmwgPSB0eXBlb2YgbyA9PSAnc3RyaW5nJyA/IG8gOiBvWyd1cmwnXVxuICAgIHRoaXMudGltZW91dCA9IG51bGxcblxuICAgIC8vIHdoZXRoZXIgcmVxdWVzdCBoYXMgYmVlbiBmdWxmaWxsZWQgZm9yIHB1cnBvc2VcbiAgICAvLyBvZiB0cmFja2luZyB0aGUgUHJvbWlzZXNcbiAgICB0aGlzLl9mdWxmaWxsZWQgPSBmYWxzZVxuICAgIC8vIHN1Y2Nlc3MgaGFuZGxlcnNcbiAgICB0aGlzLl9zdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uKCl7fVxuICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcnMgPSBbXVxuICAgIC8vIGVycm9yIGhhbmRsZXJzXG4gICAgdGhpcy5fZXJyb3JIYW5kbGVycyA9IFtdXG4gICAgLy8gY29tcGxldGUgKGJvdGggc3VjY2VzcyBhbmQgZmFpbCkgaGFuZGxlcnNcbiAgICB0aGlzLl9jb21wbGV0ZUhhbmRsZXJzID0gW11cbiAgICB0aGlzLl9lcnJlZCA9IGZhbHNlXG4gICAgdGhpcy5fcmVzcG9uc2VBcmdzID0ge31cblxuICAgIHZhciBzZWxmID0gdGhpc1xuXG4gICAgZm4gPSBmbiB8fCBmdW5jdGlvbiAoKSB7fVxuXG4gICAgaWYgKG9bJ3RpbWVvdXQnXSkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRpbWVkT3V0KClcbiAgICAgIH0sIG9bJ3RpbWVvdXQnXSlcbiAgICB9XG5cbiAgICBpZiAob1snc3VjY2VzcyddKSB7XG4gICAgICB0aGlzLl9zdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb1snc3VjY2VzcyddLmFwcGx5KG8sIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob1snZXJyb3InXSkge1xuICAgICAgdGhpcy5fZXJyb3JIYW5kbGVycy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb1snZXJyb3InXS5hcHBseShvLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChvWydjb21wbGV0ZSddKSB7XG4gICAgICB0aGlzLl9jb21wbGV0ZUhhbmRsZXJzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBvWydjb21wbGV0ZSddLmFwcGx5KG8sIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGUgKHJlc3ApIHtcbiAgICAgIG9bJ3RpbWVvdXQnXSAmJiBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuICAgICAgc2VsZi50aW1lb3V0ID0gbnVsbFxuICAgICAgd2hpbGUgKHNlbGYuX2NvbXBsZXRlSGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLl9jb21wbGV0ZUhhbmRsZXJzLnNoaWZ0KCkocmVzcClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWNjZXNzIChyZXNwKSB7XG4gICAgICB2YXIgdHlwZSA9IG9bJ3R5cGUnXSB8fCByZXNwICYmIHNldFR5cGUocmVzcC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykpIC8vIHJlc3AgY2FuIGJlIHVuZGVmaW5lZCBpbiBJRVxuICAgICAgcmVzcCA9ICh0eXBlICE9PSAnanNvbnAnKSA/IHNlbGYucmVxdWVzdCA6IHJlc3BcbiAgICAgIC8vIHVzZSBnbG9iYWwgZGF0YSBmaWx0ZXIgb24gcmVzcG9uc2UgdGV4dFxuICAgICAgdmFyIGZpbHRlcmVkUmVzcG9uc2UgPSBnbG9iYWxTZXR1cE9wdGlvbnMuZGF0YUZpbHRlcihyZXNwLnJlc3BvbnNlVGV4dCwgdHlwZSlcbiAgICAgICAgLCByID0gZmlsdGVyZWRSZXNwb25zZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcC5yZXNwb25zZVRleHQgPSByXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGNhbid0IGFzc2lnbiB0aGlzIGluIElFPD04LCBqdXN0IGlnbm9yZVxuICAgICAgfVxuICAgICAgaWYgKHIpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwID0gd2luLkpTT04gPyB3aW4uSlNPTi5wYXJzZShyKSA6IGV2YWwoJygnICsgciArICcpJylcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihyZXNwLCAnQ291bGQgbm90IHBhcnNlIEpTT04gaW4gcmVzcG9uc2UnLCBlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2pzJzpcbiAgICAgICAgICByZXNwID0gZXZhbChyKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgIHJlc3AgPSByXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAneG1sJzpcbiAgICAgICAgICByZXNwID0gcmVzcC5yZXNwb25zZVhNTFxuICAgICAgICAgICAgICAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IgLy8gSUUgdHJvbG9sb1xuICAgICAgICAgICAgICAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IuZXJyb3JDb2RlXG4gICAgICAgICAgICAgICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvci5yZWFzb25cbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiByZXNwLnJlc3BvbnNlWE1MXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLl9yZXNwb25zZUFyZ3MucmVzcCA9IHJlc3BcbiAgICAgIHNlbGYuX2Z1bGZpbGxlZCA9IHRydWVcbiAgICAgIGZuKHJlc3ApXG4gICAgICBzZWxmLl9zdWNjZXNzSGFuZGxlcihyZXNwKVxuICAgICAgd2hpbGUgKHNlbGYuX2Z1bGZpbGxtZW50SGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXNwID0gc2VsZi5fZnVsZmlsbG1lbnRIYW5kbGVycy5zaGlmdCgpKHJlc3ApXG4gICAgICB9XG5cbiAgICAgIGNvbXBsZXRlKHJlc3ApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGltZWRPdXQoKSB7XG4gICAgICBzZWxmLl90aW1lZE91dCA9IHRydWVcbiAgICAgIHNlbGYucmVxdWVzdC5hYm9ydCgpICAgICAgXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3IocmVzcCwgbXNnLCB0KSB7XG4gICAgICByZXNwID0gc2VsZi5yZXF1ZXN0XG4gICAgICBzZWxmLl9yZXNwb25zZUFyZ3MucmVzcCA9IHJlc3BcbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5tc2cgPSBtc2dcbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy50ID0gdFxuICAgICAgc2VsZi5fZXJyZWQgPSB0cnVlXG4gICAgICB3aGlsZSAoc2VsZi5fZXJyb3JIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGYuX2Vycm9ySGFuZGxlcnMuc2hpZnQoKShyZXNwLCBtc2csIHQpXG4gICAgICB9XG4gICAgICBjb21wbGV0ZShyZXNwKVxuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdCA9IGdldFJlcXVlc3QuY2FsbCh0aGlzLCBzdWNjZXNzLCBlcnJvcilcbiAgfVxuXG4gIFJlcXdlc3QucHJvdG90eXBlID0ge1xuICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hYm9ydGVkID0gdHJ1ZVxuICAgICAgdGhpcy5yZXF1ZXN0LmFib3J0KClcbiAgICB9XG5cbiAgLCByZXRyeTogZnVuY3Rpb24gKCkge1xuICAgICAgaW5pdC5jYWxsKHRoaXMsIHRoaXMubywgdGhpcy5mbilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTbWFsbCBkZXZpYXRpb24gZnJvbSB0aGUgUHJvbWlzZXMgQSBDb21tb25KcyBzcGVjaWZpY2F0aW9uXG4gICAgICogaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvUHJvbWlzZXMvQVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogYHRoZW5gIHdpbGwgZXhlY3V0ZSB1cG9uIHN1Y2Nlc3NmdWwgcmVxdWVzdHNcbiAgICAgKi9cbiAgLCB0aGVuOiBmdW5jdGlvbiAoc3VjY2VzcywgZmFpbCkge1xuICAgICAgc3VjY2VzcyA9IHN1Y2Nlc3MgfHwgZnVuY3Rpb24gKCkge31cbiAgICAgIGZhaWwgPSBmYWlsIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgICBpZiAodGhpcy5fZnVsZmlsbGVkKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwID0gc3VjY2Vzcyh0aGlzLl9yZXNwb25zZUFyZ3MucmVzcClcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fZXJyZWQpIHtcbiAgICAgICAgZmFpbCh0aGlzLl9yZXNwb25zZUFyZ3MucmVzcCwgdGhpcy5fcmVzcG9uc2VBcmdzLm1zZywgdGhpcy5fcmVzcG9uc2VBcmdzLnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXJzLnB1c2goc3VjY2VzcylcbiAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVycy5wdXNoKGZhaWwpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGBhbHdheXNgIHdpbGwgZXhlY3V0ZSB3aGV0aGVyIHRoZSByZXF1ZXN0IHN1Y2NlZWRzIG9yIGZhaWxzXG4gICAgICovXG4gICwgYWx3YXlzOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGlmICh0aGlzLl9mdWxmaWxsZWQgfHwgdGhpcy5fZXJyZWQpIHtcbiAgICAgICAgZm4odGhpcy5fcmVzcG9uc2VBcmdzLnJlc3ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZUhhbmRsZXJzLnB1c2goZm4pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGBmYWlsYCB3aWxsIGV4ZWN1dGUgd2hlbiB0aGUgcmVxdWVzdCBmYWlsc1xuICAgICAqL1xuICAsIGZhaWw6IGZ1bmN0aW9uIChmbikge1xuICAgICAgaWYgKHRoaXMuX2VycmVkKSB7XG4gICAgICAgIGZuKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwLCB0aGlzLl9yZXNwb25zZUFyZ3MubXNnLCB0aGlzLl9yZXNwb25zZUFyZ3MudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Vycm9ySGFuZGxlcnMucHVzaChmbilcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAsICdjYXRjaCc6IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIHRoaXMuZmFpbChmbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXF3ZXN0KG8sIGZuKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF3ZXN0KG8sIGZuKVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIG5ld2xpbmUgdmFyaWFudHMgYWNjb3JkaW5nIHRvIHNwZWMgLT4gQ1JMRlxuICBmdW5jdGlvbiBub3JtYWxpemUocykge1xuICAgIHJldHVybiBzID8gcy5yZXBsYWNlKC9cXHI/XFxuL2csICdcXHJcXG4nKSA6ICcnXG4gIH1cblxuICBmdW5jdGlvbiBzZXJpYWwoZWwsIGNiKSB7XG4gICAgdmFyIG4gPSBlbC5uYW1lXG4gICAgICAsIHQgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICwgb3B0Q2IgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgIC8vIElFIGdpdmVzIHZhbHVlPVwiXCIgZXZlbiB3aGVyZSB0aGVyZSBpcyBubyB2YWx1ZSBhdHRyaWJ1dGVcbiAgICAgICAgICAvLyAnc3BlY2lmaWVkJyByZWY6IGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvcmUvY29yZS5odG1sI0lELTg2MjUyOTI3M1xuICAgICAgICAgIGlmIChvICYmICFvWydkaXNhYmxlZCddKVxuICAgICAgICAgICAgY2Iobiwgbm9ybWFsaXplKG9bJ2F0dHJpYnV0ZXMnXVsndmFsdWUnXSAmJiBvWydhdHRyaWJ1dGVzJ11bJ3ZhbHVlJ11bJ3NwZWNpZmllZCddID8gb1sndmFsdWUnXSA6IG9bJ3RleHQnXSkpXG4gICAgICAgIH1cbiAgICAgICwgY2gsIHJhLCB2YWwsIGlcblxuICAgIC8vIGRvbid0IHNlcmlhbGl6ZSBlbGVtZW50cyB0aGF0IGFyZSBkaXNhYmxlZCBvciB3aXRob3V0IGEgbmFtZVxuICAgIGlmIChlbC5kaXNhYmxlZCB8fCAhbikgcmV0dXJuXG5cbiAgICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpZiAoIS9yZXNldHxidXR0b258aW1hZ2V8ZmlsZS9pLnRlc3QoZWwudHlwZSkpIHtcbiAgICAgICAgY2ggPSAvY2hlY2tib3gvaS50ZXN0KGVsLnR5cGUpXG4gICAgICAgIHJhID0gL3JhZGlvL2kudGVzdChlbC50eXBlKVxuICAgICAgICB2YWwgPSBlbC52YWx1ZVxuICAgICAgICAvLyBXZWJLaXQgZ2l2ZXMgdXMgXCJcIiBpbnN0ZWFkIG9mIFwib25cIiBpZiBhIGNoZWNrYm94IGhhcyBubyB2YWx1ZSwgc28gY29ycmVjdCBpdCBoZXJlXG4gICAgICAgIDsoIShjaCB8fCByYSkgfHwgZWwuY2hlY2tlZCkgJiYgY2Iobiwgbm9ybWFsaXplKGNoICYmIHZhbCA9PT0gJycgPyAnb24nIDogdmFsKSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgY2Iobiwgbm9ybWFsaXplKGVsLnZhbHVlKSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGlmIChlbC50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3Qtb25lJykge1xuICAgICAgICBvcHRDYihlbC5zZWxlY3RlZEluZGV4ID49IDAgPyBlbC5vcHRpb25zW2VsLnNlbGVjdGVkSW5kZXhdIDogbnVsbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGVsLmxlbmd0aCAmJiBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbC5vcHRpb25zW2ldLnNlbGVjdGVkICYmIG9wdENiKGVsLm9wdGlvbnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gY29sbGVjdCB1cCBhbGwgZm9ybSBlbGVtZW50cyBmb3VuZCBmcm9tIHRoZSBwYXNzZWQgYXJndW1lbnQgZWxlbWVudHMgYWxsXG4gIC8vIHRoZSB3YXkgZG93biB0byBjaGlsZCBlbGVtZW50czsgcGFzcyBhICc8Zm9ybT4nIG9yIGZvcm0gZmllbGRzLlxuICAvLyBjYWxsZWQgd2l0aCAndGhpcyc9Y2FsbGJhY2sgdG8gdXNlIGZvciBzZXJpYWwoKSBvbiBlYWNoIGVsZW1lbnRcbiAgZnVuY3Rpb24gZWFjaEZvcm1FbGVtZW50KCkge1xuICAgIHZhciBjYiA9IHRoaXNcbiAgICAgICwgZSwgaVxuICAgICAgLCBzZXJpYWxpemVTdWJ0YWdzID0gZnVuY3Rpb24gKGUsIHRhZ3MpIHtcbiAgICAgICAgICB2YXIgaSwgaiwgZmFcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmEgPSBlW2J5VGFnXSh0YWdzW2ldKVxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZhLmxlbmd0aDsgaisrKSBzZXJpYWwoZmFbal0sIGNiKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZSA9IGFyZ3VtZW50c1tpXVxuICAgICAgaWYgKC9pbnB1dHxzZWxlY3R8dGV4dGFyZWEvaS50ZXN0KGUudGFnTmFtZSkpIHNlcmlhbChlLCBjYilcbiAgICAgIHNlcmlhbGl6ZVN1YnRhZ3MoZSwgWyAnaW5wdXQnLCAnc2VsZWN0JywgJ3RleHRhcmVhJyBdKVxuICAgIH1cbiAgfVxuXG4gIC8vIHN0YW5kYXJkIHF1ZXJ5IHN0cmluZyBzdHlsZSBzZXJpYWxpemF0aW9uXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5U3RyaW5nKCkge1xuICAgIHJldHVybiByZXF3ZXN0LnRvUXVlcnlTdHJpbmcocmVxd2VzdC5zZXJpYWxpemVBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKVxuICB9XG5cbiAgLy8geyAnbmFtZSc6ICd2YWx1ZScsIC4uLiB9IHN0eWxlIHNlcmlhbGl6YXRpb25cbiAgZnVuY3Rpb24gc2VyaWFsaXplSGFzaCgpIHtcbiAgICB2YXIgaGFzaCA9IHt9XG4gICAgZWFjaEZvcm1FbGVtZW50LmFwcGx5KGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKG5hbWUgaW4gaGFzaCkge1xuICAgICAgICBoYXNoW25hbWVdICYmICFpc0FycmF5KGhhc2hbbmFtZV0pICYmIChoYXNoW25hbWVdID0gW2hhc2hbbmFtZV1dKVxuICAgICAgICBoYXNoW25hbWVdLnB1c2godmFsdWUpXG4gICAgICB9IGVsc2UgaGFzaFtuYW1lXSA9IHZhbHVlXG4gICAgfSwgYXJndW1lbnRzKVxuICAgIHJldHVybiBoYXNoXG4gIH1cblxuICAvLyBbIHsgbmFtZTogJ25hbWUnLCB2YWx1ZTogJ3ZhbHVlJyB9LCAuLi4gXSBzdHlsZSBzZXJpYWxpemF0aW9uXG4gIHJlcXdlc3Quc2VyaWFsaXplQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyciA9IFtdXG4gICAgZWFjaEZvcm1FbGVtZW50LmFwcGx5KGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgYXJyLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0pXG4gICAgfSwgYXJndW1lbnRzKVxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIHJlcXdlc3Quc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgICB2YXIgb3B0LCBmblxuICAgICAgLCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuXG4gICAgb3B0ID0gYXJncy5wb3AoKVxuICAgIG9wdCAmJiBvcHQubm9kZVR5cGUgJiYgYXJncy5wdXNoKG9wdCkgJiYgKG9wdCA9IG51bGwpXG4gICAgb3B0ICYmIChvcHQgPSBvcHQudHlwZSlcblxuICAgIGlmIChvcHQgPT0gJ21hcCcpIGZuID0gc2VyaWFsaXplSGFzaFxuICAgIGVsc2UgaWYgKG9wdCA9PSAnYXJyYXknKSBmbiA9IHJlcXdlc3Quc2VyaWFsaXplQXJyYXlcbiAgICBlbHNlIGZuID0gc2VyaWFsaXplUXVlcnlTdHJpbmdcblxuICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKVxuICB9XG5cbiAgcmVxd2VzdC50b1F1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKG8sIHRyYWQpIHtcbiAgICB2YXIgcHJlZml4LCBpXG4gICAgICAsIHRyYWRpdGlvbmFsID0gdHJhZCB8fCBmYWxzZVxuICAgICAgLCBzID0gW11cbiAgICAgICwgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50XG4gICAgICAsIGFkZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG4gICAgICAgICAgdmFsdWUgPSAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlKSA/IHZhbHVlKCkgOiAodmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpXG4gICAgICAgICAgc1tzLmxlbmd0aF0gPSBlbmMoa2V5KSArICc9JyArIGVuYyh2YWx1ZSlcbiAgICAgICAgfVxuICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgaWYgKGlzQXJyYXkobykpIHtcbiAgICAgIGZvciAoaSA9IDA7IG8gJiYgaSA8IG8ubGVuZ3RoOyBpKyspIGFkZChvW2ldWyduYW1lJ10sIG9baV1bJ3ZhbHVlJ10pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cbiAgICAgIGZvciAocHJlZml4IGluIG8pIHtcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkocHJlZml4KSkgYnVpbGRQYXJhbXMocHJlZml4LCBvW3ByZWZpeF0sIHRyYWRpdGlvbmFsLCBhZGQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3BhY2VzIHNob3VsZCBiZSArIGFjY29yZGluZyB0byBzcGVjXG4gICAgcmV0dXJuIHMuam9pbignJicpLnJlcGxhY2UoLyUyMC9nLCAnKycpXG4gIH1cblxuICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xuICAgIHZhciBuYW1lLCBpLCB2XG4gICAgICAsIHJicmFja2V0ID0gL1xcW1xcXSQvXG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgIGZvciAoaSA9IDA7IG9iaiAmJiBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHYgPSBvYmpbaV1cbiAgICAgICAgaWYgKHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QocHJlZml4KSkge1xuICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cbiAgICAgICAgICBhZGQocHJlZml4LCB2KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArICdbJyArICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgPyBpIDogJycpICsgJ10nLCB2LCB0cmFkaXRpb25hbCwgYWRkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgb2JqLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG4gICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArICdbJyArIG5hbWUgKyAnXScsIG9ialtuYW1lXSwgdHJhZGl0aW9uYWwsIGFkZClcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG4gICAgICBhZGQocHJlZml4LCBvYmopXG4gICAgfVxuICB9XG5cbiAgcmVxd2VzdC5nZXRjYWxsYmFja1ByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2tQcmVmaXhcbiAgfVxuXG4gIC8vIGpRdWVyeSBhbmQgWmVwdG8gY29tcGF0aWJpbGl0eSwgZGlmZmVyZW5jZXMgY2FuIGJlIHJlbWFwcGVkIGhlcmUgc28geW91IGNhbiBjYWxsXG4gIC8vIC5hamF4LmNvbXBhdChvcHRpb25zLCBjYWxsYmFjaylcbiAgcmVxd2VzdC5jb21wYXQgPSBmdW5jdGlvbiAobywgZm4pIHtcbiAgICBpZiAobykge1xuICAgICAgb1sndHlwZSddICYmIChvWydtZXRob2QnXSA9IG9bJ3R5cGUnXSkgJiYgZGVsZXRlIG9bJ3R5cGUnXVxuICAgICAgb1snZGF0YVR5cGUnXSAmJiAob1sndHlwZSddID0gb1snZGF0YVR5cGUnXSlcbiAgICAgIG9bJ2pzb25wQ2FsbGJhY2snXSAmJiAob1snanNvbnBDYWxsYmFja05hbWUnXSA9IG9bJ2pzb25wQ2FsbGJhY2snXSkgJiYgZGVsZXRlIG9bJ2pzb25wQ2FsbGJhY2snXVxuICAgICAgb1snanNvbnAnXSAmJiAob1snanNvbnBDYWxsYmFjayddID0gb1snanNvbnAnXSlcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZXF3ZXN0KG8sIGZuKVxuICB9XG5cbiAgcmVxd2VzdC5hamF4U2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgZm9yICh2YXIgayBpbiBvcHRpb25zKSB7XG4gICAgICBnbG9iYWxTZXR1cE9wdGlvbnNba10gPSBvcHRpb25zW2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcXdlc3Rcbn0pO1xuIiwiLyohXG4gKiBAb3ZlcnZpZXcgUlNWUCAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vdGlsZGVpby9yc3ZwLmpzL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDMuMC4xOFxuICovXG5cbihmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCR1dGlscyQkaXNGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkdXRpbHMkJGlzTWF5YmVUaGVuYWJsZSh4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJHV0aWxzJCRfaXNBcnJheTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkpIHtcbiAgICAgIGxpYiRyc3ZwJHV0aWxzJCRfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkcnN2cCR1dGlscyQkX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIH1cblxuICAgIHZhciBsaWIkcnN2cCR1dGlscyQkaXNBcnJheSA9IGxpYiRyc3ZwJHV0aWxzJCRfaXNBcnJheTtcblxuICAgIHZhciBsaWIkcnN2cCR1dGlscyQkbm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHV0aWxzJCRGKCkgeyB9XG5cbiAgICB2YXIgbGliJHJzdnAkdXRpbHMkJG9fY3JlYXRlID0gKE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY29uZCBhcmd1bWVudCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG8gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBsaWIkcnN2cCR1dGlscyQkRi5wcm90b3R5cGUgPSBvO1xuICAgICAgcmV0dXJuIG5ldyBsaWIkcnN2cCR1dGlscyQkRigpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGV2ZW50cyQkaW5kZXhPZihjYWxsYmFja3MsIGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKHZhciBpPTAsIGw9Y2FsbGJhY2tzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrc1tpXSA9PT0gY2FsbGJhY2spIHsgcmV0dXJuIGk7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGV2ZW50cyQkY2FsbGJhY2tzRm9yKG9iamVjdCkge1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IG9iamVjdC5fcHJvbWlzZUNhbGxiYWNrcztcblxuICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgY2FsbGJhY2tzID0gb2JqZWN0Ll9wcm9taXNlQ2FsbGJhY2tzID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsYmFja3M7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJGV2ZW50cyQkZGVmYXVsdCA9IHtcblxuICAgICAgLyoqXG4gICAgICAgIGBSU1ZQLkV2ZW50VGFyZ2V0Lm1peGluYCBleHRlbmRzIGFuIG9iamVjdCB3aXRoIEV2ZW50VGFyZ2V0IG1ldGhvZHMuIEZvclxuICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuXG4gICAgICAgIFJTVlAuRXZlbnRUYXJnZXQubWl4aW4ob2JqZWN0KTtcblxuICAgICAgICBvYmplY3Qub24oJ2ZpbmlzaGVkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAvLyBoYW5kbGUgZXZlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0LnRyaWdnZXIoJ2ZpbmlzaGVkJywgeyBkZXRhaWw6IHZhbHVlIH0pO1xuICAgICAgICBgYGBcblxuICAgICAgICBgRXZlbnRUYXJnZXQubWl4aW5gIGFsc28gd29ya3Mgd2l0aCBwcm90b3R5cGVzOlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgdmFyIFBlcnNvbiA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIFJTVlAuRXZlbnRUYXJnZXQubWl4aW4oUGVyc29uLnByb3RvdHlwZSk7XG5cbiAgICAgICAgdmFyIHllaHVkYSA9IG5ldyBQZXJzb24oKTtcbiAgICAgICAgdmFyIHRvbSA9IG5ldyBQZXJzb24oKTtcblxuICAgICAgICB5ZWh1ZGEub24oJ3Bva2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdZZWh1ZGEgc2F5cyBPVycpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0b20ub24oJ3Bva2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdUb20gc2F5cyBPVycpO1xuICAgICAgICB9KTtcblxuICAgICAgICB5ZWh1ZGEudHJpZ2dlcigncG9rZScpO1xuICAgICAgICB0b20udHJpZ2dlcigncG9rZScpO1xuICAgICAgICBgYGBcblxuICAgICAgICBAbWV0aG9kIG1peGluXG4gICAgICAgIEBmb3IgUlNWUC5FdmVudFRhcmdldFxuICAgICAgICBAcHJpdmF0ZVxuICAgICAgICBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9iamVjdCB0byBleHRlbmQgd2l0aCBFdmVudFRhcmdldCBtZXRob2RzXG4gICAgICAqL1xuICAgICAgJ21peGluJzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdFsnb24nXSAgICAgID0gdGhpc1snb24nXTtcbiAgICAgICAgb2JqZWN0WydvZmYnXSAgICAgPSB0aGlzWydvZmYnXTtcbiAgICAgICAgb2JqZWN0Wyd0cmlnZ2VyJ10gPSB0aGlzWyd0cmlnZ2VyJ107XG4gICAgICAgIG9iamVjdC5fcHJvbWlzZUNhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuIGBldmVudE5hbWVgIGlzIHRyaWdnZXJlZFxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgb2JqZWN0Lm9uKCdldmVudCcsIGZ1bmN0aW9uKGV2ZW50SW5mbyl7XG4gICAgICAgICAgLy8gaGFuZGxlIHRoZSBldmVudFxuICAgICAgICB9KTtcblxuICAgICAgICBvYmplY3QudHJpZ2dlcignZXZlbnQnKTtcbiAgICAgICAgYGBgXG5cbiAgICAgICAgQG1ldGhvZCBvblxuICAgICAgICBAZm9yIFJTVlAuRXZlbnRUYXJnZXRcbiAgICAgICAgQHByaXZhdGVcbiAgICAgICAgQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICAqL1xuICAgICAgJ29uJzogZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgYWxsQ2FsbGJhY2tzID0gbGliJHJzdnAkZXZlbnRzJCRjYWxsYmFja3NGb3IodGhpcyksIGNhbGxiYWNrcztcblxuICAgICAgICBjYWxsYmFja3MgPSBhbGxDYWxsYmFja3NbZXZlbnROYW1lXTtcblxuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICAgIGNhbGxiYWNrcyA9IGFsbENhbGxiYWNrc1tldmVudE5hbWVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGliJHJzdnAkZXZlbnRzJCRpbmRleE9mKGNhbGxiYWNrcywgY2FsbGJhY2spID09PSAtMSkge1xuICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgIFlvdSBjYW4gdXNlIGBvZmZgIHRvIHN0b3AgZmlyaW5nIGEgcGFydGljdWxhciBjYWxsYmFjayBmb3IgYW4gZXZlbnQ6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICBmdW5jdGlvbiBkb1N0dWZmKCkgeyAvLyBkbyBzdHVmZiEgfVxuICAgICAgICBvYmplY3Qub24oJ3N0dWZmJywgZG9TdHVmZik7XG5cbiAgICAgICAgb2JqZWN0LnRyaWdnZXIoJ3N0dWZmJyk7IC8vIGRvU3R1ZmYgd2lsbCBiZSBjYWxsZWRcblxuICAgICAgICAvLyBVbnJlZ2lzdGVyIE9OTFkgdGhlIGRvU3R1ZmYgY2FsbGJhY2tcbiAgICAgICAgb2JqZWN0Lm9mZignc3R1ZmYnLCBkb1N0dWZmKTtcbiAgICAgICAgb2JqZWN0LnRyaWdnZXIoJ3N0dWZmJyk7IC8vIGRvU3R1ZmYgd2lsbCBOT1QgYmUgY2FsbGVkXG4gICAgICAgIGBgYFxuXG4gICAgICAgIElmIHlvdSBkb24ndCBwYXNzIGEgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBgb2ZmYCwgQUxMIGNhbGxiYWNrcyBmb3IgdGhlXG4gICAgICAgIGV2ZW50IHdpbGwgbm90IGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGV2ZW50IGZpcmVzLiBGb3IgZXhhbXBsZTpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBjYWxsYmFjazEgPSBmdW5jdGlvbigpe307XG4gICAgICAgIHZhciBjYWxsYmFjazIgPSBmdW5jdGlvbigpe307XG5cbiAgICAgICAgb2JqZWN0Lm9uKCdzdHVmZicsIGNhbGxiYWNrMSk7XG4gICAgICAgIG9iamVjdC5vbignc3R1ZmYnLCBjYWxsYmFjazIpO1xuXG4gICAgICAgIG9iamVjdC50cmlnZ2VyKCdzdHVmZicpOyAvLyBjYWxsYmFjazEgYW5kIGNhbGxiYWNrMiB3aWxsIGJlIGV4ZWN1dGVkLlxuXG4gICAgICAgIG9iamVjdC5vZmYoJ3N0dWZmJyk7XG4gICAgICAgIG9iamVjdC50cmlnZ2VyKCdzdHVmZicpOyAvLyBjYWxsYmFjazEgYW5kIGNhbGxiYWNrMiB3aWxsIG5vdCBiZSBleGVjdXRlZCFcbiAgICAgICAgYGBgXG5cbiAgICAgICAgQG1ldGhvZCBvZmZcbiAgICAgICAgQGZvciBSU1ZQLkV2ZW50VGFyZ2V0XG4gICAgICAgIEBwcml2YXRlXG4gICAgICAgIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgZXZlbnQgdG8gc3RvcCBsaXN0ZW5pbmcgdG9cbiAgICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgb3B0aW9uYWwgYXJndW1lbnQuIElmIGdpdmVuLCBvbmx5IHRoZSBmdW5jdGlvblxuICAgICAgICBnaXZlbiB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZXZlbnQncyBjYWxsYmFjayBxdWV1ZS4gSWYgbm8gYGNhbGxiYWNrYFxuICAgICAgICBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIGNhbGxiYWNrcyB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZXZlbnQncyBjYWxsYmFja1xuICAgICAgICBxdWV1ZS5cbiAgICAgICovXG4gICAgICAnb2ZmJzogZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgYWxsQ2FsbGJhY2tzID0gbGliJHJzdnAkZXZlbnRzJCRjYWxsYmFja3NGb3IodGhpcyksIGNhbGxiYWNrcywgaW5kZXg7XG5cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgIGFsbENhbGxiYWNrc1tldmVudE5hbWVdID0gW107XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2tzID0gYWxsQ2FsbGJhY2tzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgaW5kZXggPSBsaWIkcnN2cCRldmVudHMkJGluZGV4T2YoY2FsbGJhY2tzLCBjYWxsYmFjayk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkgeyBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTsgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgIFVzZSBgdHJpZ2dlcmAgdG8gZmlyZSBjdXN0b20gZXZlbnRzLiBGb3IgZXhhbXBsZTpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIG9iamVjdC5vbignZm9vJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICBjb25zb2xlLmxvZygnZm9vIGV2ZW50IGhhcHBlbmVkIScpO1xuICAgICAgICB9KTtcbiAgICAgICAgb2JqZWN0LnRyaWdnZXIoJ2ZvbycpO1xuICAgICAgICAvLyAnZm9vIGV2ZW50IGhhcHBlbmVkIScgbG9nZ2VkIHRvIHRoZSBjb25zb2xlXG4gICAgICAgIGBgYFxuXG4gICAgICAgIFlvdSBjYW4gYWxzbyBwYXNzIGEgdmFsdWUgYXMgYSBzZWNvbmQgYXJndW1lbnQgdG8gYHRyaWdnZXJgIHRoYXQgd2lsbCBiZVxuICAgICAgICBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gYWxsIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50OlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgb2JqZWN0Lm9uKCdmb28nLCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgY29uc29sZS5sb2codmFsdWUubmFtZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdC50cmlnZ2VyKCdmb28nLCB7IG5hbWU6ICdiYXInIH0pO1xuICAgICAgICAvLyAnYmFyJyBsb2dnZWQgdG8gdGhlIGNvbnNvbGVcbiAgICAgICAgYGBgXG5cbiAgICAgICAgQG1ldGhvZCB0cmlnZ2VyXG4gICAgICAgIEBmb3IgUlNWUC5FdmVudFRhcmdldFxuICAgICAgICBAcHJpdmF0ZVxuICAgICAgICBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIHRyaWdnZXJlZFxuICAgICAgICBAcGFyYW0ge0FueX0gb3B0aW9ucyBvcHRpb25hbCB2YWx1ZSB0byBiZSBwYXNzZWQgdG8gYW55IGV2ZW50IGhhbmRsZXJzIGZvclxuICAgICAgICB0aGUgZ2l2ZW4gYGV2ZW50TmFtZWBcbiAgICAgICovXG4gICAgICAndHJpZ2dlcic6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYWxsQ2FsbGJhY2tzID0gbGliJHJzdnAkZXZlbnRzJCRjYWxsYmFja3NGb3IodGhpcyksIGNhbGxiYWNrcywgY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrcyA9IGFsbENhbGxiYWNrc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgY2FjaGUgdGhlIGNhbGxiYWNrcy5sZW5ndGggc2luY2UgaXQgbWF5IGdyb3dcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8Y2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcblxuICAgICAgICAgICAgY2FsbGJhY2sob3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsaWIkcnN2cCRjb25maWckJGNvbmZpZyA9IHtcbiAgICAgIGluc3RydW1lbnQ6IGZhbHNlXG4gICAgfTtcblxuICAgIGxpYiRyc3ZwJGV2ZW50cyQkZGVmYXVsdFsnbWl4aW4nXShsaWIkcnN2cCRjb25maWckJGNvbmZpZyk7XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRjb25maWckJGNvbmZpZ3VyZShuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKG5hbWUgPT09ICdvbmVycm9yJykge1xuICAgICAgICAvLyBoYW5kbGUgZm9yIGxlZ2FjeSB1c2VycyB0aGF0IGV4cGVjdCB0aGUgYWN0dWFsXG4gICAgICAgIC8vIGVycm9yIHRvIGJlIHBhc3NlZCB0byB0aGVpciBmdW5jdGlvbiBhZGRlZCB2aWFcbiAgICAgICAgLy8gYFJTVlAuY29uZmlndXJlKCdvbmVycm9yJywgc29tZUZ1bmN0aW9uSGVyZSk7YFxuICAgICAgICBsaWIkcnN2cCRjb25maWckJGNvbmZpZ1snb24nXSgnZXJyb3InLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgbGliJHJzdnAkY29uZmlnJCRjb25maWdbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsaWIkcnN2cCRjb25maWckJGNvbmZpZ1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGliJHJzdnAkaW5zdHJ1bWVudCQkcXVldWUgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGluc3RydW1lbnQkJHNjaGVkdWxlRmx1c2goKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGliJHJzdnAkaW5zdHJ1bWVudCQkcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbnRyeSA9IGxpYiRyc3ZwJGluc3RydW1lbnQkJHF1ZXVlW2ldO1xuXG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBlbnRyeS5wYXlsb2FkO1xuXG4gICAgICAgICAgcGF5bG9hZC5ndWlkID0gcGF5bG9hZC5rZXkgKyBwYXlsb2FkLmlkO1xuICAgICAgICAgIHBheWxvYWQuY2hpbGRHdWlkID0gcGF5bG9hZC5rZXkgKyBwYXlsb2FkLmNoaWxkSWQ7XG4gICAgICAgICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcbiAgICAgICAgICAgIHBheWxvYWQuc3RhY2sgPSBwYXlsb2FkLmVycm9yLnN0YWNrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnWyd0cmlnZ2VyJ10oZW50cnkubmFtZSwgZW50cnkucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGliJHJzdnAkaW5zdHJ1bWVudCQkcXVldWUubGVuZ3RoID0gMDtcbiAgICAgIH0sIDUwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRpbnN0cnVtZW50JCRpbnN0cnVtZW50KGV2ZW50TmFtZSwgcHJvbWlzZSwgY2hpbGQpIHtcbiAgICAgIGlmICgxID09PSBsaWIkcnN2cCRpbnN0cnVtZW50JCRxdWV1ZS5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAga2V5OiBwcm9taXNlLl9ndWlkS2V5LFxuICAgICAgICAgICAgaWQ6ICBwcm9taXNlLl9pZCxcbiAgICAgICAgICAgIGV2ZW50TmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGV0YWlsOiBwcm9taXNlLl9yZXN1bHQsXG4gICAgICAgICAgICBjaGlsZElkOiBjaGlsZCAmJiBjaGlsZC5faWQsXG4gICAgICAgICAgICBsYWJlbDogcHJvbWlzZS5fbGFiZWwsXG4gICAgICAgICAgICB0aW1lU3RhbXA6IGxpYiRyc3ZwJHV0aWxzJCRub3coKSxcbiAgICAgICAgICAgIGVycm9yOiBsaWIkcnN2cCRjb25maWckJGNvbmZpZ1tcImluc3RydW1lbnQtd2l0aC1zdGFja1wiXSA/IG5ldyBFcnJvcihwcm9taXNlLl9sYWJlbCkgOiBudWxsXG4gICAgICAgICAgfX0pKSB7XG4gICAgICAgICAgICBsaWIkcnN2cCRpbnN0cnVtZW50JCRzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIHZhciBsaWIkcnN2cCRpbnN0cnVtZW50JCRkZWZhdWx0ID0gbGliJHJzdnAkaW5zdHJ1bWVudCQkaW5zdHJ1bWVudDtcblxuICAgIGZ1bmN0aW9uICBsaWIkcnN2cCQkaW50ZXJuYWwkJHdpdGhPd25Qcm9taXNlKCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJG5vb3AoKSB7fVxuXG4gICAgdmFyIGxpYiRyc3ZwJCRpbnRlcm5hbCQkUEVORElORyAgID0gdm9pZCAwO1xuICAgIHZhciBsaWIkcnN2cCQkaW50ZXJuYWwkJEZVTEZJTExFRCA9IDE7XG4gICAgdmFyIGxpYiRyc3ZwJCRpbnRlcm5hbCQkUkVKRUNURUQgID0gMjtcblxuICAgIHZhciBsaWIkcnN2cCQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SID0gbmV3IGxpYiRyc3ZwJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJCRpbnRlcm5hbCQkZ2V0VGhlbihwcm9taXNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBsaWIkcnN2cCQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmFzeW5jKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgPSBsaWIkcnN2cCQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgICAgIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIHRoZW5hYmxlLl9vbkVycm9yID0gbnVsbDtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSkge1xuICAgICAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0aGVuID0gbGliJHJzdnAkJGludGVybmFsJCRnZXRUaGVuKG1heWJlVGhlbmFibGUpO1xuXG4gICAgICAgIGlmICh0aGVuID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SKSB7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJHJzdnAkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpYiRyc3ZwJHV0aWxzJCRpc0Z1bmN0aW9uKHRoZW4pKSB7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobGliJHJzdnAkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fb25FcnJvcikge1xuICAgICAgICBwcm9taXNlLl9vbkVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJHJzdnAkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuXG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3N0YXRlID0gbGliJHJzdnAkJGludGVybmFsJCRGVUxGSUxMRUQ7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmluc3RydW1lbnQpIHtcbiAgICAgICAgICBsaWIkcnN2cCRpbnN0cnVtZW50JCRkZWZhdWx0KCdmdWxmaWxsZWQnLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJHJzdnAkY29uZmlnJCRjb25maWcuYXN5bmMobGliJHJzdnAkJGludGVybmFsJCRwdWJsaXNoLCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJHJzdnAkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkcnN2cCQkaW50ZXJuYWwkJFJFSkVDVEVEO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuICAgICAgbGliJHJzdnAkY29uZmlnJCRjb25maWcuYXN5bmMobGliJHJzdnAkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgICAgIHZhciBsZW5ndGggPSBzdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgICAgIHBhcmVudC5fb25FcnJvciA9IG51bGw7XG5cbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIGxpYiRyc3ZwJCRpbnRlcm5hbCQkRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkcnN2cCQkaW50ZXJuYWwkJFJFSkVDVEVEXSAgPSBvblJlamVjdGlvbjtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmFzeW5jKGxpYiRyc3ZwJCRpbnRlcm5hbCQkcHVibGlzaCwgcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSkge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gICAgICBpZiAobGliJHJzdnAkY29uZmlnJCRjb25maWcuaW5zdHJ1bWVudCkge1xuICAgICAgICBsaWIkcnN2cCRpbnN0cnVtZW50JCRkZWZhdWx0KHNldHRsZWQgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkRlVMRklMTEVEID8gJ2Z1bGZpbGxlZCcgOiAncmVqZWN0ZWQnLCBwcm9taXNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgdmFyIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCkge1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SID0gbmV3IGxpYiRyc3ZwJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgICAgICByZXR1cm4gbGliJHJzdnAkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBsaWIkcnN2cCR1dGlscyQkaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICAgICAgdmFsdWUsIGVycm9yLCBzdWNjZWVkZWQsIGZhaWxlZDtcblxuICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgIHZhbHVlID0gbGliJHJzdnAkJGludGVybmFsJCR0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJHJzdnAkJGludGVybmFsJCR3aXRoT3duUHJvbWlzZSgpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJHJzdnAkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgICAgIHZhciByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpe1xuICAgICAgICAgIGlmIChyZXNvbHZlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGVudW1lcmF0b3IkJG1ha2VTZXR0bGVkUmVzdWx0KHN0YXRlLCBwb3NpdGlvbiwgdmFsdWUpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gbGliJHJzdnAkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0ZTogJ2Z1bGZpbGxlZCcsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlOiAncmVqZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCwgYWJvcnRPblJlamVjdCwgbGFiZWwpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkcnN2cCQkaW50ZXJuYWwkJG5vb3AsIGxhYmVsKTtcbiAgICAgIHRoaXMuX2Fib3J0T25SZWplY3QgPSBhYm9ydE9uUmVqZWN0O1xuXG4gICAgICBpZiAodGhpcy5fdmFsaWRhdGVJbnB1dChpbnB1dCkpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgICAgID0gaW5wdXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgICB0aGlzLl9lbnVtZXJhdGUoKTtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QodGhpcy5wcm9taXNlLCB0aGlzLl92YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJGVudW1lcmF0b3IkJGRlZmF1bHQgPSBsaWIkcnN2cCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yO1xuXG4gICAgbGliJHJzdnAkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlSW5wdXQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIGxpYiRyc3ZwJHV0aWxzJCRpc0FycmF5KGlucHV0KTtcbiAgICB9O1xuXG4gICAgbGliJHJzdnAkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG4gICAgfTtcblxuICAgIGxpYiRyc3ZwJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICBsaWIkcnN2cCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoICA9IHRoaXMubGVuZ3RoO1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgICB2YXIgaW5wdXQgICA9IHRoaXMuX2lucHV0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgcHJvbWlzZS5fc3RhdGUgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJHJzdnAkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgICBpZiAobGliJHJzdnAkdXRpbHMkJGlzTWF5YmVUaGVuYWJsZShlbnRyeSkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmNvbnN0cnVjdG9yID09PSBjICYmIGVudHJ5Ll9zdGF0ZSAhPT0gbGliJHJzdnAkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgICAgZW50cnkuX29uRXJyb3IgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChjLnJlc29sdmUoZW50cnkpLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHRoaXMuX21ha2VSZXN1bHQobGliJHJzdnAkJGludGVybmFsJCRGVUxGSUxMRUQsIGksIGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJHJzdnAkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbGliJHJzdnAkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICAgIGlmICh0aGlzLl9hYm9ydE9uUmVqZWN0ICYmIHN0YXRlID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHRoaXMuX21ha2VSZXN1bHQoc3RhdGUsIGksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkcnN2cCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fbWFrZVJlc3VsdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBsaWIkcnN2cCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24ocHJvbWlzZSwgaSkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkcnN2cCQkaW50ZXJuYWwkJEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkcnN2cCQkaW50ZXJuYWwkJFJFSkVDVEVELCBpLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRwcm9taXNlJGFsbCQkYWxsKGVudHJpZXMsIGxhYmVsKSB7XG4gICAgICByZXR1cm4gbmV3IGxpYiRyc3ZwJGVudW1lcmF0b3IkJGRlZmF1bHQodGhpcywgZW50cmllcywgdHJ1ZSAvKiBhYm9ydCBvbiByZWplY3QgKi8sIGxhYmVsKS5wcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJHJzdnAkcHJvbWlzZSRhbGwkJGRlZmF1bHQgPSBsaWIkcnN2cCRwcm9taXNlJGFsbCQkYWxsO1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHByb21pc2UkcmFjZSQkcmFjZShlbnRyaWVzLCBsYWJlbCkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRyc3ZwJCRpbnRlcm5hbCQkbm9vcCwgbGFiZWwpO1xuXG4gICAgICBpZiAoIWxpYiRyc3ZwJHV0aWxzJCRpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRnVsZmlsbG1lbnQodmFsdWUpIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SZWplY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBwcm9taXNlLl9zdGF0ZSA9PT0gbGliJHJzdnAkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHN1YnNjcmliZShDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLCB1bmRlZmluZWQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkcnN2cCRwcm9taXNlJHJhY2UkJGRlZmF1bHQgPSBsaWIkcnN2cCRwcm9taXNlJHJhY2UkJHJhY2U7XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkcHJvbWlzZSRyZXNvbHZlJCRyZXNvbHZlKG9iamVjdCwgbGFiZWwpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJHJzdnAkJGludGVybmFsJCRub29wLCBsYWJlbCk7XG4gICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJHJzdnAkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0ID0gbGliJHJzdnAkcHJvbWlzZSRyZXNvbHZlJCRyZXNvbHZlO1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHByb21pc2UkcmVqZWN0JCRyZWplY3QocmVhc29uLCBsYWJlbCkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkcnN2cCQkaW50ZXJuYWwkJG5vb3AsIGxhYmVsKTtcbiAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0ID0gbGliJHJzdnAkcHJvbWlzZSRyZWplY3QkJHJlamVjdDtcblxuICAgIHZhciBsaWIkcnN2cCRwcm9taXNlJCRndWlkS2V5ID0gJ3JzdnBfJyArIGxpYiRyc3ZwJHV0aWxzJCRub3coKSArICctJztcbiAgICB2YXIgbGliJHJzdnAkcHJvbWlzZSQkY291bnRlciA9IDA7XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHByb21pc2UkJG5lZWRzTmV3KCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgICAgIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gICAgICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZeKAmXMgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICAgICAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgIFRlcm1pbm9sb2d5XG4gICAgICAtLS0tLS0tLS0tLVxuXG4gICAgICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgICAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAgICAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAgICAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gICAgICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gICAgICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICAgICAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gICAgICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICAgICAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICAgICAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgICAgIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICAgICAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICAgICAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gICAgICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gICAgICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gICAgICBCYXNpYyBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICBgYGBqc1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gb24gc3VjY2Vzc1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgICAgICAvLyBvbiBmYWlsdXJlXG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQWR2YW5jZWQgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICAgICAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gICAgICBgYGBqc1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICAgICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgICAgIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICAgICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgICAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBjbGFzcyBSU1ZQLlByb21pc2VcbiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gICAgICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEBjb25zdHJ1Y3RvclxuICAgICovXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkcHJvbWlzZSQkUHJvbWlzZShyZXNvbHZlciwgbGFiZWwpIHtcbiAgICAgIHRoaXMuX2lkID0gbGliJHJzdnAkcHJvbWlzZSQkY291bnRlcisrO1xuICAgICAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcbiAgICAgIHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgICAgaWYgKGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmluc3RydW1lbnQpIHtcbiAgICAgICAgbGliJHJzdnAkaW5zdHJ1bWVudCQkZGVmYXVsdCgnY3JlYXRlZCcsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGliJHJzdnAkJGludGVybmFsJCRub29wICE9PSByZXNvbHZlcikge1xuICAgICAgICBpZiAoIWxpYiRyc3ZwJHV0aWxzJCRpc0Z1bmN0aW9uKHJlc29sdmVyKSkge1xuICAgICAgICAgIGxpYiRyc3ZwJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBsaWIkcnN2cCRwcm9taXNlJCRQcm9taXNlKSkge1xuICAgICAgICAgIGxpYiRyc3ZwJHByb21pc2UkJG5lZWRzTmV3KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdCA9IGxpYiRyc3ZwJHByb21pc2UkJFByb21pc2U7XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgbGliJHJzdnAkcHJvbWlzZSQkUHJvbWlzZS5jYXN0ID0gbGliJHJzdnAkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0O1xuICAgIGxpYiRyc3ZwJHByb21pc2UkJFByb21pc2UuYWxsID0gbGliJHJzdnAkcHJvbWlzZSRhbGwkJGRlZmF1bHQ7XG4gICAgbGliJHJzdnAkcHJvbWlzZSQkUHJvbWlzZS5yYWNlID0gbGliJHJzdnAkcHJvbWlzZSRyYWNlJCRkZWZhdWx0O1xuICAgIGxpYiRyc3ZwJHByb21pc2UkJFByb21pc2UucmVzb2x2ZSA9IGxpYiRyc3ZwJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdDtcbiAgICBsaWIkcnN2cCRwcm9taXNlJCRQcm9taXNlLnJlamVjdCA9IGxpYiRyc3ZwJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0O1xuXG4gICAgbGliJHJzdnAkcHJvbWlzZSQkUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogbGliJHJzdnAkcHJvbWlzZSQkUHJvbWlzZSxcblxuICAgICAgX2d1aWRLZXk6IGxpYiRyc3ZwJHByb21pc2UkJGd1aWRLZXksXG5cbiAgICAgIF9vbkVycm9yOiBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmFzeW5jKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX29uRXJyb3IpIHtcbiAgICAgICAgICAgICAgbGliJHJzdnAkY29uZmlnJCRjb25maWdbJ3RyaWdnZXInXSgnZXJyb3InLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBDaGFpbmluZ1xuICAgICAgLS0tLS0tLS1cblxuICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgICAgfSk7XG4gICAgICBgYGBcbiAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFzc2ltaWxhdGlvblxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBTaW1wbGUgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcblxuICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kQXV0aG9yKCkuXG4gICAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgdGhlblxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgdGhlbjogZnVuY3Rpb24ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24sIGxhYmVsKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gbGliJHJzdnAkJGludGVybmFsJCRGVUxGSUxMRUQgJiYgIW9uRnVsZmlsbG1lbnQgfHwgc3RhdGUgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkUkVKRUNURUQgJiYgIW9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmluc3RydW1lbnQpIHtcbiAgICAgICAgICAgIGxpYiRyc3ZwJGluc3RydW1lbnQkJGRlZmF1bHQoJ2NoYWluZWQnLCB0aGlzLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQuX29uRXJyb3IgPSBudWxsO1xuXG4gICAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGxpYiRyc3ZwJCRpbnRlcm5hbCQkbm9vcCwgbGFiZWwpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyZW50Ll9yZXN1bHQ7XG5cbiAgICAgICAgaWYgKGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmluc3RydW1lbnQpIHtcbiAgICAgICAgICBsaWIkcnN2cCRpbnN0cnVtZW50JCRkZWZhdWx0KCdjaGFpbmVkJywgcGFyZW50LCBjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbc3RhdGUgLSAxXTtcbiAgICAgICAgICBsaWIkcnN2cCRjb25maWckJGNvbmZpZy5hc3luYyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCByZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBzeW5jaHJvbm91c1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEF1dGhvcigpO1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH1cblxuICAgICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIGNhdGNoXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGlvbiwgbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbiwgbGFiZWwpO1xuICAgICAgfSxcblxuICAgIC8qKlxuICAgICAgYGZpbmFsbHlgIHdpbGwgYmUgaW52b2tlZCByZWdhcmRsZXNzIG9mIHRoZSBwcm9taXNlJ3MgZmF0ZSBqdXN0IGFzIG5hdGl2ZVxuICAgICAgdHJ5L2NhdGNoL2ZpbmFsbHkgYmVoYXZlc1xuXG4gICAgICBTeW5jaHJvbm91cyBleGFtcGxlOlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZEF1dGhvcigpIHtcbiAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEF1dGhvcigpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gYWx3YXlzIHJ1bnNcbiAgICAgICAgLy8gZG9lc24ndCBhZmZlY3QgdGhlIHJldHVybiB2YWx1ZVxuICAgICAgfVxuICAgICAgYGBgXG5cbiAgICAgIEFzeW5jaHJvbm91cyBleGFtcGxlOlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gYXV0aG9yIHdhcyBlaXRoZXIgZm91bmQsIG9yIG5vdFxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCBmaW5hbGx5XG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICAnZmluYWxseSc6IGZ1bmN0aW9uKGNhbGxiYWNrLCBsYWJlbCkge1xuICAgICAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbGFiZWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRhbGwkc2V0dGxlZCQkQWxsU2V0dGxlZChDb25zdHJ1Y3RvciwgZW50cmllcywgbGFiZWwpIHtcbiAgICAgIHRoaXMuX3N1cGVyQ29uc3RydWN0b3IoQ29uc3RydWN0b3IsIGVudHJpZXMsIGZhbHNlIC8qIGRvbid0IGFib3J0IG9uIHJlamVjdCAqLywgbGFiZWwpO1xuICAgIH1cblxuICAgIGxpYiRyc3ZwJGFsbCRzZXR0bGVkJCRBbGxTZXR0bGVkLnByb3RvdHlwZSA9IGxpYiRyc3ZwJHV0aWxzJCRvX2NyZWF0ZShsaWIkcnN2cCRlbnVtZXJhdG9yJCRkZWZhdWx0LnByb3RvdHlwZSk7XG4gICAgbGliJHJzdnAkYWxsJHNldHRsZWQkJEFsbFNldHRsZWQucHJvdG90eXBlLl9zdXBlckNvbnN0cnVjdG9yID0gbGliJHJzdnAkZW51bWVyYXRvciQkZGVmYXVsdDtcbiAgICBsaWIkcnN2cCRhbGwkc2V0dGxlZCQkQWxsU2V0dGxlZC5wcm90b3R5cGUuX21ha2VSZXN1bHQgPSBsaWIkcnN2cCRlbnVtZXJhdG9yJCRtYWtlU2V0dGxlZFJlc3VsdDtcbiAgICBsaWIkcnN2cCRhbGwkc2V0dGxlZCQkQWxsU2V0dGxlZC5wcm90b3R5cGUuX3ZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignYWxsU2V0dGxlZCBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIGFycmF5Jyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGFsbCRzZXR0bGVkJCRhbGxTZXR0bGVkKGVudHJpZXMsIGxhYmVsKSB7XG4gICAgICByZXR1cm4gbmV3IGxpYiRyc3ZwJGFsbCRzZXR0bGVkJCRBbGxTZXR0bGVkKGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQsIGVudHJpZXMsIGxhYmVsKS5wcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJHJzdnAkYWxsJHNldHRsZWQkJGRlZmF1bHQgPSBsaWIkcnN2cCRhbGwkc2V0dGxlZCQkYWxsU2V0dGxlZDtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRhbGwkJGFsbChhcnJheSwgbGFiZWwpIHtcbiAgICAgIHJldHVybiBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LmFsbChhcnJheSwgbGFiZWwpO1xuICAgIH1cbiAgICB2YXIgbGliJHJzdnAkYWxsJCRkZWZhdWx0ID0gbGliJHJzdnAkYWxsJCRhbGw7XG4gICAgdmFyIGxpYiRyc3ZwJGFzYXAkJGxlbiA9IDA7XG4gICAgdmFyIGxpYiRyc3ZwJGFzYXAkJHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG4gICAgdmFyIGxpYiRyc3ZwJGFzYXAkJHZlcnR4TmV4dDtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRhc2FwJCRhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgIGxpYiRyc3ZwJGFzYXAkJHF1ZXVlW2xpYiRyc3ZwJGFzYXAkJGxlbl0gPSBjYWxsYmFjaztcbiAgICAgIGxpYiRyc3ZwJGFzYXAkJHF1ZXVlW2xpYiRyc3ZwJGFzYXAkJGxlbiArIDFdID0gYXJnO1xuICAgICAgbGliJHJzdnAkYXNhcCQkbGVuICs9IDI7XG4gICAgICBpZiAobGliJHJzdnAkYXNhcCQkbGVuID09PSAyKSB7XG4gICAgICAgIC8vIElmIGxlbiBpcyAxLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAgICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAgICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgICAgICBsaWIkcnN2cCRhc2FwJCRzY2hlZHVsZUZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJGFzYXAkJGRlZmF1bHQgPSBsaWIkcnN2cCRhc2FwJCRhc2FwO1xuXG4gICAgdmFyIGxpYiRyc3ZwJGFzYXAkJGJyb3dzZXJXaW5kb3cgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDogdW5kZWZpbmVkO1xuICAgIHZhciBsaWIkcnN2cCRhc2FwJCRicm93c2VyR2xvYmFsID0gbGliJHJzdnAkYXNhcCQkYnJvd3NlcldpbmRvdyB8fCB7fTtcbiAgICB2YXIgbGliJHJzdnAkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBsaWIkcnN2cCRhc2FwJCRicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgbGliJHJzdnAkYXNhcCQkYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgIHZhciBsaWIkcnN2cCRhc2FwJCRpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4gICAgLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbiAgICB2YXIgbGliJHJzdnAkYXNhcCQkaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBub2RlXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkYXNhcCQkdXNlTmV4dFRpY2soKSB7XG4gICAgICB2YXIgbmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgICAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gICAgICAvLyBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBpbnN0ZWFkXG4gICAgICB2YXIgdmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5tYXRjaCgvXig/OihcXGQrKVxcLik/KD86KFxcZCspXFwuKT8oXFwqfFxcZCspJC8pO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmVyc2lvbikgJiYgdmVyc2lvblsxXSA9PT0gJzAnICYmIHZlcnNpb25bMl0gPT09ICcxMCcpIHtcbiAgICAgICAgbmV4dFRpY2sgPSBzZXRJbW1lZGlhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIG5leHRUaWNrKGxpYiRyc3ZwJGFzYXAkJGZsdXNoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gdmVydHhcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRhc2FwJCR1c2VWZXJ0eFRpbWVyKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBsaWIkcnN2cCRhc2FwJCR2ZXJ0eE5leHQobGliJHJzdnAkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IGxpYiRyc3ZwJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGxpYiRyc3ZwJGFzYXAkJGZsdXNoKTtcbiAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgbm9kZS5kYXRhID0gKGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gd2ViIHdvcmtlclxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGliJHJzdnAkYXNhcCQkZmx1c2g7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRhc2FwJCR1c2VTZXRUaW1lb3V0KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGxpYiRyc3ZwJGFzYXAkJGZsdXNoLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJGFzYXAkJHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGFzYXAkJGZsdXNoKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaWIkcnN2cCRhc2FwJCRsZW47IGkrPTIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbGliJHJzdnAkYXNhcCQkcXVldWVbaV07XG4gICAgICAgIHZhciBhcmcgPSBsaWIkcnN2cCRhc2FwJCRxdWV1ZVtpKzFdO1xuXG4gICAgICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICAgICAgbGliJHJzdnAkYXNhcCQkcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxpYiRyc3ZwJGFzYXAkJHF1ZXVlW2krMV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGxpYiRyc3ZwJGFzYXAkJGxlbiA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkYXNhcCQkYXR0ZW1wdFZlcnRleCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByID0gcmVxdWlyZTtcbiAgICAgICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICAgICAgbGliJHJzdnAkYXNhcCQkdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIGxpYiRyc3ZwJGFzYXAkJHVzZVZlcnR4VGltZXIoKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gbGliJHJzdnAkYXNhcCQkdXNlU2V0VGltZW91dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaWIkcnN2cCRhc2FwJCRzY2hlZHVsZUZsdXNoO1xuICAgIC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG4gICAgaWYgKGxpYiRyc3ZwJGFzYXAkJGlzTm9kZSkge1xuICAgICAgbGliJHJzdnAkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRyc3ZwJGFzYXAkJHVzZU5leHRUaWNrKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkcnN2cCRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgbGliJHJzdnAkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRyc3ZwJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRyc3ZwJGFzYXAkJGlzV29ya2VyKSB7XG4gICAgICBsaWIkcnN2cCRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJHJzdnAkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRyc3ZwJGFzYXAkJGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGliJHJzdnAkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRyc3ZwJGFzYXAkJGF0dGVtcHRWZXJ0ZXgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGliJHJzdnAkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRyc3ZwJGFzYXAkJHVzZVNldFRpbWVvdXQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkZGVmZXIkJGRlZmVyKGxhYmVsKSB7XG4gICAgICB2YXIgZGVmZXJyZWQgPSB7IH07XG5cbiAgICAgIGRlZmVycmVkWydwcm9taXNlJ10gPSBuZXcgbGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZGVmZXJyZWRbJ3Jlc29sdmUnXSA9IHJlc29sdmU7XG4gICAgICAgIGRlZmVycmVkWydyZWplY3QnXSA9IHJlamVjdDtcbiAgICAgIH0sIGxhYmVsKTtcblxuICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgIH1cbiAgICB2YXIgbGliJHJzdnAkZGVmZXIkJGRlZmF1bHQgPSBsaWIkcnN2cCRkZWZlciQkZGVmZXI7XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkZmlsdGVyJCRmaWx0ZXIocHJvbWlzZXMsIGZpbHRlckZuLCBsYWJlbCkge1xuICAgICAgcmV0dXJuIGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQuYWxsKHByb21pc2VzLCBsYWJlbCkudGhlbihmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCFsaWIkcnN2cCR1dGlscyQkaXNGdW5jdGlvbihmaWx0ZXJGbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIGZpbHRlcidzIHNlY29uZCBhcmd1bWVudC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGZpbHRlcmVkID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpbHRlcmVkW2ldID0gZmlsdGVyRm4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LmFsbChmaWx0ZXJlZCwgbGFiZWwpLnRoZW4oZnVuY3Rpb24oZmlsdGVyZWQpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICAgIHZhciBuZXdMZW5ndGggPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZpbHRlcmVkW2ldKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHNbbmV3TGVuZ3RoXSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgbmV3TGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0cy5sZW5ndGggPSBuZXdMZW5ndGg7XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJGZpbHRlciQkZGVmYXVsdCA9IGxpYiRyc3ZwJGZpbHRlciQkZmlsdGVyO1xuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkcHJvbWlzZSRoYXNoJCRQcm9taXNlSGFzaChDb25zdHJ1Y3Rvciwgb2JqZWN0LCBsYWJlbCkge1xuICAgICAgdGhpcy5fc3VwZXJDb25zdHJ1Y3RvcihDb25zdHJ1Y3Rvciwgb2JqZWN0LCB0cnVlLCBsYWJlbCk7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJHByb21pc2UkaGFzaCQkZGVmYXVsdCA9IGxpYiRyc3ZwJHByb21pc2UkaGFzaCQkUHJvbWlzZUhhc2g7XG5cbiAgICBsaWIkcnN2cCRwcm9taXNlJGhhc2gkJFByb21pc2VIYXNoLnByb3RvdHlwZSA9IGxpYiRyc3ZwJHV0aWxzJCRvX2NyZWF0ZShsaWIkcnN2cCRlbnVtZXJhdG9yJCRkZWZhdWx0LnByb3RvdHlwZSk7XG4gICAgbGliJHJzdnAkcHJvbWlzZSRoYXNoJCRQcm9taXNlSGFzaC5wcm90b3R5cGUuX3N1cGVyQ29uc3RydWN0b3IgPSBsaWIkcnN2cCRlbnVtZXJhdG9yJCRkZWZhdWx0O1xuICAgIGxpYiRyc3ZwJHByb21pc2UkaGFzaCQkUHJvbWlzZUhhc2gucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZXN1bHQgPSB7fTtcbiAgICB9O1xuXG4gICAgbGliJHJzdnAkcHJvbWlzZSRoYXNoJCRQcm9taXNlSGFzaC5wcm90b3R5cGUuX3ZhbGlkYXRlSW5wdXQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCc7XG4gICAgfTtcblxuICAgIGxpYiRyc3ZwJHByb21pc2UkaGFzaCQkUHJvbWlzZUhhc2gucHJvdG90eXBlLl92YWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1Byb21pc2UuaGFzaCBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIG9iamVjdCcpO1xuICAgIH07XG5cbiAgICBsaWIkcnN2cCRwcm9taXNlJGhhc2gkJFByb21pc2VIYXNoLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICAgIHZhciBpbnB1dCAgID0gdGhpcy5faW5wdXQ7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJFBFTkRJTkcgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlucHV0LCBrZXkpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBrZXksXG4gICAgICAgICAgICBlbnRyeTogaW5wdXRba2V5XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSByZXN1bHRzLmxlbmd0aDtcbiAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGxlbmd0aDtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBwcm9taXNlLl9zdGF0ZSA9PT0gbGliJHJzdnAkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICB0aGlzLl9lYWNoRW50cnkocmVzdWx0LmVudHJ5LCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRoYXNoJHNldHRsZWQkJEhhc2hTZXR0bGVkKENvbnN0cnVjdG9yLCBvYmplY3QsIGxhYmVsKSB7XG4gICAgICB0aGlzLl9zdXBlckNvbnN0cnVjdG9yKENvbnN0cnVjdG9yLCBvYmplY3QsIGZhbHNlLCBsYWJlbCk7XG4gICAgfVxuXG4gICAgbGliJHJzdnAkaGFzaCRzZXR0bGVkJCRIYXNoU2V0dGxlZC5wcm90b3R5cGUgPSBsaWIkcnN2cCR1dGlscyQkb19jcmVhdGUobGliJHJzdnAkcHJvbWlzZSRoYXNoJCRkZWZhdWx0LnByb3RvdHlwZSk7XG4gICAgbGliJHJzdnAkaGFzaCRzZXR0bGVkJCRIYXNoU2V0dGxlZC5wcm90b3R5cGUuX3N1cGVyQ29uc3RydWN0b3IgPSBsaWIkcnN2cCRlbnVtZXJhdG9yJCRkZWZhdWx0O1xuICAgIGxpYiRyc3ZwJGhhc2gkc2V0dGxlZCQkSGFzaFNldHRsZWQucHJvdG90eXBlLl9tYWtlUmVzdWx0ID0gbGliJHJzdnAkZW51bWVyYXRvciQkbWFrZVNldHRsZWRSZXN1bHQ7XG5cbiAgICBsaWIkcnN2cCRoYXNoJHNldHRsZWQkJEhhc2hTZXR0bGVkLnByb3RvdHlwZS5fdmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdoYXNoU2V0dGxlZCBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIG9iamVjdCcpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRoYXNoJHNldHRsZWQkJGhhc2hTZXR0bGVkKG9iamVjdCwgbGFiZWwpIHtcbiAgICAgIHJldHVybiBuZXcgbGliJHJzdnAkaGFzaCRzZXR0bGVkJCRIYXNoU2V0dGxlZChsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LCBvYmplY3QsIGxhYmVsKS5wcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJHJzdnAkaGFzaCRzZXR0bGVkJCRkZWZhdWx0ID0gbGliJHJzdnAkaGFzaCRzZXR0bGVkJCRoYXNoU2V0dGxlZDtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRoYXNoJCRoYXNoKG9iamVjdCwgbGFiZWwpIHtcbiAgICAgIHJldHVybiBuZXcgbGliJHJzdnAkcHJvbWlzZSRoYXNoJCRkZWZhdWx0KGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQsIG9iamVjdCwgbGFiZWwpLnByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkcnN2cCRoYXNoJCRkZWZhdWx0ID0gbGliJHJzdnAkaGFzaCQkaGFzaDtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRtYXAkJG1hcChwcm9taXNlcywgbWFwRm4sIGxhYmVsKSB7XG4gICAgICByZXR1cm4gbGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdC5hbGwocHJvbWlzZXMsIGxhYmVsKS50aGVuKGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICBpZiAoIWxpYiRyc3ZwJHV0aWxzJCRpc0Z1bmN0aW9uKG1hcEZuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgbWFwJ3Mgc2Vjb25kIGFyZ3VtZW50LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRzW2ldID0gbWFwRm4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LmFsbChyZXN1bHRzLCBsYWJlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJG1hcCQkZGVmYXVsdCA9IGxpYiRyc3ZwJG1hcCQkbWFwO1xuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkbm9kZSQkUmVzdWx0KCkge1xuICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgbGliJHJzdnAkbm9kZSQkRVJST1IgPSBuZXcgbGliJHJzdnAkbm9kZSQkUmVzdWx0KCk7XG4gICAgdmFyIGxpYiRyc3ZwJG5vZGUkJEdFVF9USEVOX0VSUk9SID0gbmV3IGxpYiRyc3ZwJG5vZGUkJFJlc3VsdCgpO1xuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkbm9kZSQkZ2V0VGhlbihvYmopIHtcbiAgICAgIHRyeSB7XG4gICAgICAgcmV0dXJuIG9iai50aGVuO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBsaWIkcnN2cCRub2RlJCRFUlJPUi52YWx1ZT0gZXJyb3I7XG4gICAgICAgIHJldHVybiBsaWIkcnN2cCRub2RlJCRFUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJG5vZGUkJHRyeUFwcGx5KGYsIHMsIGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGYuYXBwbHkocywgYSk7XG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIGxpYiRyc3ZwJG5vZGUkJEVSUk9SLnZhbHVlID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBsaWIkcnN2cCRub2RlJCRFUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRub2RlJCRtYWtlT2JqZWN0KF8sIGFyZ3VtZW50TmFtZXMpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHZhciBuYW1lO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuZ3RoID0gXy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGxlbmd0aDsgeCsrKSB7XG4gICAgICAgIGFyZ3NbeF0gPSBfW3hdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lID0gYXJndW1lbnROYW1lc1tpXTtcbiAgICAgICAgb2JqW25hbWVdID0gYXJnc1tpICsgMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkbm9kZSQkYXJyYXlSZXN1bHQoXykge1xuICAgICAgdmFyIGxlbmd0aCA9IF8ubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuZ3RoIC0gMSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBfW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRub2RlJCR3cmFwVGhlbmFibGUodGhlbiwgcHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhlbjogZnVuY3Rpb24ob25GdWxGaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhlbi5jYWxsKHByb21pc2UsIG9uRnVsRmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRub2RlJCRkZW5vZGVpZnkobm9kZUZ1bmMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCArIDEpO1xuICAgICAgICB2YXIgYXJnO1xuICAgICAgICB2YXIgcHJvbWlzZUlucHV0ID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICBpZiAoIXByb21pc2VJbnB1dCkge1xuICAgICAgICAgICAgLy8gVE9ETzogY2xlYW4gdGhpcyB1cFxuICAgICAgICAgICAgcHJvbWlzZUlucHV0ID0gbGliJHJzdnAkbm9kZSQkbmVlZHNQcm9taXNlSW5wdXQoYXJnKTtcbiAgICAgICAgICAgIGlmIChwcm9taXNlSW5wdXQgPT09IGxpYiRyc3ZwJG5vZGUkJEdFVF9USEVOX0VSUk9SKSB7XG4gICAgICAgICAgICAgIHZhciBwID0gbmV3IGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQobGliJHJzdnAkJGludGVybmFsJCRub29wKTtcbiAgICAgICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocCwgbGliJHJzdnAkbm9kZSQkR0VUX1RIRU5fRVJST1IudmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvbWlzZUlucHV0ICYmIHByb21pc2VJbnB1dCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBhcmcgPSBsaWIkcnN2cCRub2RlJCR3cmFwVGhlbmFibGUocHJvbWlzZUlucHV0LCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhcmdzW2ldID0gYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgbGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdChsaWIkcnN2cCQkaW50ZXJuYWwkJG5vb3ApO1xuXG4gICAgICAgIGFyZ3NbbF0gPSBmdW5jdGlvbihlcnIsIHZhbCkge1xuICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnIpO1xuICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWwpO1xuICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHRydWUpXG4gICAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgbGliJHJzdnAkbm9kZSQkYXJyYXlSZXN1bHQoYXJndW1lbnRzKSk7XG4gICAgICAgICAgZWxzZSBpZiAobGliJHJzdnAkdXRpbHMkJGlzQXJyYXkob3B0aW9ucykpXG4gICAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgbGliJHJzdnAkbm9kZSQkbWFrZU9iamVjdChhcmd1bWVudHMsIG9wdGlvbnMpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocHJvbWlzZUlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGxpYiRyc3ZwJG5vZGUkJGhhbmRsZVByb21pc2VJbnB1dChwcm9taXNlLCBhcmdzLCBub2RlRnVuYywgc2VsZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGxpYiRyc3ZwJG5vZGUkJGhhbmRsZVZhbHVlSW5wdXQocHJvbWlzZSwgYXJncywgbm9kZUZ1bmMsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmbi5fX3Byb3RvX18gPSBub2RlRnVuYztcblxuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cblxuICAgIHZhciBsaWIkcnN2cCRub2RlJCRkZWZhdWx0ID0gbGliJHJzdnAkbm9kZSQkZGVub2RlaWZ5O1xuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkbm9kZSQkaGFuZGxlVmFsdWVJbnB1dChwcm9taXNlLCBhcmdzLCBub2RlRnVuYywgc2VsZikge1xuICAgICAgdmFyIHJlc3VsdCA9IGxpYiRyc3ZwJG5vZGUkJHRyeUFwcGx5KG5vZGVGdW5jLCBzZWxmLCBhcmdzKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGxpYiRyc3ZwJG5vZGUkJEVSUk9SKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRub2RlJCRoYW5kbGVQcm9taXNlSW5wdXQocHJvbWlzZSwgYXJncywgbm9kZUZ1bmMsIHNlbGYpe1xuICAgICAgcmV0dXJuIGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQuYWxsKGFyZ3MpLnRoZW4oZnVuY3Rpb24oYXJncyl7XG4gICAgICAgIHZhciByZXN1bHQgPSBsaWIkcnN2cCRub2RlJCR0cnlBcHBseShub2RlRnVuYywgc2VsZiwgYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGxpYiRyc3ZwJG5vZGUkJEVSUk9SKSB7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJG5vZGUkJG5lZWRzUHJvbWlzZUlucHV0KGFyZykge1xuICAgICAgaWYgKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGxpYiRyc3ZwJG5vZGUkJGdldFRoZW4oYXJnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRyYWNlJCRyYWNlKGFycmF5LCBsYWJlbCkge1xuICAgICAgcmV0dXJuIGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQucmFjZShhcnJheSwgbGFiZWwpO1xuICAgIH1cbiAgICB2YXIgbGliJHJzdnAkcmFjZSQkZGVmYXVsdCA9IGxpYiRyc3ZwJHJhY2UkJHJhY2U7XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkcmVqZWN0JCRyZWplY3QocmVhc29uLCBsYWJlbCkge1xuICAgICAgcmV0dXJuIGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQucmVqZWN0KHJlYXNvbiwgbGFiZWwpO1xuICAgIH1cbiAgICB2YXIgbGliJHJzdnAkcmVqZWN0JCRkZWZhdWx0ID0gbGliJHJzdnAkcmVqZWN0JCRyZWplY3Q7XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkcmVzb2x2ZSQkcmVzb2x2ZSh2YWx1ZSwgbGFiZWwpIHtcbiAgICAgIHJldHVybiBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LnJlc29sdmUodmFsdWUsIGxhYmVsKTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJHJlc29sdmUkJGRlZmF1bHQgPSBsaWIkcnN2cCRyZXNvbHZlJCRyZXNvbHZlO1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHJldGhyb3ckJHJldGhyb3cocmVhc29uKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICB9KTtcbiAgICAgIHRocm93IHJlYXNvbjtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJHJldGhyb3ckJGRlZmF1bHQgPSBsaWIkcnN2cCRyZXRocm93JCRyZXRocm93O1xuXG4gICAgLy8gZGVmYXVsdCBhc3luYyBpcyBhc2FwO1xuICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmFzeW5jID0gbGliJHJzdnAkYXNhcCQkZGVmYXVsdDtcbiAgICB2YXIgbGliJHJzdnAkJGNhc3QgPSBsaWIkcnN2cCRyZXNvbHZlJCRkZWZhdWx0O1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJCRhc3luYyhjYWxsYmFjaywgYXJnKSB7XG4gICAgICBsaWIkcnN2cCRjb25maWckJGNvbmZpZy5hc3luYyhjYWxsYmFjaywgYXJnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkb24oKSB7XG4gICAgICBsaWIkcnN2cCRjb25maWckJGNvbmZpZ1snb24nXS5hcHBseShsaWIkcnN2cCRjb25maWckJGNvbmZpZywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkb2ZmKCkge1xuICAgICAgbGliJHJzdnAkY29uZmlnJCRjb25maWdbJ29mZiddLmFwcGx5KGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFNldCB1cCBpbnN0cnVtZW50YXRpb24gdGhyb3VnaCBgd2luZG93Ll9fUFJPTUlTRV9JTlRSVU1FTlRBVElPTl9fYFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93WydfX1BST01JU0VfSU5TVFJVTUVOVEFUSU9OX18nXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsaWIkcnN2cCQkY2FsbGJhY2tzID0gd2luZG93WydfX1BST01JU0VfSU5TVFJVTUVOVEFUSU9OX18nXTtcbiAgICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlndXJlKCdpbnN0cnVtZW50JywgdHJ1ZSk7XG4gICAgICBmb3IgKHZhciBsaWIkcnN2cCQkZXZlbnROYW1lIGluIGxpYiRyc3ZwJCRjYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKGxpYiRyc3ZwJCRjYWxsYmFja3MuaGFzT3duUHJvcGVydHkobGliJHJzdnAkJGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICBsaWIkcnN2cCQkb24obGliJHJzdnAkJGV2ZW50TmFtZSwgbGliJHJzdnAkJGNhbGxiYWNrc1tsaWIkcnN2cCQkZXZlbnROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGliJHJzdnAkdW1kJCRSU1ZQID0ge1xuICAgICAgJ3JhY2UnOiBsaWIkcnN2cCRyYWNlJCRkZWZhdWx0LFxuICAgICAgJ1Byb21pc2UnOiBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LFxuICAgICAgJ2FsbFNldHRsZWQnOiBsaWIkcnN2cCRhbGwkc2V0dGxlZCQkZGVmYXVsdCxcbiAgICAgICdoYXNoJzogbGliJHJzdnAkaGFzaCQkZGVmYXVsdCxcbiAgICAgICdoYXNoU2V0dGxlZCc6IGxpYiRyc3ZwJGhhc2gkc2V0dGxlZCQkZGVmYXVsdCxcbiAgICAgICdkZW5vZGVpZnknOiBsaWIkcnN2cCRub2RlJCRkZWZhdWx0LFxuICAgICAgJ29uJzogbGliJHJzdnAkJG9uLFxuICAgICAgJ29mZic6IGxpYiRyc3ZwJCRvZmYsXG4gICAgICAnbWFwJzogbGliJHJzdnAkbWFwJCRkZWZhdWx0LFxuICAgICAgJ2ZpbHRlcic6IGxpYiRyc3ZwJGZpbHRlciQkZGVmYXVsdCxcbiAgICAgICdyZXNvbHZlJzogbGliJHJzdnAkcmVzb2x2ZSQkZGVmYXVsdCxcbiAgICAgICdyZWplY3QnOiBsaWIkcnN2cCRyZWplY3QkJGRlZmF1bHQsXG4gICAgICAnYWxsJzogbGliJHJzdnAkYWxsJCRkZWZhdWx0LFxuICAgICAgJ3JldGhyb3cnOiBsaWIkcnN2cCRyZXRocm93JCRkZWZhdWx0LFxuICAgICAgJ2RlZmVyJzogbGliJHJzdnAkZGVmZXIkJGRlZmF1bHQsXG4gICAgICAnRXZlbnRUYXJnZXQnOiBsaWIkcnN2cCRldmVudHMkJGRlZmF1bHQsXG4gICAgICAnY29uZmlndXJlJzogbGliJHJzdnAkY29uZmlnJCRjb25maWd1cmUsXG4gICAgICAnYXN5bmMnOiBsaWIkcnN2cCQkYXN5bmNcbiAgICB9O1xuXG4gICAgLyogZ2xvYmFsIGRlZmluZTp0cnVlIG1vZHVsZTp0cnVlIHdpbmRvdzogdHJ1ZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGxpYiRyc3ZwJHVtZCQkUlNWUDsgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGVbJ2V4cG9ydHMnXSkge1xuICAgICAgbW9kdWxlWydleHBvcnRzJ10gPSBsaWIkcnN2cCR1bWQkJFJTVlA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNbJ1JTVlAnXSA9IGxpYiRyc3ZwJHVtZCQkUlNWUDtcbiAgICB9XG59KS5jYWxsKHRoaXMpO1xuXG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguMlxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUNyZWF0ZSAgICAgICA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuOC4yJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcbiAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCB1bmRlZmluZWRPbmx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIXVuZGVmaW5lZE9ubHkgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIHZhciBiYXNlQ3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgdGFyZ2V0LCB0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInICYmIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gaW5wdXQgJiYgaW5wdXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuemlwKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ29tcGxlbWVudCBvZiBfLnppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXNcbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCAnbGVuZ3RoJykubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QgJiYgbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkgJiYgYXJyYXkubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgPT0gJ251bWJlcicpIHtcbiAgICAgIGkgPSBpc1NvcnRlZCA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBpc1NvcnRlZCkgOiBpc1NvcnRlZDtcbiAgICB9IGVsc2UgaWYgKGlzU29ydGVkICYmIGxlbmd0aCkge1xuICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgIH1cbiAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgcmV0dXJuIF8uZmluZEluZGV4KHNsaWNlLmNhbGwoYXJyYXksIGkpLCBfLmlzTmFOKTtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICBpZiAodHlwZW9mIGZyb20gPT0gJ251bWJlcicpIHtcbiAgICAgIGlkeCA9IGZyb20gPCAwID8gaWR4ICsgZnJvbSArIDEgOiBNYXRoLm1pbihpZHgsIGZyb20gKyAxKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmZpbmRMYXN0SW5kZXgoc2xpY2UuY2FsbChhcnJheSwgMCwgaWR4KSwgXy5pc05hTik7XG4gICAgfVxuICAgIHdoaWxlICgtLWlkeCA+PSAwKSBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSAhPSBudWxsICYmIGFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb24gYW4gYXJyYXktbGlrZSB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEluZGV4ID0gY3JlYXRlSW5kZXhGaW5kZXIoMSk7XG5cbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICBcbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcbiAgXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCJcbnZhciBybmc7XG5cbmlmIChnbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHJuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzOCk7XG4gICAgcmV0dXJuIF9ybmRzODtcbiAgfTtcbn1cblxuaWYgKCFybmcpIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgIF9ybmRzID0gbmV3IEFycmF5KDE2KTtcbiAgcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIF9ybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBfcm5kcztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBybmc7XG5cbiIsIi8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4vLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcbnZhciBfcm5nID0gcmVxdWlyZSgnLi9ybmcnKTtcblxuLy8gTWFwcyBmb3IgbnVtYmVyIDwtPiBoZXggc3RyaW5nIGNvbnZlcnNpb25cbnZhciBfYnl0ZVRvSGV4ID0gW107XG52YXIgX2hleFRvQnl0ZSA9IHt9O1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBfYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgX2hleFRvQnl0ZVtfYnl0ZVRvSGV4W2ldXSA9IGk7XG59XG5cbi8vICoqYHBhcnNlKClgIC0gUGFyc2UgYSBVVUlEIGludG8gaXQncyBjb21wb25lbnQgYnl0ZXMqKlxuZnVuY3Rpb24gcGFyc2UocywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSAoYnVmICYmIG9mZnNldCkgfHwgMCwgaWkgPSAwO1xuXG4gIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uKG9jdCkge1xuICAgIGlmIChpaSA8IDE2KSB7IC8vIERvbid0IG92ZXJmbG93IVxuICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gIHdoaWxlIChpaSA8IDE2KSB7XG4gICAgYnVmW2kgKyBpaSsrXSA9IDA7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG4vLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbmZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMCwgYnRoID0gX2J5dGVUb0hleDtcbiAgcmV0dXJuICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG59XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbnZhciBfc2VlZEJ5dGVzID0gX3JuZygpO1xuXG4vLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbnZhciBfbm9kZUlkID0gW1xuICBfc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XVxuXTtcblxuLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbnZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwLCBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyBuKyspIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogdW5wYXJzZShiKTtcbn1cblxuLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7IGlpKyspIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCB1bnBhcnNlKHJuZHMpO1xufVxuXG4vLyBFeHBvcnQgcHVibGljIEFQSVxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcbnV1aWQucGFyc2UgPSBwYXJzZTtcbnV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIENvbnN0YW50cyA9IHt9O1xyXG5Db25zdGFudHMuRGVmYXVsdFRha2VJdGVtc0NvdW50ID0gNTA7XHJcbkNvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZSA9ICdFeHBhbmQnO1xyXG5Db25zdGFudHMuUmV0dXJuQXNGaWVsZE5hbWUgPSAnUmV0dXJuQXMnO1xyXG5Db25zdGFudHMuRmllbGRzRXhwcmVzc2lvbk5hbWUgPSAnRmllbGRzJztcclxuQ29uc3RhbnRzLlNpbmdsZUZpZWxkRXhwcmVzc2lvbk5hbWUgPSAnU2luZ2xlRmllbGQnO1xyXG5Db25zdGFudHMuU29ydEV4cHJlc3Npb25OYW1lID0gJ1NvcnQnO1xyXG5Db25zdGFudHMuRmlsdGVyRXhwcmVzc2lvbk5hbWUgPSAnRmlsdGVyJztcclxuQ29uc3RhbnRzLlNraXBFeHByZXNzaW9uTmFtZSA9ICdTa2lwJztcclxuQ29uc3RhbnRzLlRha2VFeHByZXNzaW9uTmFtZSA9ICdUYWtlJztcclxuQ29uc3RhbnRzLlBhcmVudFJlbGF0aW9uRmllbGROYW1lID0gJ1BhcmVudFJlbGF0aW9uRmllbGQnO1xyXG5Db25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQgPSAnSWQnO1xyXG5Db25zdGFudHMuVGFyZ2V0VHlwZU5hbWVGaWVsZE5hbWUgPSAnVGFyZ2V0VHlwZU5hbWUnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb25zdGFudHM7IiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9Db25zdGFudHMnKTtcclxuXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgaXMgdXNlZCB0byBnZXQgYWxsIHJlcXVpcmVkIGluZm9ybWF0aW9uIGluIG9yZGVyIHRvIHByb2Nlc3MgYSBzZXQgb2YgcmVsYXRpb25zLlxyXG4gKiBAcGFyYW0gcGFyZW50IC0gQW4gRXhlY3V0aW9uTm9kZSBpbnN0YW5jZSB1c2VkIHRvIHN1cHBseSB0aGUgdHJlZSBsaWtlIGRhdGEgc3RydWN0dXJlLlxyXG4gKiBAcGFyYW0gcmVsYXRpb25Ob2RlIC0gVGhlIHJlbGF0aW9uIG5vZGUgdXNlZCB0byBjcmVhdGVkIHRoZSBFeGVjdXRpb25Ob2RlIGluc3RhbmNlIChFeGVjdXRpb25Ob2RlIGluc3RhbmNlIHNob3VsZCBjb250YWluIG9uZSBvciBtYW55IHJlbGF0aW9uc1xyXG4gKiBpZiB0aGV5IGNhbiBiZSBjb21iaW5lZCBmb3IgYmF0Y2ggZXhlY3V0aW9uKS5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRXhlY3V0aW9uTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHJlbGF0aW9uTm9kZSkge1xyXG4gICAgdmFyIHBhcmVudFBhdGggPSAnJztcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnRQYXRoID0gcGFyZW50LnBhdGg7XHJcbiAgICB9XHJcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFBhdGg7XHJcbiAgICB0aGlzLnJlbGF0aW9ucyA9IFtyZWxhdGlvbk5vZGUucGF0aF07XHJcbiAgICB0aGlzLm5hbWUgPSByZWxhdGlvbk5vZGUucGF0aDtcclxuICAgIHRoaXMudGFyZ2V0VHlwZU5hbWUgPSByZWxhdGlvbk5vZGUudGFyZ2V0VHlwZU5hbWU7XHJcbiAgICB0aGlzLmNhbkFkZE90aGVyUmVsYXRpb25zID0gIXJlbGF0aW9uTm9kZS5maWx0ZXJFeHByZXNzaW9uICYmICFyZWxhdGlvbk5vZGUuc29ydEV4cHJlc3Npb24gJiYgIXJlbGF0aW9uTm9kZS50YWtlICYmICFyZWxhdGlvbk5vZGUuc2tpcDtcclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgIHZhciBwYXRoID0gJyc7XHJcbiAgICBpZiAocGFyZW50UGF0aCkge1xyXG4gICAgICAgIHBhdGggKz0gcGFyZW50UGF0aCArICcuJztcclxuICAgIH1cclxuICAgIHBhdGggKz0gcmVsYXRpb25Ob2RlLnRhcmdldFR5cGVOYW1lO1xyXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnNlcnRzIGEgUmVsYXRpb25Ob2RlIHRvIGFuIEV4ZWN1dGlvbk5vZGUuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIEEgUmVsYXRpb24gaW5zdGFuY2UuXHJcbiAqL1xyXG5FeGVjdXRpb25Ob2RlLnByb3RvdHlwZS5pbnNlcnRSZWxhdGlvbk5vZGUgPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIHRoaXMucmVsYXRpb25zLnB1c2gocmVsYXRpb24ucGF0aCk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zZXJ0cyBhIGNoaWxkIG5vZGUgKHdoaWNoIHJlbGF0aW9ucykgZGVwZW5kcyBmcm9tIHBhcmVudCBub2RlIHJlc3VsdC5cclxuICogQHBhcmFtIGNoaWxkIC0gRXhlY3V0aW9uTm9kZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgY2hpbGQgbm9kZS5cclxuICovXHJcbkV4ZWN1dGlvbk5vZGUucHJvdG90eXBlLmluc2VydENoaWxkcmVuTm9kZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkLm5hbWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBtZXRob2QgdGhhdCBjaGVja3MgaWYgc29tZSByZWxhdGlvbnMgY291bGQgYmUgY29tYmluZWQgKGZvciBleGFtcGxlIGhhdmUgc2FtZSBUYXJnZXRUeXBlKS5cclxuICogQHBhcmFtIHJlbGF0aW9uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuRXhlY3V0aW9uTm9kZS5wcm90b3R5cGUuY2FuQ29tYmluZVdpdGhSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xyXG4gICAgLy9UT0RPOiB0aGluayBzb21lIG1vcmUgPyFcclxuICAgIGlmICghdGhpcy5jYW5BZGRPdGhlclJlbGF0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy50YXJnZXRUeXBlTmFtZSA9PT0gcmVsYXRpb24udGFyZ2V0VHlwZU5hbWUgJiYgIXJlbGF0aW9uLmZpbHRlckV4cHJlc3Npb24gJiYgIXJlbGF0aW9uLnNvcnRFeHByZXNzaW9uICYmICFyZWxhdGlvbi50YWtlICYmICFyZWxhdGlvbi5za2lwO1xyXG59O1xyXG5cclxuLyoqIEV4ZWN1dGlvblRyZWVcclxuICogQ2xhc3MgdGhhdCBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGFuIGV4ZWN1dGlvbiB0cmVlIGZyb20gYSByZWxhdGlvblRyZWUuIFVzZWQgdG8gcHJvY2VzcyBhbGwgcXVlcmllcyAobWFzdGVyIGFuZCBjaGlsZCkgaW4gYSBjb3JyZWN0IG9yZGVyLlxyXG4gKiBAcGFyYW0gcmVsYXRpb25UcmVlIC0gQW4gaW5zdGFuY2Ugb2YgcmVsYXRpb24gdHJlZS5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRXhlY3V0aW9uVHJlZSA9IGZ1bmN0aW9uIChyZWxhdGlvblRyZWUpIHtcclxuICAgIHRoaXMuX3JlbGF0aW9uVHJlZSA9IHJlbGF0aW9uVHJlZTtcclxuICAgIHRoaXMuX21hcCA9IHt9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgZXhlY3V0aW9uIG5vZGUgdG8gdGhlIEV4ZWN1dGlvblRyZWUuXHJcbiAqIEBwYXJhbSBleGVjdXRpb25Ob2RlXHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5hZGRFeGVjdXRpb25Ob2RlID0gZnVuY3Rpb24gKGV4ZWN1dGlvbk5vZGUpIHtcclxuICAgIHRoaXMuX21hcFtleGVjdXRpb25Ob2RlLm5hbWVdID0gZXhlY3V0aW9uTm9kZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kcyB0aGUgRXhlY3V0aW9uTm9kZSB3aGljaCBjb250YWlucyB0aGUgcmVxdWVzdGVkIHJlbGF0aW9uLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIFJlbGF0aW9uIGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldEV4ZWN1dGlvbk5vZGVPZlJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICBmb3IgKHZhciBleGVjTm9kZSBpbiB0aGlzLl9tYXApIHtcclxuICAgICAgICBpZiAodGhpcy5fbWFwLmhhc093blByb3BlcnR5KGV4ZWNOb2RlKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwW2V4ZWNOb2RlXS5yZWxhdGlvbnMuaW5kZXhPZihyZWxhdGlvbikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcFtleGVjTm9kZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kcyBhIFJlbGF0aW9uTm9kZSB3aXRoaW4gdGhlIFJlbGF0aW9uVHJlZS5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gU3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVsYXRpb24gd2l0aGluIHRoZSBSZWxhdGlvblRyZWUgKGZvciBleGFtcGxlOiBBY3Rpdml0aWVzLkxpa2VzLlJvbGUpLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldFJlbGF0aW9uTm9kZSA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xyXG4gICAgaWYgKHJlbGF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGF0aW9uVHJlZVtyZWxhdGlvbl0gfHwgbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5nZXRSb290UmVsYXRpb25Ob2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JlbGF0aW9uVHJlZVt0aGlzLl9yZWxhdGlvblRyZWUuJHJvb3RdIHx8IG51bGw7XHJcbn07XHJcbi8qKlxyXG4gKiBCdWlsZHMgdGhlIEV4ZWN1dGlvblRyZWUgZnJvbSBhIFJlbGF0aW9uVHJlZS5cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy9idWlsZCBiZWdpbm5pbmcgZnJvbSB0aGUgcm9vdFxyXG4gICAgdmFyIHJlbGF0aW9uUm9vdCA9IHRoaXMuZ2V0UmVsYXRpb25Ob2RlKHRoaXMuX3JlbGF0aW9uVHJlZS4kcm9vdCk7XHJcbiAgICAvL1NldHVwIHRoZSByb290IG9mIHRoZSBleGVjdXRpb24gdHJlZS5cclxuICAgIHZhciByb290RXhlY3V0aW9uTm9kZSA9IG5ldyBFeGVjdXRpb25Ob2RlKG51bGwsIHJlbGF0aW9uUm9vdCk7Ly9ubyBwYXJlbnQgbm9kZVxyXG4gICAgdGhpcy5hZGRFeGVjdXRpb25Ob2RlKHJvb3RFeGVjdXRpb25Ob2RlKTtcclxuICAgIHRoaXMuYnVpbGRJbnRlcm5hbChyZWxhdGlvblJvb3QpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyYXZlcnNlIHRoZSByZWxhdGlvbiB0cmVlIGFuZCBidWlsZCB0aGUgZXhlY3V0aW9uIHRyZWUuXHJcbiAqIEBwYXJhbSByZWxhdGlvblJvb3QgLSBUaGUgcm9vdCBub2RlIG9mIHRoZSBSZWxhdGlvblRyZWUuXHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5idWlsZEludGVybmFsID0gZnVuY3Rpb24gKHJlbGF0aW9uUm9vdCkge1xyXG4gICAgcmVsYXRpb25Sb290LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkUmVsYXRpb25Ob2RlID0gdGhpcy5nZXRSZWxhdGlvbk5vZGUoY2hpbGQpO1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0UmVsYXRpb25Ob2RlSW5FeGVjdXRpb25UcmVlKGNoaWxkUmVsYXRpb25Ob2RlKTtcclxuICAgICAgICB0aGlzLmJ1aWxkSW50ZXJuYWwoY2hpbGRSZWxhdGlvbk5vZGUpO1xyXG4gICAgfSwgdGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zZXJ0cyBhIHJlbGF0aW9uIG5vZGUgd2l0aGluIHRoZSBleGVjdXRpb24gdHJlZSAoYmFzZWQgb24gaXRzIGRlcGVuZGVuY2llcykuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSByZWxhdGlvbiB0aGF0IHdpbGwgYmUgaW5zZXJ0ZWQuXHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5pbnNlcnRSZWxhdGlvbk5vZGVJbkV4ZWN1dGlvblRyZWUgPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIHZhciByb290RXhlY3V0aW9uTm9kZSA9IHRoaXMuZ2V0RXhlY3V0aW9uTm9kZU9mUmVsYXRpb24ocmVsYXRpb24ucGFyZW50KTtcclxuICAgIHZhciBjaGlsZFRvQ29tYmluZSA9IHRoaXMudHJ5R2V0Q2hpbGROb2RlVG9Db21iaW5lKHJvb3RFeGVjdXRpb25Ob2RlLCByZWxhdGlvbik7XHJcbiAgICBpZiAoY2hpbGRUb0NvbWJpbmUpIHsvL2lmIHRoZXJlIGlzIGEgY2hpbGQgdGhhdCB3ZSBjb21iaW5lIHRoZSByZWxhdGlvblxyXG4gICAgICAgIGNoaWxkVG9Db21iaW5lLmluc2VydFJlbGF0aW9uTm9kZShyZWxhdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBuZXdFeGVjdXRpb25Ob2RlID0gbmV3IEV4ZWN1dGlvbk5vZGUocm9vdEV4ZWN1dGlvbk5vZGUsIHJlbGF0aW9uKTsvL2NyZWF0ZSBhIHNlcGFyYXRlIGV4ZWN1dGlvbiBub2RlIHRoYXQgd2lsbCBob3N0IHRoZSByZWxhdGlvblxyXG4gICAgICAgIHJvb3RFeGVjdXRpb25Ob2RlLmluc2VydENoaWxkcmVuTm9kZShuZXdFeGVjdXRpb25Ob2RlKTtcclxuICAgICAgICB0aGlzLmFkZEV4ZWN1dGlvbk5vZGUobmV3RXhlY3V0aW9uTm9kZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVHJpZXMgdG8gZmluZCBhbiBFeGVjdXRpb25Ob2RlIHdoaWNoIGNvdWxkIGJlIGNvbWJpbmVkIHdpdGggYSByZWxhdGlvbi5cclxuICogQHBhcmFtIHJvb3RFeGVjdXRpb25Ob2RlIC0gVGhlIHJvb3Qgbm9kZSBvZiB0aGUgRXhlY3V0aW9uVHJlZS5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gUmVsYXRpb24gdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBFeGVjdXRpb25UcmVlLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLnRyeUdldENoaWxkTm9kZVRvQ29tYmluZSA9IGZ1bmN0aW9uIChyb290RXhlY3V0aW9uTm9kZSwgcmVsYXRpb24pIHtcclxuICAgIGlmIChyb290RXhlY3V0aW9uTm9kZS5jYW5Db21iaW5lV2l0aFJlbGF0aW9uKHJlbGF0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiByb290RXhlY3V0aW9uTm9kZTtcclxuICAgIH1cclxuICAgIHZhciBjaGlsZHJlbiA9IHJvb3RFeGVjdXRpb25Ob2RlLmNoaWxkcmVuO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX21hcFtjaGlsZHJlbltpXV07XHJcbiAgICAgICAgdmFyIGNoaWxkVG9Db21iaW5lID0gdGhpcy50cnlHZXRDaGlsZE5vZGVUb0NvbWJpbmUoY2hpbGQsIHJlbGF0aW9uKTtcclxuICAgICAgICBpZiAoY2hpbGRUb0NvbWJpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkVG9Db21iaW5lO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGZpbHRlciBleHByZXNzaW9uIGZyb20gYWxsIHJlbGF0aW9ucyBpbnNpZGUgYW4gRXhlY3V0aW9uTm9kZS5cclxuICogQHBhcmFtIGV4ZWN1dGlvbk5vZGUgLSBUaGUgRXhlY3V0aW9uTm9kZSBpbnN0YW5jZS5cclxuICogQHJldHVybnMge3t9fVxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuZ2V0RmlsdGVyRnJvbUV4ZWN1dGlvbk5vZGUgPSBmdW5jdGlvbiAoZXhlY3V0aW9uTm9kZSwgaW5jbHVkZUFycmF5cykge1xyXG4gICAgdmFyIGZpbHRlciA9IHt9O1xyXG4gICAgdmFyIHN1YlJlbGF0aW9uc0ZpbHRlciA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGVjdXRpb25Ob2RlLnJlbGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBpbm5lckZpbHRlciA9IHRoaXMuZ2V0RmlsdGVyRnJvbVNpbmdsZVJlbGF0aW9uKHRoaXMuX3JlbGF0aW9uVHJlZVtleGVjdXRpb25Ob2RlLnJlbGF0aW9uc1tpXV0sIGluY2x1ZGVBcnJheXMpO1xyXG4gICAgICAgIGlmIChpbm5lckZpbHRlcikge1xyXG4gICAgICAgICAgICBzdWJSZWxhdGlvbnNGaWx0ZXIucHVzaChpbm5lckZpbHRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdWJSZWxhdGlvbnNGaWx0ZXIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGZpbHRlci4kb3IgPSBzdWJSZWxhdGlvbnNGaWx0ZXI7XHJcbiAgICB9IGVsc2UgaWYgKHN1YlJlbGF0aW9uc0ZpbHRlci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZmlsdGVyID0gc3ViUmVsYXRpb25zRmlsdGVyWzBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmaWx0ZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZpbHRlcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIGZpbHRlciBleHByZXNzaW9uIGZyb20gYSBzaW5nbGUgcmVsYXRpb24uIFRyYXZlcnNlIHRoZSByZWxhdGlvbiB0cmVlIGluIG9yZGVyIHRvIGdldCB0aGUgXCJJZFwicyBmcm9tIHRoZSByZXN1bHQgb2YgcGFyZW50IHJlbGF0aW9uXHJcbiAqIGFsb25nIHdpdGggdXNlciBkZWZpbmVkIGZpbHRlcnMuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIEEgUmVsYXRpb24gaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuZ2V0RmlsdGVyRnJvbVNpbmdsZVJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uLCBpbmNsdWRlQXJyYXlzKSB7XHJcbiAgICB2YXIgdXNlckRlZmluZWRGaWx0ZXIgPSByZWxhdGlvbi5maWx0ZXJFeHByZXNzaW9uO1xyXG4gICAgdmFyIHBhcmVudFJlbGF0aW9uRmlsdGVyID0ge307XHJcbiAgICB2YXIgcGFyZW50UmVsYXRpb25JZHMgPSB0aGlzLmdldFJlbGF0aW9uRmllbGRWYWx1ZXMocmVsYXRpb24sIGluY2x1ZGVBcnJheXMpO1xyXG4gICAgdmFyIHBhcmVudFJlbGF0aW9uRmllbGROYW1lID0gKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbiA/IHJlbGF0aW9uLnJlbGF0aW9uRmllbGQgOiBDb25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQpO1xyXG5cclxuICAgIGlmIChwYXJlbnRSZWxhdGlvbklkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcGFyZW50UmVsYXRpb25GaWx0ZXJbcGFyZW50UmVsYXRpb25GaWVsZE5hbWVdID0geyckaW4nOiBwYXJlbnRSZWxhdGlvbklkc307XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1c2VyRGVmaW5lZEZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBbXTtcclxuICAgICAgICBmaWx0ZXJzLnB1c2gocGFyZW50UmVsYXRpb25GaWx0ZXIpO1xyXG4gICAgICAgIGZpbHRlcnMucHVzaCh1c2VyRGVmaW5lZEZpbHRlcik7XHJcbiAgICAgICAgcmV0dXJuIHsnJGFuZCc6IGZpbHRlcnN9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50UmVsYXRpb25GaWx0ZXI7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHJlbGF0aW9uIGZpZWxkIHZhbHVlcyBvZiBwYXJlbnQgcmVsYXRpb24gaW4gb3JkZXIgdG8gY29uc3RydWN0IGEgcHJvcGVyIGZpbHRlciAodG8gY3JlYXRlIGEgcmVsYXRpb24pLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIHJlbGF0aW9uIGluc3RhbmNlIHdoaWNoIHdpbGwgZ2V0IHRoZSBmaWx0ZXIuXHJcbiAqIEBwYXJhbSBpbmNsdWRlQXJyYXlzIC0gV2hldGhlciB0byBpbmNsdWRlIGFycmF5IHZhbHVzIG9mIHRoZSBwYXJlbnQgaXRlbXMgd2hlbiBjYWxjdWxhdGluZyB0aGUgaXRlbXMgdGhhdCB3aWxsIGJlIGV4cGFuZGVkIG9uIHRoZSBjdXJyZW50IGxldmVsLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgb2YgcmVsYXRpb24gZmllbGQgdmFsdWVzLlxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuZ2V0UmVsYXRpb25GaWVsZFZhbHVlcyA9IGZ1bmN0aW9uIChyZWxhdGlvbiwgaW5jbHVkZUFycmF5cykge1xyXG4gICAgdmFyIHBhcmVudFJlbGF0aW9uSWRzID0gW107XHJcbiAgICB2YXIgcGFyZW50UmVsYXRpb24gPSB0aGlzLl9yZWxhdGlvblRyZWVbcmVsYXRpb24ucGFyZW50XTtcclxuICAgIC8vIHBhcmVudFJlbGF0aW9uUmVzdWx0IGFjdHVhbGx5IGlzIGFuIEFjdGl2aXR5IG9yIEFycmF5IG9mIEFjdGl2aXRpZXNcclxuICAgIHZhciBwYXJlbnRSZWxhdGlvblJlc3VsdCA9IEFycmF5LmlzQXJyYXkocGFyZW50UmVsYXRpb24ucmVzdWx0KSA/IHBhcmVudFJlbGF0aW9uLnJlc3VsdCA6IFtwYXJlbnRSZWxhdGlvbi5yZXN1bHRdO1xyXG4gICAgaWYgKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcGFyZW50UmVsYXRpb25SZXN1bHQubGVuZ3RoOyBwKyspIHtcclxuICAgICAgICAgICAgcGFyZW50UmVsYXRpb25JZHMucHVzaChwYXJlbnRSZWxhdGlvblJlc3VsdFtwXVtyZWxhdGlvbi5wYXJlbnRSZWxhdGlvbkZpZWxkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBhbGwgY29tbWVudHMgYXJlIHJlbGF0ZWQgdG8gZXhwYW5kIG9mIHR5cGUgY29udGVudCB0eXBlIEFjdGl2aXRpZXMgZXhwYW5kOiB7XCJMaWtlc1wiOiB0cnVlfVxyXG4gICAgICAgIGlmIChwYXJlbnRSZWxhdGlvbiAmJiBwYXJlbnRSZWxhdGlvbi5yZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVsYXRpb24ucGFyZW50UmVsYXRpb25JZHMgPSByZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkcyB8fCB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRSZWxhdGlvblJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gaXRlbUZyb21QYXJlbnRSZWxhdGlvbiBpcyBzaW5nbGUgQWN0aXZpdHlcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtRnJvbVBhcmVudFJlbGF0aW9uID0gcGFyZW50UmVsYXRpb25SZXN1bHRbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50UmVsYXRpb25GaWVsZFZhbHVlIGlzIEFjdGl2aXR5Lkxpa2VzXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UmVsYXRpb25GaWVsZFZhbHVlID0gaXRlbUZyb21QYXJlbnRSZWxhdGlvbltyZWxhdGlvbi5yZWxhdGlvbkZpZWxkXTtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGlvbi5oYXNBcnJheVZhbHVlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVBcnJheXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZW1Ub0V4cGFuZElkIGlzIGN1cnJlbnQgdmFsdWUgaW4gQWN0aXZpdHkuTGlrZXMgYXJyYXkgb3IganVzdCBhIHNpbmdsZSBcIklkXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVG9FeHBhbmRJZCA9IHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZVtqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW1Ub0V4cGFuZElkICE9PSB1bmRlZmluZWQgJiYgaXRlbVRvRXhwYW5kSWQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZWxhdGlvbklkcy5wdXNoKGl0ZW1Ub0V4cGFuZElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZXQgYW55IHZhbHVlIGp1c3QgdG8gY3JlYXRlIGEgbWFwIG9mIElkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzW2l0ZW1Ub0V4cGFuZElkXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZWxhdGlvbklkcy5wdXNoKHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzW3BhcmVudFJlbGF0aW9uRmllbGRWYWx1ZV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyZW50UmVsYXRpb25JZHM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvblRyZWU7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcclxudmFyIFJlbGF0aW9uVHJlZUJ1aWxkZXIgPSByZXF1aXJlKCcuL1JlbGF0aW9uVHJlZUJ1aWxkZXInKTtcclxudmFyIEV4ZWN1dGlvblRyZWUgPSByZXF1aXJlKCcuL0V4ZWN1dGlvblRyZWUnKTtcclxudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XHJcblxyXG5mdW5jdGlvbiBQcm9jZXNzb3Iob3B0aW9ucykge1xyXG4gICAgdGhpcy5fZXhlY3V0aW9uTm9kZUZ1bmN0aW9uID0gb3B0aW9ucy5leGVjdXRpb25Ob2RlRnVuY3Rpb247XHJcbiAgICB0aGlzLl9tZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb24gPSBvcHRpb25zLm1ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbjtcclxufVxyXG5cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5nZXRFeGVjdXRpb25UcmVlUm9vdCA9IGZ1bmN0aW9uIChleGVjdXRpb25UcmVlKSB7XHJcbiAgICB2YXIgZXhlY3V0aW9uVHJlZVJvb3QgPSBudWxsO1xyXG4gICAgZm9yICh2YXIgZXhOb2RlIGluIGV4ZWN1dGlvblRyZWUpIHtcclxuICAgICAgICBpZiAoZXhlY3V0aW9uVHJlZS5oYXNPd25Qcm9wZXJ0eShleE5vZGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChleGVjdXRpb25UcmVlW2V4Tm9kZV0ucGFyZW50ID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uVHJlZVJvb3QgPSBleGVjdXRpb25UcmVlW2V4Tm9kZV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBleGVjdXRpb25UcmVlUm9vdDtcclxufTtcclxuXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuY3JlYXRlRXhlY3V0ZU5vZGVFeGVjdXRvciA9IGZ1bmN0aW9uIChyZWxhdGlvbnNUcmVlLCBleGVjdXRpb25UcmVlLCBleGVjdXRpb25Ob2RlLCBleHBhbmRDb250ZXh0KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgcmVsYXRpb25zVHJlZU1hcCA9IHJlbGF0aW9uc1RyZWUubWFwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkb25lKSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aW9uTm9kZSA9IGV4ZWN1dGlvblRyZWUuZ2V0UmVsYXRpb25Ob2RlKGV4ZWN1dGlvbk5vZGUucmVsYXRpb25zWzBdKTsvL2dldCB0aGUgcmVsYXRpb24gbm9kZSBmb3IgdGhlIG9ubHkgcmVsYXRpb24gb2YgdGhlIGV4ZWN1dGlvbiBub2RlLlxyXG4gICAgICAgIHZhciBwYXJlbnRSZWxhdGlvbk5vZGUgPSBleGVjdXRpb25UcmVlLmdldFJlbGF0aW9uTm9kZShyZWxhdGlvbk5vZGUucGFyZW50KTtcclxuICAgICAgICB2YXIgaW5jbHVkZUFycmF5cyA9ICEocGFyZW50UmVsYXRpb25Ob2RlLnBhcmVudCAmJiBwYXJlbnRSZWxhdGlvbk5vZGUuaGFzQXJyYXlWYWx1ZXMpOyAvL29ubHkgZXhwYW5kIGFycmF5IGZpZWxkcyBpZiB0aGUgcGFyZW50IHJlbGF0aW9uIGlzIG5vdCBhbiBhcnJheS4gVGhpcyBtZWFucyB0aGF0IGlmIHdlIGhhdmUgZXhwYW5kZWQgYSBMaWtlcyAobXVsdGlwbGUgdG8gVXNlcnMpLCB3ZSB3b24ndCBleHBhbmQgYW55IGFycmF5IHJlbGF0aW9ucyB0aGF0IGFyZSBuZXN0ZWQgaW4gaXQgc3VjaCBhcyB0aGUgVXNlckNvbW1lbnRzIChtdWx0aXBsZSByZWxhdGlvbiB0byBDb21tZW50cykuXHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGV4ZWN1dGlvblRyZWUuZ2V0RmlsdGVyRnJvbUV4ZWN1dGlvbk5vZGUoZXhlY3V0aW9uTm9kZSwgaW5jbHVkZUFycmF5cyk7XHJcblxyXG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSByZWxhdGlvbnNUcmVlLnZhbGlkYXRlU2luZ2xlUmVsYXRpb24ocmVsYXRpb25Ob2RlKTtcclxuICAgICAgICBpZihlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKGVycm9yTWVzc2FnZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBzdWNoIG9wdGlvbnMgZXhlY3V0aW9uTm9kZSBzaG91bGQgaGF2ZSBvbmx5IG9uZSByZWxhdGlvbi5cclxuICAgICAgICB2YXIgbm9kZSA9IHt9O1xyXG4gICAgICAgIG5vZGUuc2VsZWN0ID0gcmVsYXRpb25Ob2RlLmZpZWxkc0V4cHJlc3Npb247XHJcbiAgICAgICAgbm9kZS5zb3J0ID0gcmVsYXRpb25Ob2RlLnNvcnRFeHByZXNzaW9uO1xyXG4gICAgICAgIG5vZGUuc2tpcCA9IHJlbGF0aW9uTm9kZS5za2lwO1xyXG4gICAgICAgIG5vZGUudGFrZSA9IHJlbGF0aW9uTm9kZS50YWtlO1xyXG4gICAgICAgIG5vZGUuZmlsdGVyID0gZmlsdGVyO1xyXG4gICAgICAgIG5vZGUudGFyZ2V0VHlwZU5hbWUgPSByZWxhdGlvbk5vZGUudGFyZ2V0VHlwZU5hbWU7XHJcblxyXG4gICAgICAgIHNlbGYuX2V4ZWN1dGlvbk5vZGVGdW5jdGlvbi5jYWxsKG51bGwsIG5vZGUsIGV4cGFuZENvbnRleHQsIGZ1bmN0aW9uIG9uUHJvY2Vzc0V4ZWN1dGlvbk5vZGUoZXJyLCByZXN1bHQpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGVjdXRpb25Ob2RlLnJlbGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkUmVsYXRpb24gPSByZWxhdGlvbnNUcmVlTWFwW2V4ZWN1dGlvbk5vZGUucmVsYXRpb25zW2ldXTtcclxuICAgICAgICAgICAgICAgIGNoaWxkUmVsYXRpb24ucmVzdWx0ID0gc2VsZi5leHRyYWN0UmVzdWx0Rm9yUmVsYXRpb24ocmVsYXRpb25zVHJlZU1hcFtleGVjdXRpb25Ob2RlLnJlbGF0aW9uc1tpXV0sIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXhlY3V0aW9uTm9kZS5yZXN1bHQgPSBjaGlsZFJlbGF0aW9uLnJlc3VsdDtcclxuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGV4ZWN1dGlvbk5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBleGVjdXRpb25UcmVlTWFwID0gZXhlY3V0aW9uVHJlZS5fbWFwO1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goc2VsZi5jcmVhdGVFeGVjdXRlTm9kZUV4ZWN1dG9yKHJlbGF0aW9uc1RyZWUsIGV4ZWN1dGlvblRyZWUsIGV4ZWN1dGlvblRyZWVNYXBbZXhlY3V0aW9uTm9kZS5jaGlsZHJlbltqXV0sIGV4cGFuZENvbnRleHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3luYy5wYXJhbGxlbChhcnIsIGRvbmUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufTtcclxuXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuZ2V0U2luZ2xlUmVzdWx0ID0gZnVuY3Rpb24gKHJlbGF0aW9uc1RyZWUsIHJlbGF0aW9uLCBzaW5nbGVPYmplY3QpIHtcclxuICAgIGlmICghc2luZ2xlT2JqZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNoaWxkUmVsYXRpb247XHJcbiAgICB2YXIgY2hpbGRJdGVtO1xyXG5cclxuICAgIC8vIGlmIHJlbGF0aW9uIGhhcyBzaW5nbGVGaWVsZE5hbWUgb3B0aW9uIHdlIGp1c3QgcmVwbGFjZSB0aGUgcGFyZW50IGlkIHdpdGggYSBzaW5nbGUgdmFsdWVcclxuICAgIGlmIChyZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWUpIHtcclxuICAgICAgICBpZiAocmVsYXRpb24uY2hpbGRyZW4gJiYgcmVsYXRpb24uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjaGlsZFJlbGF0aW9uID0gcmVsYXRpb25zVHJlZVtyZWxhdGlvbi5jaGlsZHJlblswXV07XHJcbiAgICAgICAgICAgIGNoaWxkSXRlbSA9IHRoaXMuZ2V0T2JqZWN0QnlJZEZyb21BcnJheShjaGlsZFJlbGF0aW9uLnJlc3VsdCwgc2luZ2xlT2JqZWN0W3JlbGF0aW9uLnNpbmdsZUZpZWxkTmFtZV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaW5nbGVSZXN1bHQocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpbmdsZU9iamVjdFtyZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIHZhciBwYXNzZWRQcm9wZXJ0aWVzID0ge307XHJcblxyXG4gICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuICYmIHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGNoaWxkUmVsYXRpb24gPSByZWxhdGlvbnNUcmVlW3JlbGF0aW9uLmNoaWxkcmVuW2pdXTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkUmVsYXRpb25GaWVsZCA9IGNoaWxkUmVsYXRpb24ucmVsYXRpb25GaWVsZDtcclxuICAgICAgICAgICAgdmFyIHVzZXJEZWZpbmVkUmVsTmFtZSA9IGNoaWxkUmVsYXRpb24udXNlckRlZmluZWROYW1lO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkUmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBwYXNzZWRQcm9wZXJ0aWVzW2NoaWxkUmVsYXRpb25GaWVsZF0gPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5uZXJSZWxhdGlvblJlc3VsdCA9IGNoaWxkUmVsYXRpb24ucmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoaWxkUmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGlubmVyUmVsYXRpb25SZXN1bHQubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNpbmdsZVJlc3VsdFRvUGFyZW50QXJyYXkocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgaW5uZXJSZWxhdGlvblJlc3VsdFtrXSwgcmVzdWx0LCB1c2VyRGVmaW5lZFJlbE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W3VzZXJEZWZpbmVkUmVsTmFtZV0gPSBjaGlsZFJlbGF0aW9uLmlzQXJyYXkoKSA/IFtdIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZU9iamVjdFtjaGlsZFJlbGF0aW9uRmllbGRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFJlbGF0aW9uLnNvcnRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNvcnRpbmcgd2UgcmVwbGFjZSBpdGVtcyB1c2luZyBvcmRlciBvZiB0aGUgcXVlcnkgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IGlubmVyUmVsYXRpb25SZXN1bHQubGVuZ3RoOyBwKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF0uaW5kZXhPZihpbm5lclJlbGF0aW9uUmVzdWx0W3BdLklkKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbSA9IGlubmVyUmVsYXRpb25SZXN1bHRbcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2luZ2xlUmVzdWx0VG9QYXJlbnRBcnJheShyZWxhdGlvbnNUcmVlLCBjaGlsZFJlbGF0aW9uLCBjaGlsZEl0ZW0sIHJlc3VsdCwgdXNlckRlZmluZWRSZWxOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IHJlcGxhY2UgaXRlbXMgZ2V0dGluZyB0aGVtIGJ5IGlkIHdoaWNoIHdlIGhhdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEl0ZW0gPSB0aGlzLmdldE9iamVjdEJ5SWRGcm9tQXJyYXkoaW5uZXJSZWxhdGlvblJlc3VsdCwgc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF1baV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2luZ2xlUmVzdWx0VG9QYXJlbnRBcnJheShyZWxhdGlvbnNUcmVlLCBjaGlsZFJlbGF0aW9uLCBjaGlsZEl0ZW0sIHJlc3VsdCwgdXNlckRlZmluZWRSZWxOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbSA9IHRoaXMuZ2V0T2JqZWN0QnlJZEZyb21BcnJheShpbm5lclJlbGF0aW9uUmVzdWx0LCBzaW5nbGVPYmplY3RbY2hpbGRSZWxhdGlvbkZpZWxkXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFt1c2VyRGVmaW5lZFJlbE5hbWVdID0gdGhpcy5nZXRTaW5nbGVSZXN1bHQocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIGFsbCBvdGhlciBmaWVsZHMgdG8gdGhlIHJlc3VsdCAoZXhjZXB0IHRoZSByZWxhdGlvbiBmaWVsZHMgd2hpY2ggd2UgaGF2ZSBhbHJlYWR5IHJlcGxhY2VkKS5cclxuICAgIGZvciAodmFyIHByb3AgaW4gc2luZ2xlT2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIHByb3BlcnR5U2hvdWxkQmVBZGRlZFRvUmVzdWx0ID0gc2luZ2xlT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApICYmICFwYXNzZWRQcm9wZXJ0aWVzW3Byb3BdICYmXHJcbiAgICAgICAgICAgIHRoaXMuZmllbGRFeGlzdEluRmllbGRzRXhwcmVzc2lvbihwcm9wLCByZWxhdGlvbi5vcmlnaW5hbEZpZWxkc0V4cHJlc3Npb24pO1xyXG4gICAgICAgIGlmIChwcm9wZXJ0eVNob3VsZEJlQWRkZWRUb1Jlc3VsdCkge1xyXG4gICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBzaW5nbGVPYmplY3RbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5Qcm9jZXNzb3IucHJvdG90eXBlLmFkZFNpbmdsZVJlc3VsdFRvUGFyZW50QXJyYXkgPSBmdW5jdGlvbiAocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtLCByZXN1bHQsIHVzZXJEZWZpbmVkUmVsTmFtZSkge1xyXG4gICAgdmFyIHNpbmdsZVJlc3VsdCA9IHRoaXMuZ2V0U2luZ2xlUmVzdWx0KHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGNoaWxkSXRlbSk7XHJcbiAgICByZXN1bHRbdXNlckRlZmluZWRSZWxOYW1lXSA9IHJlc3VsdFt1c2VyRGVmaW5lZFJlbE5hbWVdIHx8IFtdO1xyXG4gICAgaWYgKHNpbmdsZVJlc3VsdCkge1xyXG4gICAgICAgIHJlc3VsdFt1c2VyRGVmaW5lZFJlbE5hbWVdLnB1c2goc2luZ2xlUmVzdWx0KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBmaWVsZCB3aWxsIGJlIHJldHVybmVkIHZpYSBnaXZlbiBmaWVsZHMgZXhwcmVzc2lvbi5cclxuICogQHBhcmFtIGZpZWxkIC0gVGhlIG5hbWUgb2YgdGhlIGZpZWxkLlxyXG4gKiBAcGFyYW0gZmllbGRzRXhwcmVzc2lvbiAtIFRoZSBGaWVsZHMgZXhwcmVzc2lvbiB3aGljaCBpcyBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuZmllbGRFeGlzdEluRmllbGRzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChmaWVsZCwgZmllbGRzRXhwcmVzc2lvbikge1xyXG4gICAgaWYgKGZpZWxkc0V4cHJlc3Npb24gPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhmaWVsZHNFeHByZXNzaW9uKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmllbGQgPT09IENvbnN0YW50cy5JZEZpZWxkTmFtZUNsaWVudCkge1xyXG4gICAgICAgIGlmIChmaWVsZHNFeHByZXNzaW9uW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmllbGRzRXhwcmVzc2lvbltmaWVsZF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzRXhjbHVzaXZlID0gUmVsYXRpb25UcmVlQnVpbGRlci5nZXRJc0ZpZWxkc0V4cHJlc3Npb25FeGNsdXNpdmUoZmllbGRzRXhwcmVzc2lvbik7XHJcblxyXG4gICAgaWYgKGlzRXhjbHVzaXZlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNFeGNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gIWZpZWxkc0V4cHJlc3Npb24uaGFzT3duUHJvcGVydHkoZmllbGQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmllbGRzRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShmaWVsZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRXh0cmFjdHMgdGhlIHJlc3VsdCBmb3IgYSBzaW5nbGUgcmVsYXRpb24gKGluIGNhc2VzIHdoZW4gRXhlY3V0aW9uTm9kZSBjb250YWlucyBtb3JlIHRoYW4gb25lIHJlbGF0aW9ucykuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSByZWxhdGlvbiBvYmplY3QuXHJcbiAqIEBwYXJhbSBxdWVyeVJlc3VsdCAtIFJlc3VsdCBvZiB0aGUgY29tYmluZWQgcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICovXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuZXh0cmFjdFJlc3VsdEZvclJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uLCBxdWVyeVJlc3VsdCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeVJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkcykge1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpb24ucGFyZW50UmVsYXRpb25JZHMuaGFzT3duUHJvcGVydHkocXVlcnlSZXN1bHRbaV0uSWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChxdWVyeVJlc3VsdFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChxdWVyeVJlc3VsdFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIGFuIG9iamVjdCB3aXRoIGEgZ2l2ZW4gSWQgZnJvbSBBcnJheS5cclxuICogQHBhcmFtIGFycmF5XHJcbiAqIEBwYXJhbSBpZFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuZ2V0T2JqZWN0QnlJZEZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgaWQpIHtcclxuICAgIGlmIChhcnJheSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5W2ldLklkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5W2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5Qcm9jZXNzb3IucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbiwgbWFpblR5cGVOYW1lLCBpc0FycmF5LCBmaWVsZHNFeHByZXNzaW9uLCBtYXhUYWtlVmFsdWUsIHByZXBhcmVDb250ZXh0LCBkb25lKSB7XHJcbiAgICB2YXIgcnRiID0gbmV3IFJlbGF0aW9uVHJlZUJ1aWxkZXIoZXhwYW5kRXhwcmVzc2lvbiwgbWFpblR5cGVOYW1lLCBpc0FycmF5LCBmaWVsZHNFeHByZXNzaW9uLCBtYXhUYWtlVmFsdWUsIHRoaXMuX21ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbiwgcHJlcGFyZUNvbnRleHQpO1xyXG4gICAgcnRiLmJ1aWxkKGZ1bmN0aW9uIChlcnIsIG1hcCkge1xyXG4gICAgICAgIHZhciBtYWluUXVlcnlGaWVsZHNFeHByZXNzaW9uO1xyXG4gICAgICAgIGlmIChtYXApIHtcclxuICAgICAgICAgICAgbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvbiA9IG1hcFttYXAuJHJvb3RdLmZpZWxkc0V4cHJlc3Npb247XHJcbiAgICAgICAgICAgIHZhciBwcmVwYXJlUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgcmVsYXRpb25zVHJlZTogcnRiLFxyXG4gICAgICAgICAgICAgICAgbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvbjogbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvbmUoZXJyLCBwcmVwYXJlUmVzdWx0KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAocmVsYXRpb25zVHJlZSwgbWFpblF1ZXJ5UmVzdWx0LCBleHBhbmRDb250ZXh0LCBkb25lKSB7XHJcbiAgICB2YXIgcmVsYXRpb25zVHJlZU1hcCA9IHJlbGF0aW9uc1RyZWUubWFwO1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIGV4ZWN1dGlvblRyZWUgPSBuZXcgRXhlY3V0aW9uVHJlZShyZWxhdGlvbnNUcmVlTWFwKTtcclxuICAgIGV4ZWN1dGlvblRyZWUuYnVpbGQoKTtcclxuICAgIHJlbGF0aW9uc1RyZWVNYXBbcmVsYXRpb25zVHJlZU1hcC4kcm9vdF0ucmVzdWx0ID0gbWFpblF1ZXJ5UmVzdWx0O1xyXG4gICAgdmFyIGV4ZWN1dGlvblRyZWVNYXAgPSBleGVjdXRpb25UcmVlLl9tYXA7XHJcblxyXG4gICAgdmFyIGV4ZWN1dGlvblRyZWVSb290ID0gdGhpcy5nZXRFeGVjdXRpb25UcmVlUm9vdChleGVjdXRpb25UcmVlTWFwKTtcclxuXHJcbiAgICB2YXIgbWF4UXVlcmllc0NvdW50ID0gMjA7IC8vVE9ETzogbWFrZSBpdCBjb25maWd1cmFibGVcclxuICAgIGlmIChPYmplY3Qua2V5cyhleGVjdXRpb25UcmVlTWFwKS5sZW5ndGggPiBtYXhRdWVyaWVzQ291bnQpIHtcclxuICAgICAgICBkb25lKG5ldyBFcnJvcignRXhwYW5kIGV4cHJlc3Npb24gcmVzdWx0cyBpbiBtb3JlIHRoYW4gJyArIG1heFF1ZXJpZXNDb3VudCArICcgaW5uZXIgcXVlcmllcyEnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGV4ZWN1dGlvblRyZWVSb290KSB7XHJcbiAgICAgICAgdmFyIGV4ZWNGdW5jcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhlY3V0aW9uVHJlZVJvb3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXhlY0Z1bmNzLnB1c2godGhpcy5jcmVhdGVFeGVjdXRlTm9kZUV4ZWN1dG9yKHJlbGF0aW9uc1RyZWUsIGV4ZWN1dGlvblRyZWUsIGV4ZWN1dGlvblRyZWVNYXBbZXhlY3V0aW9uVHJlZVJvb3QuY2hpbGRyZW5baV1dLCBleHBhbmRDb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV4ZWNGdW5jcyBhcmUgZnVuY3Rpb25zIGNyZWF0ZWQgZm9yIGV2ZXJ5IHNpbmdsZSBleGVjdXRpb24gbm90ZVxyXG4gICAgICAgIC8vIHdlIGV4ZWN1dGUgdGhlbSBpbiBhc3luYywgc2luY2UgdGhlIHJlc3VsdCBvZiB0aGUgcGFyZW50IHJlbGF0aW9uIGlzIHVzZWQgdG8gZ2V0IGNvcnJlY3QgZmlsdGVyLlxyXG4gICAgICAgIGFzeW5jLnNlcmllcyhleGVjRnVuY3MsIGZ1bmN0aW9uIG9uUHJvY2Vzc0V4ZWN1dGlvblRyZWUoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdFJlbGF0aW9uID0gcmVsYXRpb25zVHJlZU1hcFtyZWxhdGlvbnNUcmVlTWFwLiRyb290XTtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1haW5RdWVyeVJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1haW5RdWVyeVJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUmVzdWx0ID0gc2VsZi5nZXRTaW5nbGVSZXN1bHQocmVsYXRpb25zVHJlZU1hcCwgcm9vdFJlbGF0aW9uLCBtYWluUXVlcnlSZXN1bHRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzaW5nbGVSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBzZWxmLmdldFNpbmdsZVJlc3VsdChyZWxhdGlvbnNUcmVlTWFwLCByb290UmVsYXRpb24sIG1haW5RdWVyeVJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkb25lKG51bGwsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuXHJcblByb2Nlc3Nvci5Db25zdGFudHMgPSBDb25zdGFudHM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NvcjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9Db25zdGFudHMnKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcblxyXG5mdW5jdGlvbiBSZWxhdGlvbk5vZGUob3B0aW9ucykge1xyXG4gICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcclxuICAgIHRoaXMucmVsYXRpb25GaWVsZCA9IG9wdGlvbnMucmVsYXRpb25GaWVsZDtcclxuICAgIHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aCB8fCBvcHRpb25zLnBhcmVudCArICcuJyArIG9wdGlvbnMucmVsYXRpb25GaWVsZDtcclxuICAgIHRoaXMuZmllbGRzRXhwcmVzc2lvbiA9IG9wdGlvbnMuZmllbGRzRXhwcmVzc2lvbiB8fCB7fTtcclxuICAgIHZhciBpc01hbnVhbGx5VmFsaWRhdGVkID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgndmFsaWRhdGVkJykgPyBvcHRpb25zLnZhbGlkYXRlZCA6ICEhb3B0aW9ucy50YXJnZXRUeXBlTmFtZTtcclxuICAgIHRoaXMudmFsaWRhdGVkID0gaXNNYW51YWxseVZhbGlkYXRlZDtcclxuICAgIHRoaXMudGFyZ2V0VHlwZU5hbWUgPSBvcHRpb25zLnRhcmdldFR5cGVOYW1lO1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgdGhpcy5pc0ludmVydGVkUmVsYXRpb24gPSBvcHRpb25zLmlzSW52ZXJ0ZWRSZWxhdGlvbjtcclxuICAgIHRoaXMuaXNBcnJheVJvb3QgPSBvcHRpb25zLmlzQXJyYXlSb290OyAvL3VzZWQgZm9yIHZhbGlkYXRpb24gb2YgY2FzZXMgd2hlcmUgdmFyaW91cyBleHBhbmQgZmVhdHVyZXMgYXJlIGRpc2FibGVkIGZvciBhIEdldEFsbCBzY2VuYXJpby5cclxuICAgIHRoaXMuaGFzQXJyYXlWYWx1ZXMgPSBmYWxzZTsvL3NldCB3aGVuIHdlIGhhdmUgZXhlY3V0ZWQgdGhlIHF1ZXJ5LiBVc2VkIGluIHZhbGlkYXRpb24gc2NlbmFyaW9zIHdoZXJlIHdlIGRvIG5vdCBoYXZlIG1ldGFkYXRhIGFib3V0IHdoZXRoZXIgdGhlIHJlbGF0aW9uIGlzIGFuIGFycmF5IG9yIG5vdC5cclxuXHJcbiAgICB2YXIgZXhwYW5kRXhwcmVzc2lvbiA9IG9wdGlvbnMuZXhwYW5kRXhwcmVzc2lvbiB8fCB7fTtcclxuXHJcbiAgICB0aGlzLnBhcmVudFJlbGF0aW9uRmllbGQgPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5QYXJlbnRSZWxhdGlvbkZpZWxkTmFtZV0gfHwgQ29uc3RhbnRzLklkRmllbGROYW1lQ2xpZW50O1xyXG4gICAgdmFyIHJlbGF0aW9uRmllbGQgPSB0aGlzLmlzSW52ZXJ0ZWRSZWxhdGlvbiA/IHRoaXMucGF0aCA6IHRoaXMucmVsYXRpb25GaWVsZDsgLy9pbnZlcnRlZCByZWxhdGlvbnMgYXBwZWFyIHdpdGggdGhlIGZ1bGwgcGF0aCAtIENvbnRlbnRUeXBlLkZpZWxkIC0gaW4gdGhlIHJlc3VsdCB3aGVuIGV4cGFuZGluZy5cclxuICAgIHRoaXMudXNlckRlZmluZWROYW1lID0gZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuUmV0dXJuQXNGaWVsZE5hbWVdIHx8IHJlbGF0aW9uRmllbGQ7XHJcbiAgICBfLmV4dGVuZCh0aGlzLmZpZWxkc0V4cHJlc3Npb24sIGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLkZpZWxkc0V4cHJlc3Npb25OYW1lXSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiA9IHt9O1xyXG4gICAgXy5leHRlbmQodGhpcy5vcmlnaW5hbEZpZWxkc0V4cHJlc3Npb24sIHRoaXMuZmllbGRzRXhwcmVzc2lvbik7XHJcbiAgICB0aGlzLnNpbmdsZUZpZWxkTmFtZSA9IGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLlNpbmdsZUZpZWxkRXhwcmVzc2lvbk5hbWVdO1xyXG4gICAgdGhpcy5maWx0ZXJFeHByZXNzaW9uID0gZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuRmlsdGVyRXhwcmVzc2lvbk5hbWVdO1xyXG4gICAgdGhpcy5zb3J0RXhwcmVzc2lvbiA9IGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLlNvcnRFeHByZXNzaW9uTmFtZV07XHJcbiAgICB0aGlzLnNraXAgPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5Ta2lwRXhwcmVzc2lvbk5hbWVdO1xyXG4gICAgdGhpcy50YWtlID0gdGhpcy5fZ2V0VGFrZUxpbWl0KGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLlRha2VFeHByZXNzaW9uTmFtZV0sIG9wdGlvbnMubWF4VGFrZVZhbHVlKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB0YWtlIGxpbWl0IGRlcGVuZGluZyBvbiB0aGUgYXBwbGljYXRpb24gYW5kIHRoZSB0YWtlIHZhbHVlIHRoYXQgdGhlIHVzZXIgaGFzIHByb3ZpZGVkLlxyXG4gKiBAcGFyYW0gY2xpZW50VGFrZVZhbHVlXHJcbiAqIEBwYXJhbSBtYXhUYWtlVmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcblJlbGF0aW9uTm9kZS5wcm90b3R5cGUuX2dldFRha2VMaW1pdCA9IGZ1bmN0aW9uIChjbGllbnRUYWtlVmFsdWUsIG1heFRha2VWYWx1ZSkge1xyXG4gICAgbWF4VGFrZVZhbHVlID0gbWF4VGFrZVZhbHVlIHx8IENvbnN0YW50cy5EZWZhdWx0VGFrZUl0ZW1zQ291bnQ7XHJcbiAgICBpZiAoY2xpZW50VGFrZVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGNsaWVudFRha2VWYWx1ZSA+IG1heFRha2VWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtYXhpbXVtIGFsbG93ZWQgdGFrZSB2YWx1ZSB3aGVuIGV4cGFuZGluZyByZWxhdGlvbnMgaXMgJyArIG1heFRha2VWYWx1ZSArICchJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGllbnRUYWtlVmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXhUYWtlVmFsdWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQW55b25lIHVzaW5nIHRoZSBicy1leHBhbmQtcHJvY2Vzc29yIG1vZHVsZSBjYW4gc2V0IHdoZXRoZXIgdGhlIHJlbGF0aW9uIGlzIGEgbXVsdGlwbGUgcmVsYXRpb24gaW4gdGhlIHByZXBhcmUgcGhhc2UuXHJcbiAqIFRoaXMgd2lsbCBhbGxvdyBmb3IgY2VydGFpbiByZXN0cmljdGlvbnMgdG8gYmUgZW5mb3JjZWQgZGlyZWN0bHkgb24gdGhlIHByZXBhcmUgcGhhc2UgaW5zdGVhZCBvZiB0aGUgZXhlY3V0aW9uIHBoYXNlLlxyXG4gKi9cclxuUmVsYXRpb25Ob2RlLnByb3RvdHlwZS5zZXRJc0FycmF5RnJvbU1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5pc0FycmF5RnJvbU1ldGFkYXRhID0gdHJ1ZTtcclxufTtcclxuXHJcblJlbGF0aW9uTm9kZS5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFdlIGNhbiBmaW5kIG91dCBpZiBhIHJlbGF0aW9uIGlzIGFuIGFycmF5IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XHJcbiAgICAvLyBGcm9tIG1ldGFkYXRhIGluIHRoZSBBUEkgU2VydmVyLlxyXG4gICAgLy8gQWxsIGludmVydGVkIHJlbGF0aW9ucyBhcmUgYXJyYXkuXHJcbiAgICAvLyBPbmNlIHZhbHVlcyBoYXZlIGJlZW4gcmVjZWl2ZWQgd2UgY2FuIGZpbmQgb3V0LiBUaGlzIGlzIHVzZWQgZm9yIHNjZW5hcmlvcyB3aGVyZSB3ZSBkbyBub3QgaGF2ZSBtZXRhZGF0YSBhYm91dCB0aGUgcmVsYXRpb24gKG9mZmxpbmUgc3RvcmFnZSBpbiBTREspLlxyXG4gICAgcmV0dXJuIHRoaXMuaXNBcnJheUZyb21NZXRhZGF0YSB8fCB0aGlzLmlzSW52ZXJ0ZWRSZWxhdGlvbiB8fCB0aGlzLmhhc0FycmF5VmFsdWVzIDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVsYXRpb25Ob2RlO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBSZWxhdGlvbk5vZGUgPSByZXF1aXJlKCcuL1JlbGF0aW9uTm9kZScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XHJcblxyXG4vL3ZhciByZWxhdGlvbkZpZWxkUHJvcGVydHlOYW1lID0gQ29uc3RhbnRzLlJlbGF0aW9uRXhwcmVzc2lvbk5hbWU7XHJcblxyXG52YXIgcG9zc2libGVFeHBhbmRPcHRpb25zID0gW1xyXG4gICAgQ29uc3RhbnRzLkV4cGFuZEV4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lLFxyXG4gICAgQ29uc3RhbnRzLkZpZWxkc0V4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLlNpbmdsZUZpZWxkRXhwcmVzc2lvbk5hbWUsXHJcbiAgICBDb25zdGFudHMuU29ydEV4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLkZpbHRlckV4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLlNraXBFeHByZXNzaW9uTmFtZSxcclxuICAgIENvbnN0YW50cy5UYWtlRXhwcmVzc2lvbk5hbWUsXHJcbiAgICBDb25zdGFudHMuUGFyZW50UmVsYXRpb25GaWVsZE5hbWUsXHJcbiAgICBDb25zdGFudHMuVGFyZ2V0VHlwZU5hbWVGaWVsZE5hbWVcclxuXTtcclxuXHJcblxyXG4vKipcclxuICogQSBjbGFzcyB1c2VkIHRvIHBhcnNlIEV4cGFuZCBleHByZXNzaW9uIGFuZCBidWlsZCBhIGNvcnJlc3BvbmRpbmcgcmVsYXRpb24gdHJlZS5cclxuICogSW4gYSBwcm9jZXNzIG9mIGNyZWF0aW5nIHRoZSByZWxhdGlvbiB0cmVlIGFyZSBwZXJmb3JtZWQgc2V2ZXJhbCBjaGVja3MgaW4gb3JkZXIgdG8gZm9yY2Ugc29tZSBsaW1pdGF0aW9ucyAtXHJcbiAqIDUwIGl0ZW1zIGJvdGggZm9yIG1hc3RlciBhbmQgY2hpbGQgcXVlcmllcyBhbmQgZW50aXJlIGFtb3VudCBvZiBhbGwgcXVlcmllcyBsaW1pdGVkIHRvIDIwLlxyXG4gKiBDaGVja3MgaWYgdGhlIHJlbGF0aW9uIGZpZWxkIGdpdmVuIGJ5IHRoZSBjdXN0b21lciBpcyB2YWxpZCAoZm9yIGV4YW1wbGU6IHVzZXIgZ2l2ZXMgXCJMaWtlXCIgd2hpbGUgdGhlIHJlbGF0aW9uIGZpZWxkIGlzIFwiTGlrZXNcIikuXHJcbiAqIENoZWNrcyBmb3IgcG9zc2libGUgZXhwYW5kIG9wdGlvbnMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFJlbGF0aW9uVHJlZUJ1aWxkZXIgPSBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbiwgbWFpblR5cGVOYW1lLCBpc0FycmF5LCBmaWVsZHNFeHByZXNzaW9uLCBtYXhUYWtlVmFsdWUsIG1ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbiwgY29udGV4dCkge1xyXG4gICAgdGhpcy5tYXhUYWtlVmFsdWUgPSBtYXhUYWtlVmFsdWU7XHJcbiAgICB0aGlzLl9tZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb24gPSBtZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb247XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5leHBhbmRFeHByZXNzaW9uID0gdGhpcy5wcm9jZXNzRXhwYW5kRXhwcmVzc2lvbihleHBhbmRFeHByZXNzaW9uKTtcclxuICAgIC8vIG1hcmsgdGhlIG1haW4gcXVlcnkgaW4gb3JkZXIgdG8gYXZvaWQgc29tZSBkdXBsaWNhdGlvbiBpc3N1ZXMuXHJcbiAgICB0aGlzLm1hcCA9IHt9O1xyXG4gICAgdGhpcy5tYXBbbWFpblR5cGVOYW1lXSA9IG5ldyBSZWxhdGlvbk5vZGUoe1xyXG4gICAgICAgIHRhcmdldFR5cGVOYW1lOiBtYWluVHlwZU5hbWUsXHJcbiAgICAgICAgaXNBcnJheVJvb3Q6IGlzQXJyYXksXHJcbiAgICAgICAgZmllbGRzRXhwcmVzc2lvbjogZmllbGRzRXhwcmVzc2lvbixcclxuICAgICAgICB2YWxpZGF0ZWQ6IHRydWUsXHJcbiAgICAgICAgcGF0aDogbWFpblR5cGVOYW1lLFxyXG4gICAgICAgIG1heFRha2VWYWx1ZTogbWF4VGFrZVZhbHVlXHJcbiAgICB9KTtcclxuICAgIHRoaXMubWFwW21haW5UeXBlTmFtZV0ub3JpZ2luYWxGaWVsZHNFeHByZXNzaW9uID0ge307XHJcbiAgICBfLmV4dGVuZCh0aGlzLm1hcFttYWluVHlwZU5hbWVdLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiwgZmllbGRzRXhwcmVzc2lvbik7XHJcbiAgICB0aGlzLm1hcC4kcm9vdCA9IG1haW5UeXBlTmFtZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGZ1bGx5IHF1YWxpZmllZCBleHBhbmQgZXhwcmVzc2lvbiBmcm9tIHNob3J0aGFuZCB1c2FnZXM6XHJcbiAqIHtcIkxpa2VzXCI6IHRydWV9IC0+IHtcIkxpa2VzXCI6IHtcIlJldHVybkFzXCI6IFwiTGlrZXNcIn19XHJcbiAqIHtcIkxpa2VzXCI6IFwiTGlrZXNFeHBhbmRlZFwifSAtPiB7XCJMaWtlc1wiOiB7XCJSZXR1cm5Bc1wiOiBcIkxpa2VzRXhwYW5kZWRcIn19XHJcbiAqIEBwYXJhbSBleHBhbmRFeHByZXNzaW9uXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUucHJvY2Vzc0V4cGFuZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbikge1xyXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZXhwYW5kRXhwcmVzc2lvbikge1xyXG4gICAgICAgIGlmIChleHBhbmRFeHByZXNzaW9uLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldID0ge307XHJcbiAgICAgICAgICAgICAgICBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XVtDb25zdGFudHMuUmV0dXJuQXNGaWVsZE5hbWVdID0gcHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWxhdGlvbkZpZWxkID0gZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV1bQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lXSA9IHJlbGF0aW9uRmllbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwYW5kRXhwcmVzc2lvbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgdGhlIHJlbGF0aW9uIHRyZWUuXHJcbiAqIEBwYXJhbSBkb25lXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChkb25lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuYnVpbGRNYXBJbnRlcm5hbCh0aGlzLmV4cGFuZEV4cHJlc3Npb24sIHRoaXMubWFwLiRyb290KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZG9uZShlKTtcclxuICAgIH1cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHJlcXVpcmUoJ2FzeW5jJykuc2VyaWVzKFtcclxuICAgICAgICB0aGlzLmNvbmZpZ3VyZVJlbGF0aW9uVHJlZS5iaW5kKHRoaXMpLFxyXG4gICAgICAgIHRoaXMudmFsaWRhdGVSZWxhdGlvblRyZWUuYmluZCh0aGlzKVxyXG4gICAgXSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIGRvbmUoZXJyLCBzZWxmLm1hcCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVsYXRpb25OYW1lIC0gQSBwYXRoIHRvIHRoZSBleHRlcm5hbCByZWxhdGlvbiBjb2xsZWN0aW9uIChDb21tZW50cy5BY3Rpdml0eUlkKVxyXG4gKiBAcGFyYW0gZXhwYW5kRXhwcmVzc2lvbiAtIFRoZSBleHBhbmQgZXhwcmVzc2lvbiB0aGF0IGNvbnRhaW5zIGFsbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVsYXRpb25cclxuICogQHBhcmFtIHJvb3ROYW1lIC0gTmFtZSBvZiB0aGUgcGFyZW50IHJlbGF0aW9uLlxyXG4gKiBAcmV0dXJucyB7UmVsYXRpb25Ob2RlfVxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlSW52ZXJ0ZWRSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbk5hbWUsIGV4cGFuZEV4cHJlc3Npb24sIHJvb3ROYW1lKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gICAgdmFyIHJlbGF0aW9uTmFtZVBhcnRzID0gcmVsYXRpb25OYW1lLnNwbGl0KCcuJyk7XHJcbiAgICBvcHRpb25zLnBhcmVudCA9IHJvb3ROYW1lO1xyXG4gICAgb3B0aW9ucy5yZWxhdGlvbkZpZWxkID0gcmVsYXRpb25OYW1lUGFydHNbMV07XHJcbiAgICBvcHRpb25zLmlzSW52ZXJ0ZWRSZWxhdGlvbiA9IHRydWU7XHJcbiAgICBvcHRpb25zLnRhcmdldFR5cGVOYW1lID0gcmVsYXRpb25OYW1lUGFydHNbMF07XHJcbiAgICBvcHRpb25zLmV4cGFuZEV4cHJlc3Npb24gPSBleHBhbmRFeHByZXNzaW9uO1xyXG4gICAgb3B0aW9ucy5wYXRoID0gcmVsYXRpb25OYW1lO1xyXG4gICAgb3B0aW9ucy5tYXhUYWtlVmFsdWUgPSB0aGlzLm1heFRha2VWYWx1ZTtcclxuICAgIG9wdGlvbnMudmFsaWRhdGVkID0gZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBSZWxhdGlvbk5vZGUob3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQW4gaW50ZXJuYWwgbWV0aG9kIHdoaWNoIHBhcnNlcyB0aGUgZXhwYW5kIGV4cHJlc3Npb24gYW5kIHByb2R1Y2VzIGEgYmFzaWMgcmVsYXRpb24gdHJlZSAob25seSBuYW1lcyBhbmQgcGFyZW50IHJlbGF0aW9ucykuXHJcbiAqIEBwYXJhbSBleHBhbmRFeHByZXNzaW9uIC0gVGhlIGV4cGFuZCBleHByZXNzaW9uIHdoaWNoIHdpbGwgYmUgcHJvY2Vzc2VkLlxyXG4gKiBAcGFyYW0gcm9vdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcm9vdCByZWxhdGlvbiAobWFzdGVyIHF1ZXJ5KSB1c3VhbGx5IHRoZSBuYW1lIG9mIHRoZSByZXF1ZXN0ZWQgY29udGVudCB0eXBlIChBY3Rpdml0aWVzKS5cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTWFwSW50ZXJuYWwgPSBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbiwgcm9vdE5hbWUpIHtcclxuICAgIGZvciAodmFyIHJlbGF0aW9uTmFtZSBpbiBleHBhbmRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgaWYgKGV4cGFuZEV4cHJlc3Npb24uaGFzT3duUHJvcGVydHkocmVsYXRpb25OYW1lKSkge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudEV4cHJlc3Npb24gPSBleHBhbmRFeHByZXNzaW9uW3JlbGF0aW9uTmFtZV07XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBvcHRpb24gaW4gY3VycmVudEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmIHBvc3NpYmxlRXhwYW5kT3B0aW9ucy5pbmRleE9mKG9wdGlvbikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXFwiJyArIG9wdGlvbiArICdcXFwiJyArICcgaXMgbm90IGEgdmFsaWQgb3B0aW9uIGZvciBFeHBhbmQgZXhwcmVzc2lvbicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVsYXRpb25OYW1lLmluZGV4T2YoJy4nKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJ0ZWRSZWxhdGlvbiA9IHRoaXMuY3JlYXRlSW52ZXJ0ZWRSZWxhdGlvbihyZWxhdGlvbk5hbWUsIGN1cnJlbnRFeHByZXNzaW9uLCByb290TmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcFtpbnZlcnRlZFJlbGF0aW9uLnBhdGhdID0gaW52ZXJ0ZWRSZWxhdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwW2ludmVydGVkUmVsYXRpb24ucGFyZW50XS5jaGlsZHJlbi5wdXNoKGludmVydGVkUmVsYXRpb24ucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGRzIGEgZmllbGQgZXhwcmVzc2lvbiBpbiB0aGUgb3JpZ2luYWwgZmllbGRzIGV4cHJlc3Npb24gaW4gb3JkZXIgdG8gZ2V0IHRoZSByZXN1bHQgZm9yIHRoYXQgZmllbGRcclxuICAgICAgICAgICAgICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24odGhpcy5tYXBbaW52ZXJ0ZWRSZWxhdGlvbi5wYXJlbnRdLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiwgaW52ZXJ0ZWRSZWxhdGlvbi51c2VyRGVmaW5lZE5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChleHBhbmRFeHByZXNzaW9uW3JlbGF0aW9uTmFtZV1bQ29uc3RhbnRzLkV4cGFuZEV4cHJlc3Npb25OYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRFeHBhbmRFeHByZXNzaW9uID0gdGhpcy5wcm9jZXNzRXhwYW5kRXhwcmVzc2lvbihleHBhbmRFeHByZXNzaW9uW3JlbGF0aW9uTmFtZV1bQ29uc3RhbnRzLkV4cGFuZEV4cHJlc3Npb25OYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZE1hcEludGVybmFsKHByb2Nlc3NlZEV4cGFuZEV4cHJlc3Npb24sIGludmVydGVkUmVsYXRpb24ucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZWxhdGlvbkZpZWxkID0gcmVsYXRpb25OYW1lO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJlbnQgPSByb290TmFtZTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXhwYW5kRXhwcmVzc2lvbiA9IGN1cnJlbnRFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tYXhUYWtlVmFsdWUgPSB0aGlzLm1heFRha2VWYWx1ZTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0VHlwZU5hbWUgPSBjdXJyZW50RXhwcmVzc2lvbltDb25zdGFudHMuVGFyZ2V0VHlwZU5hbWVGaWVsZE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uTm9kZSA9IG5ldyBSZWxhdGlvbk5vZGUob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMubWFwW29wdGlvbnMucGFyZW50XTtcclxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW4ucHVzaChyZWxhdGlvbk5vZGUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcFtyZWxhdGlvbk5vZGUucGF0aF0gPSByZWxhdGlvbk5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFeHByZXNzaW9uLmhhc093blByb3BlcnR5KENvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGN1cnJlbnRFeHByZXNzaW9uW0NvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZV0pID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkTWFwSW50ZXJuYWwodGhpcy5wcm9jZXNzRXhwYW5kRXhwcmVzc2lvbihjdXJyZW50RXhwcmVzc2lvbi5FeHBhbmQpLCByZWxhdGlvbk5vZGUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlbGF0aW9uTm9kZS5wYXRoICsgJy5FeHBhbmQgbXVzdCBiZSBhIHZhbGlkIGV4cGFuZCBleHByZXNzaW9uIScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFkZGl0aW9uYWwgbWV0YWRhdGEgd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIGV4ZWN1dGUgYSBxdWVyeS5cclxuICogTmFtZSBvZiB0aGUgY29udGVudCB0eXBlIG9mIHRoZSBjaGlsZCByZWxhdGlvbiBnZXQgdmlhIHJlbGF0aW9uIGZpZWxkLlxyXG4gKiBAcGFyYW0gZG9uZVxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuY29uZmlndXJlUmVsYXRpb25UcmVlID0gZnVuY3Rpb24gKGRvbmUpIHtcclxuICAgIGlmICh0aGlzLl9tZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb24pIHtcclxuICAgICAgICB2YXIgcmVsYXRpb25OYW1lcyA9IFtdO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcmVsIGluIHRoaXMubWFwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShyZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXBbcmVsXS5wYXJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGlvbk5hbWVzLnB1c2godGhpcy5tYXBbcmVsXS5yZWxhdGlvbkZpZWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uKHJlbGF0aW9uTmFtZXMsIHRoaXMubWFwLCB0aGlzLmNvbnRleHQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICBkb25lKGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkb25lKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUGVyZm9ybXMgc2V2ZXJhbCBjaGVja3MgbGlrZTpcclxuICogVmFsaWRpdHkgb2YgdGhlIHJlbGF0aW9uIGZpZWxkLlxyXG4gKiBUbyBub3QgdXNlIGZpbHRlciBvciBzb3J0aW5nIGV4cHJlc3Npb24gd2l0aGluIGEgXCJHZXRCeUZpbHRlclwiIHNjZW5hcmlvLlxyXG4gKiBEb2VzIG5vdCBhbGxvdyB0byBuZXN0IChleHBhbmQgbXVsdGlwbGUgcmVsYXRpb24gZmllbGQpIGFmdGVyIGEgbXVsdGlwbGUgcmVsYXRpb24uXHJcbiAqIERvZXMgbm90IGFsbG93IHRvIHVzZSBib3RoIFwiRmllbGRzXCIgYW5kIFwiU2luZ2xlRmllbGRcIiBvcHRpb25zLlxyXG4gKiBAcGFyYW0gZG9uZVxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLnZhbGlkYXRlUmVsYXRpb25UcmVlID0gZnVuY3Rpb24gKGRvbmUpIHtcclxuICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnJztcclxuICAgIHZhciBFT0wgPSAnXFxyXFxuJztcclxuICAgIGZvciAodmFyIHJlbGF0aW9uUGF0aCBpbiB0aGlzLm1hcCkge1xyXG4gICAgICAgIGlmIChyZWxhdGlvblBhdGggIT09ICckcm9vdCcgJiYgdGhpcy5tYXAuaGFzT3duUHJvcGVydHkocmVsYXRpb25QYXRoKSkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLm1hcFtyZWxhdGlvblBhdGhdO1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gdGhpcy52YWxpZGF0ZVNpbmdsZVJlbGF0aW9uKHJlbGF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmVGaWVsZHNFeHByZXNzaW9uc0ZvclJlbGF0aW9uKHJlbGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZXJyb3JNZXNzYWdlICE9PSAnJykge1xyXG4gICAgICAgIHZhciBmaW5hbEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZS5zdWJzdHIoMCwgZXJyb3JNZXNzYWdlLmxhc3RJbmRleE9mKEVPTCkpO1xyXG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihmaW5hbEVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyb3IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkb25lKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIHJlbGF0aW9uIGZpZWxkcyB0byBwYXJlbnQgcmVsYXRpb24gZmllbGRzIGV4cHJlc3Npb24gaWYgbmVlZGVkIChvdGhlcndpc2UgcmVsYXRpb24gY2Fubm90IGJlIGVzdGFibGlzaGVkKS5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gQSByZWxhdGlvbiB3aGljaCB3aWxsIGJlIGNvbmZpZ3VyZWQuXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5jb25maWd1cmVGaWVsZHNFeHByZXNzaW9uc0ZvclJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICBpZiAocmVsYXRpb24ucGFyZW50KSB7XHJcbiAgICAgICAgdmFyIHBhcmVudFJlbGF0aW9uRmllbGRzRXhwcmVzc2lvbiA9IHRoaXMubWFwW3JlbGF0aW9uLnBhcmVudF0uZmllbGRzRXhwcmVzc2lvbjtcclxuICAgICAgICBpZiAocmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24ocGFyZW50UmVsYXRpb25GaWVsZHNFeHByZXNzaW9uLCByZWxhdGlvbi5wYXJlbnRSZWxhdGlvbkZpZWxkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBSZWxhdGlvblRyZWVCdWlsZGVyLmFkZEZpZWxkVG9GaWVsZHNFeHByZXNzaW9uKHBhcmVudFJlbGF0aW9uRmllbGRzRXhwcmVzc2lvbiwgcmVsYXRpb24ucmVsYXRpb25GaWVsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24ocmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbiwgcmVsYXRpb24ucmVsYXRpb25GaWVsZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24ocmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbiwgQ29uc3RhbnRzLklkRmllbGROYW1lQ2xpZW50KTtcclxuICAgIH1cclxuICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRqdXN0UGFyZW50UmVsYXRpb25GaWVsZHNFeHByZXNzaW9uKHRoaXMubWFwW3JlbGF0aW9uLnBhcmVudF0sIHJlbGF0aW9uKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgYSBzaW5nbGUgcmVsYXRpb24gZm9yIGFsbCBidWlsZC1pbiBsaW1pdGF0aW9ucy5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gQSByZWxhdGlvbiB3aGljaCB3aWxsIGJlIHZhbGlkYXRlZC5cclxuICogQHJldHVybnMge3N0cmluZ30gLSBSZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2Ugd2l0aCBhbGwgZXJyb3JzIG9yIGVtcHR5IHN0cmluZyBpZiB0aGVyZSBpcyBubyBlcnJvcnMuXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS52YWxpZGF0ZVNpbmdsZVJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICB2YXIgZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICB2YXIgRU9MID0gJ1xcclxcbic7XHJcbiAgICB2YXIgaXNHZXRCeUZpbHRlclF1ZXJ5ID0gdGhpcy5tYXBbdGhpcy5tYXAuJHJvb3RdLmlzQXJyYXlSb290O1xyXG5cclxuICAgIGlmIChyZWxhdGlvbi5wYXRoID09PSByZWxhdGlvbi5wYXJlbnQpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gcmVsYXRpb24ucGF0aCArICcgaGFzIHNhbWUgcGFyZW50IHdoaWNoIHdpbGwgY2F1c2UgYW4gaW5maW5pdGUgbG9vcC4nICsgRU9MO1xyXG4gICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlbGF0aW9uLmlzQXJyYXkoKSkge1xyXG4gICAgICAgIHZhciBtdWx0aXBsZVF1ZXJpZXNDb3VudCA9IHRoaXMuZ2V0UGFyZW50TXVsdGlwbGVSZWxhdGlvbnNDb3VudChyZWxhdGlvbik7XHJcbiAgICAgICAgaWYgKG11bHRpcGxlUXVlcmllc0NvdW50ID4gMCkge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0V4cGFuZCBleHByZXNzaW9uIGhhcyBtdWx0aXBsZSByZWxhdGlvbiBcXFwiJyArIHJlbGF0aW9uLnBhdGggKyAnXFxcIiBpbnNpZGUgYSBtdWx0aXBsZSByZWxhdGlvbi4nO1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gRU9MO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubWFwW3JlbGF0aW9uLnBhcmVudF0gPT09IHRoaXMubWFwW3RoaXMubWFwLiRyb290XSAmJlxyXG4gICAgICAgICAgICBpc0dldEJ5RmlsdGVyUXVlcnkgJiZcclxuICAgICAgICAgICAgKHJlbGF0aW9uLmZpbHRlckV4cHJlc3Npb24gfHwgcmVsYXRpb24uc29ydEV4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSAnRmlsdGVyIGFuZCBTb3J0IGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCB3aXRoIEdldEJ5RmlsdGVyIHNjZW5hcmlvLic7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBFT0w7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNHZXRCeUZpbHRlclF1ZXJ5ICYmIHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0V4cGFuZGluZyBhbiBleHRlcm5hbCBjb250ZW50IHR5cGUgaXMgbm90IGFsbG93ZWQgd2l0aCBHZXRCeUZpbHRlciBzY2VuYXJpby4nO1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gRU9MO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmVsYXRpb24udmFsaWRhdGVkKSB7XHJcbiAgICAgICAgaWYgKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0NvbnRlbnQgdHlwZSBcXFwiJyArIHJlbGF0aW9uLnRhcmdldFR5cGVOYW1lICsgJ1xcXCInO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRSZWxhdGlvbiA9IHJlbGF0aW9uLnBhcmVudDtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICdDb250ZW50IHR5cGUgXFxcIicgKyB0aGlzLm1hcFtwYXJlbnRSZWxhdGlvbl0udGFyZ2V0VHlwZU5hbWUgKyAnXFxcIic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSAnIGRvZXMgbm90IGNvbnRhaW4gXFxcIicgKyByZWxhdGlvbi5yZWxhdGlvbkZpZWxkICsgJ1xcXCInICsgJyByZWxhdGlvbiBmaWVsZC4nO1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSBFT0w7XHJcbiAgICB9XHJcbiAgICBpZiAocmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbiAmJiBPYmplY3Qua2V5cyhyZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uKS5sZW5ndGggJiYgcmVsYXRpb24uc2luZ2xlRmllbGROYW1lKSB7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IHJlbGF0aW9uLnBhdGggKyAnICc7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9ICdleHBhbmQgZXhwcmVzc2lvbiBjb250YWlucyBib3RoIFxcXCJGaWVsZHNcXFwiIGFuZCBcXFwiU2luZ2xlRmllbGRcXFwiIGV4cHJlc3Npb25zLic7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcclxuICAgIH1cclxuICAgIGlmIChyZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWUpIHtcclxuICAgICAgICBpZiAocmVsYXRpb24uY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSByZWxhdGlvbi5wYXRoICsgJyBoYXMgbXVsdGlwbGUgZXhwYW5kIGV4cHJlc3Npb25zIHdpdGggYSBzaW5nbGUgZmllbGQgb3B0aW9uLicgKyBFT0w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1hcFtyZWxhdGlvbi5jaGlsZHJlblswXV0ucmVsYXRpb25GaWVsZCAhPT0gcmVsYXRpb24uc2luZ2xlRmllbGROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0V4cGFuZCBleHByZXNzaW9uICcgKyByZWxhdGlvbi5wYXRoO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICcgc2luZ2xlIGZpZWxkIFxcXCInICsgcmVsYXRpb24uc2luZ2xlRmllbGROYW1lICsgJ1xcXCInO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICcgZG9lcyBub3QgbWF0Y2ggY2hpbGQgcmVsYXRpb24gZmllbGQgXFxcIicgKyB0aGlzLm1hcFtyZWxhdGlvbi5jaGlsZHJlblswXV0ucmVsYXRpb25GaWVsZCArICdcXFwiLic7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gRU9MO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgY291bnQgb2YgcGFyZW50IG11bHRpcGxlIHJlbGF0aW9ucy5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gU3RhcnRpbmcgcmVsYXRpb24uXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gY291bnQgb2YgYWxsIHBhcmVudCBtdWx0aXBsZSByZWxhdGlvbnNcclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldFBhcmVudE11bHRpcGxlUmVsYXRpb25zQ291bnQgPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIHZhciByZXN1bHQgPSAwO1xyXG4gICAgdmFyIHJlbGF0aW9uRm9yTG9vcCA9IHJlbGF0aW9uO1xyXG4gICAgd2hpbGUgKHJlbGF0aW9uRm9yTG9vcC5wYXJlbnQpIHtcclxuICAgICAgICB2YXIgcGFyZW50UmVsYXRpb24gPSB0aGlzLm1hcFtyZWxhdGlvbkZvckxvb3AucGFyZW50XTtcclxuICAgICAgICBpZiAocGFyZW50UmVsYXRpb24uaXNBcnJheSgpICYmIHBhcmVudFJlbGF0aW9uLnBhcmVudCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVsYXRpb25Gb3JMb29wID0gcGFyZW50UmVsYXRpb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBZGp1c3RzIGZpZWxkcyBleHByZXNzaW9uIG9mIHRoZSBwYXJlbnQgcmVsYXRpb24gYmFzZWQgb24gcGFnaW5nIHNldHRpbmcgb2YgYSByZWxhdGlvbiAoc2tpcCwgdGFrZSkuXHJcbiAqIEluIHRoYXQgY2FzZSB3ZSBwdXQgYSBcIiRzbGljZVwiIG9wdGlvbiB3aXRoaW4gdGhlIHBhcmVudCByZWxhdGlvbiBmaWVsZHMgZXhwcmVzc2lvbi5cclxuICogQHBhcmFtIHBhcmVudFJlbGF0aW9uXHJcbiAqIEBwYXJhbSByZWxhdGlvblxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5hZGp1c3RQYXJlbnRSZWxhdGlvbkZpZWxkc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAocGFyZW50UmVsYXRpb24sIHJlbGF0aW9uKSB7XHJcbiAgICAvL1RPRE86IG1ha2UgaXQgZHluYW1pYyBpbiBleGVjdXRpb24gbm9kZVxyXG5cclxuICAgIGlmICghcmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uICYmIHJlbGF0aW9uLnRha2UgJiYgdHlwZW9mIHJlbGF0aW9uLnRha2UgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgLy8gd2hlbiByZWxhdGlvbiBoYXMgZmlsdGVyIG9yIHNvcnRpbmcgc2tpcCBhbmQgdGFrZSBzaG91bGQgbm90IGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwYXJlbnQgcmVsYXRpb24gYXMgJHNsaWNlLlxyXG4gICAgICAgIHZhciBzaG91bGRUcmFuc2ZlclBhZ2luZ1RvUGFyZW50UmVsYXRpb24gPSByZWxhdGlvbi5pc0FycmF5KCkgJiYgIXJlbGF0aW9uLmZpbHRlckV4cHJlc3Npb24gJiYgIXJlbGF0aW9uLnNvcnRFeHByZXNzaW9uICYmIHBhcmVudFJlbGF0aW9uO1xyXG4gICAgICAgIGlmIChzaG91bGRUcmFuc2ZlclBhZ2luZ1RvUGFyZW50UmVsYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudFJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50UmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbiA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVsYXRpb24uc2tpcCAmJiB0eXBlb2YgcmVsYXRpb24uc2tpcCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb25bcmVsYXRpb24ucmVsYXRpb25GaWVsZF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJyRzbGljZSc6IFtyZWxhdGlvbi5za2lwLCByZWxhdGlvbi50YWtlXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb25bcmVsYXRpb24ucmVsYXRpb25GaWVsZF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJyRzbGljZSc6IHJlbGF0aW9uLnRha2VcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVsYXRpb24udGFrZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJlbGF0aW9uLnNraXAgPSBudWxsO1xyXG4gICAgICAgICAgICByZWxhdGlvbi5tb3ZlZFNraXBUYWtlQXNTbGljZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgZmllbGQgdG8gcGFyZW50IHJlbGF0aW9uIGZpZWxkcyBleHByZXNzaW9uLiBGb3IgZXhhbXBsZSBpZiB0aGUgcmVsYXRpb24gZmllbGQgaXMgZXhjbHVkZWQgZnJvbSB0aGUgbWFzdGVyIHJlcXVlc3QuXHJcbiAqIEBwYXJhbSBmaWVsZHNFeHByZXNzaW9uIC0gRmllbGRzIGV4cHJlc3Npb24gb2YgdGhlIHBhcmVudCByZWxhdGlvbi5cclxuICogQHBhcmFtIHJlbGF0aW9uRmllbGQgLSBOYW1lIG9mIHRoZSBmaWVsZCB3aGljaCBzaG91bGQgYmUgcmV0dXJuZWQuXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLmFkZEZpZWxkVG9GaWVsZHNFeHByZXNzaW9uID0gZnVuY3Rpb24gKGZpZWxkc0V4cHJlc3Npb24sIHJlbGF0aW9uRmllbGQpIHtcclxuICAgIGlmIChmaWVsZHNFeHByZXNzaW9uID09PSB1bmRlZmluZWQgfHwgT2JqZWN0LmtleXMoZmllbGRzRXhwcmVzc2lvbikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGlzRXhjbHVzaXZlID0gUmVsYXRpb25UcmVlQnVpbGRlci5nZXRJc0ZpZWxkc0V4cHJlc3Npb25FeGNsdXNpdmUoZmllbGRzRXhwcmVzc2lvbik7XHJcblxyXG4gICAgaWYgKGlzRXhjbHVzaXZlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgZGVsZXRlIGZpZWxkc0V4cHJlc3Npb25bcmVsYXRpb25GaWVsZF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZpZWxkc0V4cHJlc3Npb25bcmVsYXRpb25GaWVsZF0gPSAxO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgaWYgdGhlIGZpZWxkcyBleHByZXNzaW9uIGlzIGV4Y2x1c2l2ZSAoXCJGaWVsZE5hbWVcIiA6IDApXHJcbiAqIEBwYXJhbSBmaWVsZHNFeHByZXNzaW9uIC0gRmllbGRzIGV4cHJlc3Npb24gdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5nZXRJc0ZpZWxkc0V4cHJlc3Npb25FeGNsdXNpdmUgPSBmdW5jdGlvbiAoZmllbGRzRXhwcmVzc2lvbikge1xyXG4gICAgdmFyIGlzRXhjbHVzaXZlO1xyXG4gICAgZm9yICh2YXIgZmllbGROYW1lIGluIGZpZWxkc0V4cHJlc3Npb24pIHtcclxuICAgICAgICBpZiAoZmllbGROYW1lICE9PSBDb25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQgJiYgZmllbGRzRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShmaWVsZE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0V4Y2x1c2l2ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRzRXhwcmVzc2lvbltmaWVsZE5hbWVdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNFeGNsdXNpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkc0V4cHJlc3Npb25bZmllbGROYW1lXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGRzRXhwcmVzc2lvbltmaWVsZE5hbWVdID09PSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXhjbHVzaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpc0V4Y2x1c2l2ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVsYXRpb25UcmVlQnVpbGRlcjtcclxuIiwiLyohXHJcbiAqIGFzeW5jXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYW9sYW4vYXN5bmNcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTAtMjAxNCBDYW9sYW4gTWNNYWhvblxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qanNoaW50IG9uZXZhcjogZmFsc2UsIGluZGVudDo0ICovXHJcbi8qZ2xvYmFsIHNldEltbWVkaWF0ZTogZmFsc2UsIHNldFRpbWVvdXQ6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBhc3luYyA9IHt9O1xyXG5cclxuICAgIC8vIGdsb2JhbCBvbiB0aGUgc2VydmVyLCB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcclxuICAgIHZhciByb290LCBwcmV2aW91c19hc3luYztcclxuXHJcbiAgICByb290ID0gdGhpcztcclxuICAgIGlmIChyb290ICE9IG51bGwpIHtcclxuICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcm9vdC5hc3luYyA9IHByZXZpb3VzX2FzeW5jO1xyXG4gICAgICAgIHJldHVybiBhc3luYztcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gb25seV9vbmNlKGZuKSB7XHJcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKGNhbGxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcclxuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm4uYXBwbHkocm9vdCwgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vLyBjcm9zcy1icm93c2VyIGNvbXBhdGlibGl0eSBmdW5jdGlvbnMgLy8vL1xyXG5cclxuICAgIHZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2VhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xyXG4gICAgICAgIGlmIChhcnIuZm9yRWFjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyLmZvckVhY2goaXRlcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbaV0sIGksIGFycik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX21hcCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKGFyci5tYXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyci5tYXAoaXRlcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yKHgsIGksIGEpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWVtbykge1xyXG4gICAgICAgIGlmIChhcnIucmVkdWNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xyXG4gICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IobWVtbywgeCwgaSwgYSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xyXG5cclxuICAgIC8vLy8gbmV4dFRpY2sgaW1wbGVtZW50YXRpb24gd2l0aCBicm93c2VyLWNvbXBhdGlibGUgZmFsbGJhY2sgLy8vL1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhKHByb2Nlc3MubmV4dFRpY2spKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcclxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIG9ubHlfb25jZShkb25lKSApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyKSB7XHJcbiAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBhc3luYy5mb3JFYWNoID0gYXN5bmMuZWFjaDtcclxuXHJcbiAgICBhc3luYy5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xyXG4gICAgICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbY29tcGxldGVkXSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpdGVyYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgYXN5bmMuZm9yRWFjaFNlcmllcyA9IGFzeW5jLmVhY2hTZXJpZXM7XHJcblxyXG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBmbiA9IF9lYWNoTGltaXQobGltaXQpO1xyXG4gICAgICAgIGZuLmFwcGx5KG51bGwsIFthcnIsIGl0ZXJhdG9yLCBjYWxsYmFja10pO1xyXG4gICAgfTtcclxuICAgIGFzeW5jLmZvckVhY2hMaW1pdCA9IGFzeW5jLmVhY2hMaW1pdDtcclxuXHJcbiAgICB2YXIgX2VhY2hMaW1pdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgIGlmICghYXJyLmxlbmd0aCB8fCBsaW1pdCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgcnVubmluZyA9IDA7XHJcblxyXG4gICAgICAgICAgICAoZnVuY3Rpb24gcmVwbGVuaXNoICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgc3RhcnRlZCA8IGFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydGVkICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycltzdGFydGVkIC0gMV0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB2YXIgZG9QYXJhbGxlbCA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgdmFyIGRvUGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0LCBmbikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFtfZWFjaExpbWl0KGxpbWl0KV0uY29uY2F0KGFyZ3MpKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciBkb1NlcmllcyA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoU2VyaWVzXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB2YXIgX2FzeW5jTWFwID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW3guaW5kZXhdID0gdjtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBhc3luYy5tYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XHJcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xyXG4gICAgYXN5bmMubWFwTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIF9tYXBMaW1pdChsaW1pdCkoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX21hcExpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcclxuICAgICAgICByZXR1cm4gZG9QYXJhbGxlbExpbWl0KGxpbWl0LCBfYXN5bmNNYXApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XHJcbiAgICAvLyB3b3JrIGluIG1hbnkgc2l0dWF0aW9ucy5cclxuICAgIGFzeW5jLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IobWVtbywgeCwgZnVuY3Rpb24gKGVyciwgdikge1xyXG4gICAgICAgICAgICAgICAgbWVtbyA9IHY7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gaW5qZWN0IGFsaWFzXHJcbiAgICBhc3luYy5pbmplY3QgPSBhc3luYy5yZWR1Y2U7XHJcbiAgICAvLyBmb2xkbCBhbGlhc1xyXG4gICAgYXN5bmMuZm9sZGwgPSBhc3luYy5yZWR1Y2U7XHJcblxyXG4gICAgYXN5bmMucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xyXG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICAvLyBmb2xkciBhbGlhc1xyXG4gICAgYXN5bmMuZm9sZHIgPSBhc3luYy5yZWR1Y2VSaWdodDtcclxuXHJcbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XHJcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBhc3luYy5maWx0ZXIgPSBkb1BhcmFsbGVsKF9maWx0ZXIpO1xyXG4gICAgYXN5bmMuZmlsdGVyU2VyaWVzID0gZG9TZXJpZXMoX2ZpbHRlcik7XHJcbiAgICAvLyBzZWxlY3QgYWxpYXNcclxuICAgIGFzeW5jLnNlbGVjdCA9IGFzeW5jLmZpbHRlcjtcclxuICAgIGFzeW5jLnNlbGVjdFNlcmllcyA9IGFzeW5jLmZpbHRlclNlcmllcztcclxuXHJcbiAgICB2YXIgX3JlamVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xyXG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcclxuICAgIGFzeW5jLnJlamVjdFNlcmllcyA9IGRvU2VyaWVzKF9yZWplY3QpO1xyXG5cclxuICAgIHZhciBfZGV0ZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xyXG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh4KTtcclxuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBhc3luYy5kZXRlY3QgPSBkb1BhcmFsbGVsKF9kZXRlY3QpO1xyXG4gICAgYXN5bmMuZGV0ZWN0U2VyaWVzID0gZG9TZXJpZXMoX2RldGVjdCk7XHJcblxyXG4gICAgYXN5bmMuc29tZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XHJcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gYW55IGFsaWFzXHJcbiAgICBhc3luYy5hbnkgPSBhc3luYy5zb21lO1xyXG5cclxuICAgIGFzeW5jLmV2ZXJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcclxuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gYWxsIGFsaWFzXHJcbiAgICBhc3luYy5hbGwgPSBhc3luYy5ldmVyeTtcclxuXHJcbiAgICBhc3luYy5zb3J0QnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKGVyciwgY3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChmbiksIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuYXV0byA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgIHZhciBrZXlzID0gX2tleXModGFza3MpO1xyXG4gICAgICAgIHZhciByZW1haW5pbmdUYXNrcyA9IGtleXMubGVuZ3RoXHJcbiAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XHJcblxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB2YXIgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoZm4pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdGFza0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZW1haW5pbmdUYXNrcy0tXHJcbiAgICAgICAgICAgIF9lYWNoKGxpc3RlbmVycy5zbGljZSgwKSwgZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgICAgICBmbigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBhZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBmaW5hbCBjYWxsYmFjayBmcm9tIGNhbGxpbmcgaXRzZWxmIGlmIGl0IGVycm9yc1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGVDYWxsYmFjayhudWxsLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfZWFjaChrZXlzLCBmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICB2YXIgdGFzayA9IF9pc0FycmF5KHRhc2tzW2tdKSA/IHRhc2tzW2tdOiBbdGFza3Nba11dO1xyXG4gICAgICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2FmZVJlc3VsdHMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBfZWFjaChfa2V5cyhyZXN1bHRzKSwgZnVuY3Rpb24ocmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHJlc3VsdHNbcmtleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba10gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3Agc3Vic2VxdWVudCBlcnJvcnMgaGl0dGluZyBjYWxsYmFjayBtdWx0aXBsZSB0aW1lc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcclxuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUodGFza0NvbXBsZXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHJlcXVpcmVzID0gdGFzay5zbGljZSgwLCBNYXRoLmFicyh0YXNrLmxlbmd0aCAtIDEpKSB8fCBbXTtcclxuICAgICAgICAgICAgdmFyIHJlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2UocmVxdWlyZXMsIGZ1bmN0aW9uIChhLCB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhICYmIHJlc3VsdHMuaGFzT3duUHJvcGVydHkoeCkpO1xyXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSkgJiYgIXJlc3VsdHMuaGFzT3duUHJvcGVydHkoayk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMucmV0cnkgPSBmdW5jdGlvbih0aW1lcywgdGFzaywgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgREVGQVVMVF9USU1FUyA9IDU7XHJcbiAgICAgICAgdmFyIGF0dGVtcHRzID0gW107XHJcbiAgICAgICAgLy8gVXNlIGRlZmF1bHRzIGlmIHRpbWVzIG5vdCBwYXNzZWRcclxuICAgICAgICBpZiAodHlwZW9mIHRpbWVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGFzaztcclxuICAgICAgICAgICAgdGFzayA9IHRpbWVzO1xyXG4gICAgICAgICAgICB0aW1lcyA9IERFRkFVTFRfVElNRVM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aW1lcyBpcyBhIG51bWJlclxyXG4gICAgICAgIHRpbWVzID0gcGFyc2VJbnQodGltZXMsIDEwKSB8fCBERUZBVUxUX1RJTUVTO1xyXG4gICAgICAgIHZhciB3cmFwcGVkVGFzayA9IGZ1bmN0aW9uKHdyYXBwZWRDYWxsYmFjaywgd3JhcHBlZFJlc3VsdHMpIHtcclxuICAgICAgICAgICAgdmFyIHJldHJ5QXR0ZW1wdCA9IGZ1bmN0aW9uKHRhc2ssIGZpbmFsQXR0ZW1wdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllc0NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzayhmdW5jdGlvbihlcnIsIHJlc3VsdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0NhbGxiYWNrKCFlcnIgfHwgZmluYWxBdHRlbXB0LCB7ZXJyOiBlcnIsIHJlc3VsdDogcmVzdWx0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgd3JhcHBlZFJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2hpbGUgKHRpbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRlbXB0cy5wdXNoKHJldHJ5QXR0ZW1wdCh0YXNrLCAhKHRpbWVzLT0xKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzeW5jLnNlcmllcyhhdHRlbXB0cywgZnVuY3Rpb24oZG9uZSwgZGF0YSl7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgKHdyYXBwZWRDYWxsYmFjayB8fCBjYWxsYmFjaykoZGF0YS5lcnIsIGRhdGEucmVzdWx0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGEgY2FsbGJhY2sgaXMgcGFzc2VkLCBydW4gdGhpcyBhcyBhIGNvbnRyb2xsIGZsb3dcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPyB3cmFwcGVkVGFzaygpIDogd3JhcHBlZFRhc2tcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMud2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgaWYgKCFfaXNBcnJheSh0YXNrcykpIHtcclxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xyXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd3JhcEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwSXRlcmF0b3IobmV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX3BhcmFsbGVsID0gZnVuY3Rpb24oZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcclxuICAgICAgICAgICAgZWFjaGZuLm1hcCh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XHJcbiAgICAgICAgICAgIGVhY2hmbi5lYWNoKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMucGFyYWxsZWwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBhc3luYy5tYXAsIGVhY2g6IGFzeW5jLmVhY2ggfSwgdGFza3MsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcclxuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IF9tYXBMaW1pdChsaW1pdCksIGVhY2g6IF9lYWNoTGltaXQobGltaXQpIH0sIHRhc2tzLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnNlcmllcyA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcclxuICAgICAgICAgICAgYXN5bmMubWFwU2VyaWVzKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcclxuICAgICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XHJcbiAgICAgICAgdmFyIG1ha2VDYWxsYmFjayA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFza3NbaW5kZXhdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBmbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBtYWtlQ2FsbGJhY2soMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLmFwcGx5ID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShcclxuICAgICAgICAgICAgICAgIG51bGwsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9jb25jYXQgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGZuLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciByID0gW107XHJcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNiKSB7XHJcbiAgICAgICAgICAgIGZuKHgsIGZ1bmN0aW9uIChlcnIsIHkpIHtcclxuICAgICAgICAgICAgICAgIHIgPSByLmNvbmNhdCh5IHx8IFtdKTtcclxuICAgICAgICAgICAgICAgIGNiKGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBhc3luYy5jb25jYXQgPSBkb1BhcmFsbGVsKF9jb25jYXQpO1xyXG4gICAgYXN5bmMuY29uY2F0U2VyaWVzID0gZG9TZXJpZXMoX2NvbmNhdCk7XHJcblxyXG4gICAgYXN5bmMud2hpbHN0ID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICh0ZXN0KCkpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXN5bmMud2hpbHN0KHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLmRvV2hpbHN0ID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICBpZiAodGVzdC5hcHBseShudWxsLCBhcmdzKSkge1xyXG4gICAgICAgICAgICAgICAgYXN5bmMuZG9XaGlsc3QoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMudW50aWwgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCF0ZXN0KCkpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXN5bmMudW50aWwodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuZG9VbnRpbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcclxuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgaWYgKCF0ZXN0LmFwcGx5KG51bGwsIGFyZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICBhc3luYy5kb1VudGlsKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcclxuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgaWYgKCFxLnN0YXJ0ZWQpe1xyXG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xyXG4gICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbikge1xyXG4gICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXHJcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcclxuICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICBpZiAocG9zKSB7XHJcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHEudGFza3MucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xyXG4gICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHdvcmtlcnMgPSAwO1xyXG4gICAgICAgIHZhciBxID0ge1xyXG4gICAgICAgICAgICB0YXNrczogW10sXHJcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcclxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxyXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcclxuICAgICAgICAgICAgZHJhaW46IG51bGwsXHJcbiAgICAgICAgICAgIHN0YXJ0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXVzZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBxLmRyYWluID0gbnVsbDtcclxuICAgICAgICAgICAgICBxLnRhc2tzID0gW107XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgdHJ1ZSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXEucGF1c2VkICYmIHdvcmtlcnMgPCBxLmNvbmN1cnJlbmN5ICYmIHEudGFza3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBxLnRhc2tzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEuZW1wdHkgJiYgcS50YXNrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2suY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbiAmJiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlfb25jZShuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB3b3JrZXIodGFzay5kYXRhLCBjYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VycztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaWRsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSB0cnVlKSB7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhc3luYy5wcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcclxuICAgICAgICBcclxuICAgICAgICBmdW5jdGlvbiBfY29tcGFyZVRhc2tzKGEsIGIpe1xyXG4gICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gX2JpbmFyeVNlYXJjaChzZXF1ZW5jZSwgaXRlbSwgY29tcGFyZSkge1xyXG4gICAgICAgICAgdmFyIGJlZyA9IC0xLFxyXG4gICAgICAgICAgICAgIGVuZCA9IHNlcXVlbmNlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICB3aGlsZSAoYmVnIDwgZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBtaWQgPSBiZWcgKyAoKGVuZCAtIGJlZyArIDEpID4+PiAxKTtcclxuICAgICAgICAgICAgaWYgKGNvbXBhcmUoaXRlbSwgc2VxdWVuY2VbbWlkXSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgIGJlZyA9IG1pZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gYmVnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgaWYgKCFxLnN0YXJ0ZWQpe1xyXG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xyXG4gICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbikge1xyXG4gICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXHJcbiAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcclxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoX2JpbmFyeVNlYXJjaChxLnRhc2tzLCBpdGVtLCBfY29tcGFyZVRhc2tzKSArIDEsIDAsIGl0ZW0pO1xyXG5cclxuICAgICAgICAgICAgICBpZiAocS5zYXR1cmF0ZWQgJiYgcS50YXNrcy5sZW5ndGggPT09IHEuY29uY3VycmVuY3kpIHtcclxuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxyXG4gICAgICAgIHZhciBxID0gYXN5bmMucXVldWUod29ya2VyLCBjb25jdXJyZW5jeSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHlcclxuICAgICAgICBxLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjayk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvblxyXG4gICAgICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5jYXJnbyA9IGZ1bmN0aW9uICh3b3JrZXIsIHBheWxvYWQpIHtcclxuICAgICAgICB2YXIgd29ya2luZyAgICAgPSBmYWxzZSxcclxuICAgICAgICAgICAgdGFza3MgICAgICAgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIGNhcmdvID0ge1xyXG4gICAgICAgICAgICB0YXNrczogdGFza3MsXHJcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXHJcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcclxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXHJcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxyXG4gICAgICAgICAgICBkcmFpbmVkOiB0cnVlLFxyXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FyZ28uZHJhaW5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXJnby5zYXR1cmF0ZWQgJiYgdGFza3MubGVuZ3RoID09PSBwYXlsb2FkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmdvLnNhdHVyYXRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGNhcmdvLnByb2Nlc3MpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihjYXJnby5kcmFpbiAmJiAhY2FyZ28uZHJhaW5lZCkgY2FyZ28uZHJhaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJnby5kcmFpbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRzID0gdHlwZW9mIHBheWxvYWQgPT09ICdudW1iZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhc2tzLnNwbGljZSgwLCBwYXlsb2FkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXNrcy5zcGxpY2UoMCwgdGFza3MubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZHMgPSBfbWFwKHRzLCBmdW5jdGlvbiAodGFzaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihjYXJnby5lbXB0eSkgY2FyZ28uZW1wdHkoKTtcclxuICAgICAgICAgICAgICAgIHdvcmtpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgd29ya2VyKGRzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgICAgICAgICBfZWFjaCh0cywgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2tzLmxlbmd0aDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjYXJnbztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9jb25zb2xlX2ZuID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZWFjaChhcmdzLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZVtuYW1lXSh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XSkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xyXG4gICAgYXN5bmMuZGlyID0gX2NvbnNvbGVfZm4oJ2RpcicpO1xyXG4gICAgLyphc3luYy5pbmZvID0gX2NvbnNvbGVfZm4oJ2luZm8nKTtcclxuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xyXG4gICAgYXN5bmMuZXJyb3IgPSBfY29uc29sZV9mbignZXJyb3InKTsqL1xyXG5cclxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xyXG4gICAgICAgIHZhciBtZW1vID0ge307XHJcbiAgICAgICAgdmFyIHF1ZXVlcyA9IHt9O1xyXG4gICAgICAgIGhhc2hlciA9IGhhc2hlciB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIG1lbW8pIHtcclxuICAgICAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107XHJcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBxW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XHJcbiAgICAgICAgbWVtb2l6ZWQudW5tZW1vaXplZCA9IGZuO1xyXG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMudW5tZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy50aW1lcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXN5bmMubWFwKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnRpbWVzU2VyaWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc3luYy5tYXBTZXJpZXMoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuc2VxID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xyXG4gICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XHJcbiAgICAgICAgICAgIGFzeW5jLnJlZHVjZShmbnMsIGFyZ3MsIGZ1bmN0aW9uIChuZXdhcmdzLCBmbiwgY2IpIHtcclxuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfV0pKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5jb21wb3NlID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xyXG4gICAgICByZXR1cm4gYXN5bmMuc2VxLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoYXJndW1lbnRzKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfYXBwbHlFYWNoID0gZnVuY3Rpb24gKGVhY2hmbiwgZm5zIC8qYXJncy4uLiovKSB7XHJcbiAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgY2IpIHtcclxuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KFtjYl0pKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FsbGJhY2spO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdvO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBhc3luYy5hcHBseUVhY2ggPSBkb1BhcmFsbGVsKF9hcHBseUVhY2gpO1xyXG4gICAgYXN5bmMuYXBwbHlFYWNoU2VyaWVzID0gZG9TZXJpZXMoX2FwcGx5RWFjaCk7XHJcblxyXG4gICAgYXN5bmMuZm9yZXZlciA9IGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcclxuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmbihuZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBOb2RlLmpzXHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xyXG4gICAgfVxyXG4gICAgLy8gQU1EIC8gUmVxdWlyZUpTXHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhc3luYztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIGluY2x1ZGVkIGRpcmVjdGx5IHZpYSA8c2NyaXB0PiB0YWdcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJvb3QuYXN5bmMgPSBhc3luYztcclxuICAgIH1cclxuXHJcbn0oKSk7XHJcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4yXHJcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xyXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xyXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgLy8gQmFzZWxpbmUgc2V0dXBcclxuICAvLyAtLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXHJcbiAgdmFyIHJvb3QgPSB0aGlzO1xyXG5cclxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxyXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XHJcblxyXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XHJcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xyXG5cclxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cclxuICB2YXJcclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXHJcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcclxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcclxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXHJcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXHJcbiAgdmFyXHJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxyXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXHJcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZCxcclxuICAgIG5hdGl2ZUNyZWF0ZSAgICAgICA9IE9iamVjdC5jcmVhdGU7XHJcblxyXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cclxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcclxuXHJcbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXHJcbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xyXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcclxuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XHJcbiAgfTtcclxuXHJcbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcclxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXHJcbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxyXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5fID0gXztcclxuICB9IGVsc2Uge1xyXG4gICAgcm9vdC5fID0gXztcclxuICB9XHJcblxyXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cclxuICBfLlZFUlNJT04gPSAnMS44LjInO1xyXG5cclxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXHJcbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcclxuICAvLyBmdW5jdGlvbnMuXHJcbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xyXG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XHJcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcclxuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcclxuICAgICAgfTtcclxuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xyXG4gICAgICB9O1xyXG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XHJcbiAgICAgIH07XHJcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxyXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cclxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcclxuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xyXG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcclxuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcclxuICB9O1xyXG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cclxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XHJcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcclxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXHJcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICBpZiAoIXVuZGVmaW5lZE9ubHkgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cclxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xyXG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcclxuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcclxuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xyXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xyXG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cclxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XHJcbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcclxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcclxuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uLmxlbmd0aDtcclxuICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8PSBNQVhfQVJSQVlfSU5ERVg7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cclxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXHJcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cclxuICBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xyXG4gICAgdmFyIGksIGxlbmd0aDtcclxuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcclxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cclxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcclxuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xyXG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcclxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcclxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcclxuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9O1xyXG5cclxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cclxuICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoZGlyKSB7XHJcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxyXG4gICAgZnVuY3Rpb24gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCkge1xyXG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcclxuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XHJcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCk7XHJcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXHJcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcclxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xyXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleF07XHJcbiAgICAgICAgaW5kZXggKz0gZGlyO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXHJcbiAgLy8gb3IgYGZvbGRsYC5cclxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGNyZWF0ZVJlZHVjZSgxKTtcclxuXHJcbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXHJcbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXHJcbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xyXG4gICAgdmFyIGtleTtcclxuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XHJcbiAgICAgIGtleSA9IF8uZmluZEluZGV4KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGtleSA9IF8uZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXHJcbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cclxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcclxuICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xyXG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cclxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XHJcbiAgfTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXHJcbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cclxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xyXG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcclxuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXHJcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XHJcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXHJcbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cclxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XHJcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xyXG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcclxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcclxuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cclxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cclxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcclxuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcclxuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCB0YXJnZXQsIHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicgJiYgZnJvbUluZGV4KSA+PSAwO1xyXG4gIH07XHJcblxyXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxyXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcclxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xyXG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xyXG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cclxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcclxuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xyXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXHJcbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcclxuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xyXG4gIH07XHJcblxyXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcclxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxyXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xyXG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cclxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcclxuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcclxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XHJcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xyXG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xyXG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xyXG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cclxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcclxuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXHJcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xyXG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcclxuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcclxuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XHJcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcclxuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcclxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXHJcbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XHJcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcclxuICAgIHZhciBzaHVmZmxlZCA9IEFycmF5KGxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XHJcbiAgICAgIGlmIChyYW5kICE9PSBpbmRleCkgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XHJcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcclxuICAgIH1cclxuICAgIHJldHVybiBzaHVmZmxlZDtcclxuICB9O1xyXG5cclxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbi5cclxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxyXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXHJcbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XHJcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XHJcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcclxuICAgICAgcmV0dXJuIG9ialtfLnJhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcclxuICB9O1xyXG5cclxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXHJcbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KVxyXG4gICAgICB9O1xyXG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xyXG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XHJcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XHJcbiAgICAgIGlmIChhICE9PSBiKSB7XHJcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XHJcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XHJcbiAgICB9KSwgJ3ZhbHVlJyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxyXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xyXG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcclxuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xyXG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXHJcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXHJcbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XHJcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XHJcbiAgfSk7XHJcblxyXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXHJcbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XHJcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xyXG4gIH0pO1xyXG5cclxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcclxuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcclxuICAvLyBjcml0ZXJpb24uXHJcbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XHJcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcclxuICB9KTtcclxuXHJcbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cclxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmICghb2JqKSByZXR1cm4gW107XHJcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XHJcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XHJcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXHJcbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xyXG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xyXG4gIH07XHJcblxyXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cclxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXHJcbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xyXG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcclxuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcclxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xyXG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBbcGFzcywgZmFpbF07XHJcbiAgfTtcclxuXHJcbiAgLy8gQXJyYXkgRnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxyXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcclxuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXHJcbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xyXG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XHJcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XHJcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cclxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxyXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXHJcbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XHJcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xyXG4gIH07XHJcblxyXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cclxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxyXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xyXG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XHJcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XHJcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxyXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXHJcbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LlxyXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xyXG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcclxuICB9O1xyXG5cclxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXHJcbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxyXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgc3RhcnRJbmRleCkge1xyXG4gICAgdmFyIG91dHB1dCA9IFtdLCBpZHggPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gaW5wdXQgJiYgaW5wdXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XHJcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XHJcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxyXG4gICAgICAgIGlmICghc2hhbGxvdykgdmFsdWUgPSBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QpO1xyXG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xyXG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xyXG4gICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XHJcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xyXG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxuICB9O1xyXG5cclxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXHJcbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcclxuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBmYWxzZSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXHJcbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcclxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXHJcbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cclxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcclxuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XHJcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xyXG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XHJcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XHJcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICB2YXIgc2VlbiA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxyXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcclxuICAgICAgaWYgKGlzU29ydGVkKSB7XHJcbiAgICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IGNvbXB1dGVkKSByZXN1bHQucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XHJcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHNlZW4sIGNvbXB1dGVkKSkge1xyXG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcclxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXHJcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXHJcbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xyXG4gIH07XHJcblxyXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcclxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxyXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcclxuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XHJcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxyXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXHJcbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHZhciByZXN0ID0gZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpO1xyXG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXHJcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXHJcbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBfLnVuemlwKGFyZ3VtZW50cyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29tcGxlbWVudCBvZiBfLnppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xyXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xyXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xyXG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCAnbGVuZ3RoJykubGVuZ3RoIHx8IDA7XHJcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcclxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcclxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXHJcbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0ICYmIGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHZhbHVlcykge1xyXG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcclxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxyXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxyXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXHJcbiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7XHJcbiAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5ICYmIGFycmF5Lmxlbmd0aDtcclxuICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgPT0gJ251bWJlcicpIHtcclxuICAgICAgaSA9IGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGxlbmd0aCArIGlzU29ydGVkKSA6IGlzU29ydGVkO1xyXG4gICAgfSBlbHNlIGlmIChpc1NvcnRlZCAmJiBsZW5ndGgpIHtcclxuICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xyXG4gICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xyXG4gICAgICByZXR1cm4gXy5maW5kSW5kZXgoc2xpY2UuY2FsbChhcnJheSwgaSksIF8uaXNOYU4pO1xyXG4gICAgfVxyXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcclxuICAgIHJldHVybiAtMTtcclxuICB9O1xyXG5cclxuICBfLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb20pIHtcclxuICAgIHZhciBpZHggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XHJcbiAgICBpZiAodHlwZW9mIGZyb20gPT0gJ251bWJlcicpIHtcclxuICAgICAgaWR4ID0gZnJvbSA8IDAgPyBpZHggKyBmcm9tICsgMSA6IE1hdGgubWluKGlkeCwgZnJvbSArIDEpO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIF8uZmluZExhc3RJbmRleChzbGljZS5jYWxsKGFycmF5LCAwLCBpZHgpLCBfLmlzTmFOKTtcclxuICAgIH1cclxuICAgIHdoaWxlICgtLWlkeCA+PSAwKSBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcclxuICAgIHJldHVybiAtMTtcclxuICB9O1xyXG5cclxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXHJcbiAgZnVuY3Rpb24gY3JlYXRlSW5kZXhGaW5kZXIoZGlyKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xyXG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgIT0gbnVsbCAmJiBhcnJheS5sZW5ndGg7XHJcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcclxuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxyXG4gIF8uZmluZEluZGV4ID0gY3JlYXRlSW5kZXhGaW5kZXIoMSk7XHJcblxyXG4gIF8uZmluZExhc3RJbmRleCA9IGNyZWF0ZUluZGV4RmluZGVyKC0xKTtcclxuXHJcbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxyXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cclxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcclxuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xyXG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcclxuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XHJcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG93O1xyXG4gIH07XHJcblxyXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcclxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxyXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXHJcbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xyXG4gICAgICBzdGFydCA9IDA7XHJcbiAgICB9XHJcbiAgICBzdGVwID0gc3RlcCB8fCAxO1xyXG5cclxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XHJcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xyXG5cclxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcclxuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByYW5nZTtcclxuICB9O1xyXG5cclxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxyXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xyXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XHJcbiAgICBpZiAoIShjYWxsaW5nQ29udGV4dCBpbnN0YW5jZW9mIGJvdW5kRnVuYykpIHJldHVybiBzb3VyY2VGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcclxuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xyXG4gICAgaWYgKF8uaXNPYmplY3QocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcclxuICAgIHJldHVybiBzZWxmO1xyXG4gIH07XHJcblxyXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxyXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcclxuICAvLyBhdmFpbGFibGUuXHJcbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xyXG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xyXG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGJvdW5kO1xyXG4gIH07XHJcblxyXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcclxuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXHJcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxyXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcclxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcclxuICAgICAgfVxyXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcclxuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGJvdW5kO1xyXG4gIH07XHJcblxyXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xyXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xyXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cclxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XHJcbiAgICBpZiAobGVuZ3RoIDw9IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xyXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXHJcbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XHJcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xyXG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcclxuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XHJcbiAgICB9O1xyXG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xyXG4gICAgcmV0dXJuIG1lbW9pemU7XHJcbiAgfTtcclxuXHJcbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xyXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cclxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xyXG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcclxuICAgIH0sIHdhaXQpO1xyXG4gIH07XHJcblxyXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xyXG4gIC8vIGNsZWFyZWQuXHJcbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXHJcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXHJcbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xyXG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXHJcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXHJcbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcclxuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XHJcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XHJcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xyXG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XHJcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XHJcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xyXG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xyXG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XHJcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xyXG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xyXG4gICAgICAgIGlmICh0aW1lb3V0KSB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldmlvdXMgPSBub3c7XHJcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcclxuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcclxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXHJcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXHJcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cclxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XHJcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XHJcblxyXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBsYXN0ID0gXy5ub3coKSAtIHRpbWVzdGFtcDtcclxuXHJcbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcclxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgY29udGV4dCA9IHRoaXM7XHJcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XHJcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xyXG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcclxuICAgICAgaWYgKGNhbGxOb3cpIHtcclxuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXHJcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxyXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xyXG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxyXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXHJcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cclxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgaSA9IHN0YXJ0O1xyXG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxyXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcclxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cclxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XHJcbiAgICB2YXIgbWVtbztcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XHJcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XHJcbiAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcclxuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxyXG4gIF8ub25jZSA9IF8ucGFydGlhbChfLmJlZm9yZSwgMik7XHJcblxyXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXHJcbiAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcclxuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XHJcblxyXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XHJcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XHJcbiAgICB2YXIgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XHJcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xyXG5cclxuICAgIC8vIENvbnN0cnVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlLlxyXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xyXG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcclxuXHJcbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XHJcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XHJcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XHJcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXHJcbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxyXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcclxuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xyXG4gICAgLy8gQWhlbSwgSUUgPCA5LlxyXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcclxuICAgIHJldHVybiBrZXlzO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxyXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcclxuICAgIHZhciBrZXlzID0gW107XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcclxuICAgIC8vIEFoZW0sIElFIDwgOS5cclxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XHJcbiAgICByZXR1cm4ga2V5cztcclxuICB9O1xyXG5cclxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXHJcbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XHJcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdFxyXG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XHJcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxyXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXHJcbiAgICAgICAgICByZXN1bHRzID0ge30sXHJcbiAgICAgICAgICBjdXJyZW50S2V5O1xyXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgY3VycmVudEtleSA9IGtleXNbaW5kZXhdO1xyXG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXHJcbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcclxuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFpcnM7XHJcbiAgfTtcclxuXHJcbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxyXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXHJcbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcclxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIG5hbWVzID0gW107XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xyXG4gIH07XHJcblxyXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxyXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcclxuXHJcbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcclxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcclxuICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcclxuXHJcbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XHJcbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcclxuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XHJcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cclxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xyXG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XHJcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcclxuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKG9pdGVyYXRlZSwgY29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XHJcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7IHJldHVybiBrZXkgaW4gb2JqOyB9O1xyXG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcclxuICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cclxuICBfLm9taXQgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xyXG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XHJcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICB9O1xyXG5cclxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxyXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xyXG5cclxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXHJcbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XHJcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xyXG4gIH07XHJcblxyXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cclxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cclxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cclxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcclxuICAgIGludGVyY2VwdG9yKG9iaik7XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxyXG4gIF8uaXNNYXRjaCA9IGZ1bmN0aW9uKG9iamVjdCwgYXR0cnMpIHtcclxuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xyXG4gICAgdmFyIG9iaiA9IE9iamVjdChvYmplY3QpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcblxyXG5cclxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxyXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XHJcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXHJcbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cclxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XHJcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXHJcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XHJcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cclxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XHJcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xyXG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cclxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xyXG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcclxuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXHJcbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XHJcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXHJcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XHJcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcclxuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXHJcbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xyXG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxyXG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXHJcbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cclxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xyXG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXHJcbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcclxuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XHJcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxyXG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXHJcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxyXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxuICAgIGlmICghYXJlQXJyYXlzKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXHJcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXHJcbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcclxuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xyXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXHJcbiAgICBcclxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cclxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cclxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcclxuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcclxuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xyXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxyXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXHJcbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cclxuICAgIGFTdGFjay5wdXNoKGEpO1xyXG4gICAgYlN0YWNrLnB1c2goYik7XHJcblxyXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXHJcbiAgICBpZiAoYXJlQXJyYXlzKSB7XHJcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxyXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcclxuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cclxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxyXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xyXG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxyXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcclxuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxyXG4gICAgYVN0YWNrLnBvcCgpO1xyXG4gICAgYlN0YWNrLnBvcCgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXHJcbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgcmV0dXJuIGVxKGEsIGIpO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xyXG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXHJcbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcclxuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xyXG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cclxuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxyXG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xyXG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcclxuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLlxyXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJ10sIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxyXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXHJcbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcclxuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXHJcbiAgLy8gSUUgMTEgKCMxNjIxKSwgYW5kIGluIFNhZmFyaSA4ICgjMTkyOSkuXHJcbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XHJcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XHJcbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxyXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xyXG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xyXG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xyXG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcclxuICB9O1xyXG5cclxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XHJcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cclxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XHJcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXHJcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxyXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cclxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9O1xyXG5cclxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXHJcbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xyXG5cclxuICBfLnByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXHJcbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgcmV0dXJuIG9ialtrZXldO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgXHJcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXHJcbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcclxuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcclxuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXHJcbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XHJcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XHJcbiAgICByZXR1cm4gYWNjdW07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cclxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XHJcbiAgICBpZiAobWF4ID09IG51bGwpIHtcclxuICAgICAgbWF4ID0gbWluO1xyXG4gICAgICBtaW4gPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxyXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgfTtcclxuXHJcbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXHJcbiAgdmFyIGVzY2FwZU1hcCA9IHtcclxuICAgICcmJzogJyZhbXA7JyxcclxuICAgICc8JzogJyZsdDsnLFxyXG4gICAgJz4nOiAnJmd0OycsXHJcbiAgICAnXCInOiAnJnF1b3Q7JyxcclxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcclxuICAgICdgJzogJyYjeDYwOydcclxuICB9O1xyXG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XHJcblxyXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cclxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xyXG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcclxuICAgIH07XHJcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcclxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcclxuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XHJcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcclxuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gIH07XHJcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XHJcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xyXG5cclxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxyXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxyXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcclxuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcclxuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xyXG4gIH07XHJcblxyXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXHJcbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cclxuICB2YXIgaWRDb3VudGVyID0gMDtcclxuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xyXG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXHJcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxyXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcclxuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcclxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXHJcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXHJcbiAgfTtcclxuXHJcbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxyXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcclxuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cclxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcclxuXHJcbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcclxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cclxuICB2YXIgZXNjYXBlcyA9IHtcclxuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxyXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxyXG4gICAgJ1xccic6ICAgICAncicsXHJcbiAgICAnXFxuJzogICAgICduJyxcclxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcclxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xyXG4gIH07XHJcblxyXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xyXG5cclxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XHJcbiAgfTtcclxuXHJcbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cclxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXHJcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXHJcbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxyXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcclxuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XHJcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xyXG5cclxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxyXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xyXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcclxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcclxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxyXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xyXG5cclxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XHJcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcclxuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcclxuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XHJcblxyXG4gICAgICBpZiAoZXNjYXBlKSB7XHJcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcclxuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xyXG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XHJcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxyXG4gICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICB9KTtcclxuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XHJcblxyXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cclxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XHJcblxyXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xyXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xyXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cclxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xyXG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XHJcblxyXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gIH07XHJcblxyXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxyXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcclxuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfTtcclxuXHJcbiAgLy8gT09QXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcclxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxyXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXHJcblxyXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cclxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xyXG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cclxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XHJcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XHJcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXHJcbiAgXy5taXhpbihfKTtcclxuXHJcbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cclxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XHJcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcclxuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xyXG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG9iaik7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cclxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcclxuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXHJcbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xyXG4gIH07XHJcblxyXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcclxuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxyXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcclxuICBcclxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcclxuICB9O1xyXG5cclxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXHJcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXHJcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xyXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXHJcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXHJcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxyXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIF87XHJcbiAgICB9KTtcclxuICB9XHJcbn0uY2FsbCh0aGlzKSk7XHJcbiIsInZhciBidWlsZFByb21pc2UgPSByZXF1aXJlKCcuL3V0aWxzJykuYnVpbGRQcm9taXNlO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBQbGF0Zm9ybSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuUGxhdGZvcm07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBDdXJyZW50RGV2aWNlXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHB1c2hIYW5kbGVyXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIEN1cnJlbnREZXZpY2UgPSBmdW5jdGlvbiAocHVzaEhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9wdXNoSGFuZGxlciA9IHB1c2hIYW5kbGVyO1xyXG4gICAgICAgIHRoaXMuX2luaXRTdWNjZXNzQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2luaXRFcnJvckNhbGxiYWNrID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy9TdWZmaXggZm9yIHRoZSBnbG9iYWwgY2FsbGJhY2sgZnVuY3Rpb25zXHJcbiAgICAgICAgdGhpcy5fZ2xvYmFsRnVuY3Rpb25TdWZmaXggPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wdXNoVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5lbXVsYXRvck1vZGUgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgQ3VycmVudERldmljZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBjdXJyZW50IGRldmljZSBmb3IgcHVzaCBub3RpZmljYXRpb25zLiBUaGlzIG1ldGhvZCByZXF1ZXN0cyBhIHB1c2ggdG9rZW4gZnJvbSB0aGUgZGV2aWNlIHZlbmRvciBhbmQgZW5hYmxlcyB0aGUgcHVzaCBub3RpZmljYXRpb24gZnVuY3Rpb25hbGl0eSBvbiB0aGUgZGV2aWNlLiBPbmNlIHRoaXMgaXMgZG9uZSwgeW91IGNhbiByZWdpc3RlciB0aGUgZGV2aWNlIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNpbmcgdGhlIHJlZ2lzdGVyKCkgbWV0aG9kLlxyXG4gICAgICAgICAqIEBtZXRob2QgZW5hYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBuYW1lIGVuYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge1B1c2hTZXR0aW5nc30gcHVzaFNldHRpbmdzIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHZhcmlvdXMgc2V0dGluZ3MgZm9yIHRoZSBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGN1cnJlbnQgZGV2aWNlIGZvciBwdXNoIG5vdGlmaWNhdGlvbnMuIFRoaXMgbWV0aG9kIHJlcXVlc3RzIGEgcHVzaCB0b2tlbiBmcm9tIHRoZSBkZXZpY2UgdmVuZG9yIGFuZCBlbmFibGVzIHRoZSBwdXNoIG5vdGlmaWNhdGlvbiBmdW5jdGlvbmFsaXR5IG9uIHRoZSBkZXZpY2UuIE9uY2UgdGhpcyBpcyBkb25lLCB5b3UgY2FuIHJlZ2lzdGVyIHRoZSBkZXZpY2UgaW4gRXZlcmxpdmUgdXNpbmcgdGhlIHJlZ2lzdGVyKCkgbWV0aG9kLlxyXG4gICAgICAgICAqIEBtZXRob2QgZW5hYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBuYW1lIGVuYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge1B1c2hTZXR0aW5nc30gcHVzaFNldHRpbmdzIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHZhcmlvdXMgc2V0dGluZ3MgZm9yIHRoZSBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW5hYmxlTm90aWZpY2F0aW9uczogZnVuY3Rpb24gKHB1c2hTZXR0aW5ncywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3MgPSB0aGlzLl9jbGVhblBsYXRmb3Jtc1B1c2hTZXR0aW5ncyhwdXNoU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShfLmJpbmQodGhpcy5faW5pdGlhbGl6ZSwgdGhpcyksIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSBjdXJyZW50IGRldmljZS4gVGhpcyBtZXRob2QgaW52YWxpZGF0ZXMgYW55IHB1c2ggdG9rZW5zIHRoYXQgd2VyZSBvYnRhaW5lZCBmb3IgdGhlIGRldmljZSBmcm9tIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAqIEBtZXRob2QgZGlzYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbmFtZSBkaXNhYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSBjdXJyZW50IGRldmljZS4gVGhpcyBtZXRob2QgaW52YWxpZGF0ZXMgYW55IHB1c2ggdG9rZW5zIHRoYXQgd2VyZSBvYnRhaW5lZCBmb3IgdGhlIGRldmljZSBmcm9tIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAqIEBtZXRob2QgZGlzYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbmFtZSBkaXNhYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkaXNhYmxlTm90aWZpY2F0aW9uczogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVucmVnaXN0ZXIoKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZW11bGF0b3JNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHVzaE5vdGlmaWNhdGlvbiA9IHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVucmVnaXN0ZXJPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGF0Zm9ybVR5cGUgPSBzZWxmLl9nZXRQbGF0Zm9ybVR5cGUoZGV2aWNlLnBsYXRmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxhdGZvcm1UeXBlID09PSBQbGF0Zm9ybS5XaW5kb3dzUGhvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3Rlck9wdGlvbnMgPSB7J2NoYW5uZWxOYW1lJzogc2VsZi5wdXNoU2V0dGluZ3Mud3A4LmNoYW5uZWxOYW1lfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaE5vdGlmaWNhdGlvbi51bnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJPcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcHVzaCByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwdXNoIHJlZ2lzdHJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UmVnaXN0cmF0aW9uOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGRldmljZUlkID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuX2dldERldmljZUlkKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEhhbmRsZXIuZGV2aWNlcy5nZXRCeUlkKCdIYXJkd2FyZUlkLycgKyBkZXZpY2VJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG9ubHkgYWZ0ZXIgW2VuYWJsZU5vdGlmaWNhdGlvbnMoKV0oI0N1cnJlbnREZXZpY2UuZW5hYmxlTm90aWZpY2F0aW9ucykgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG9ubHkgYWZ0ZXIgW2VuYWJsZU5vdGlmaWNhdGlvbnMoKV0oI0N1cnJlbnREZXZpY2UuZW5hYmxlTm90aWZpY2F0aW9ucykgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAoY3VzdG9tUGFyYW1ldGVycywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRldmljZVJlZ2lzdHJhdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoY3VzdG9tUGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUGFyYW1ldGVycyA9IGN1c3RvbVBhcmFtZXRlcnM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3B1bGF0ZVJlZ2lzdHJhdGlvbk9iamVjdChkZXZpY2VSZWdpc3RyYXRpb24pLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3B1c2hIYW5kbGVyLmRldmljZXMuY3JlYXRlKGRldmljZVJlZ2lzdHJhdGlvbiwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5yZWdpc3RlcnMgdGhlIGN1cnJlbnQgZGV2aWNlIGZyb20gcHVzaCBub3RpZmljYXRpb25zIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uIEFmdGVyIHRoaXMgY2FsbCBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5LCB7e3NpdGUuYnN9fSB3aWxsIG5vIGxvbmdlciBzZW5kIG5vdGlmaWNhdGlvbnMgdG8gdGhpcyBkZXZpY2UuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IHByZXZlbnQgdGhlIGRldmljZSBmcm9tIHJlY2VpdmluZyBub3RpZmljYXRpb25zIGFuZCBkb2VzIG5vdCBpbnZhbGlkYXRlIHB1c2ggdG9rZW5zLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5yZWdpc3RlcnMgdGhlIGN1cnJlbnQgZGV2aWNlIGZyb20gcHVzaCBub3RpZmljYXRpb25zIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uIEFmdGVyIHRoaXMgY2FsbCBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5LCB7e3NpdGUuYnN9fSB3aWxsIG5vIGxvbmdlciBzZW5kIG5vdGlmaWNhdGlvbnMgdG8gdGhpcyBkZXZpY2UuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IHByZXZlbnQgdGhlIGRldmljZSBmcm9tIHJlY2VpdmluZyBub3RpZmljYXRpb25zIGFuZCBkb2VzIG5vdCBpbnZhbGlkYXRlIHB1c2ggdG9rZW5zLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2UudXVpZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXNoSGFuZGxlci5kZXZpY2VzLmRlc3Ryb3lTaW5nbGUoe0lkOiAnSGFyZHdhcmVJZC8nICsgZGV2aWNlSWR9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcmVnaXN0cmF0aW9uIG9mIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB1bmRlZmluZWQsIGN1c3RvbVBhcmFtZXRlcnMgYXJlIG5vdCB1cGRhdGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB1bmRlZmluZWQsIGN1c3RvbVBhcmFtZXRlcnMgYXJlIG5vdCB1cGRhdGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGVSZWdpc3RyYXRpb246IGZ1bmN0aW9uIChjdXN0b21QYXJhbWV0ZXJzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uID0ge307XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21QYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5QYXJhbWV0ZXJzID0gY3VzdG9tUGFyYW1ldGVycztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVsYXRlUmVnaXN0cmF0aW9uT2JqZWN0KGRldmljZVJlZ2lzdHJhdGlvbikudGhlbihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uSWQgPSAnSGFyZHdhcmVJZC8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZVJlZ2lzdHJhdGlvbi5IYXJkd2FyZUlkKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcHVzaEhhbmRsZXIuZGV2aWNlcy51cGRhdGVTaW5nbGUoZGV2aWNlUmVnaXN0cmF0aW9uLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfaW5pdGlhbGl6ZUludGVyYWN0aXZlUHVzaDogZnVuY3Rpb24gKGlPU1NldHRpbmdzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgcHVzaFBsdWdpbiA9IHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb247XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZXJhY3RpdmVTZXR0aW5ncyA9IGlPU1NldHRpbmdzLmludGVyYWN0aXZlU2V0dGluZ3M7XHJcbiAgICAgICAgICAgIHZhciBub3RpZmljYXRpb25UeXBlcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoaU9TU2V0dGluZ3MuYWxlcnQpIHtcclxuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblR5cGVzLnB1c2gocHVzaFBsdWdpbi5Vc2VyTm90aWZpY2F0aW9uVHlwZXMuQWxlcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpT1NTZXR0aW5ncy5iYWRnZSkge1xyXG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uVHlwZXMucHVzaChwdXNoUGx1Z2luLlVzZXJOb3RpZmljYXRpb25UeXBlcy5CYWRnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlPU1NldHRpbmdzLnNvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25UeXBlcy5wdXNoKHB1c2hQbHVnaW4uVXNlck5vdGlmaWNhdGlvblR5cGVzLlNvdW5kKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGdldEFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb25JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gXy5maW5kKGludGVyYWN0aXZlU2V0dGluZ3MuYWN0aW9ucywgZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24uaWRlbnRpZmllciA9PT0gYWN0aW9uSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb247XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBjYXRlZ29yaWVzID0gXy5tYXAoaW50ZXJhY3RpdmVTZXR0aW5ncy5jYXRlZ29yaWVzLCBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogY2F0ZWdvcnkuaWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRm9yRGVmYXVsdENvbnRleHQ6IF8ubWFwKGNhdGVnb3J5LmFjdGlvbnNGb3JEZWZhdWx0Q29udGV4dCwgZ2V0QWN0aW9uKSxcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRm9yTWluaW1hbENvbnRleHQ6IF8ubWFwKGNhdGVnb3J5LmFjdGlvbnNGb3JNaW5pbWFsQ29udGV4dCwgZ2V0QWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHB1c2hQbHVnaW4ucmVnaXN0ZXJVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MoXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3VjY2VzcyBjYWxsYmFjayB3aGljaCB3aWxsIGltbWVkaWF0ZWx5IHJldHVybiAoQVBOcyBpcyBub3QgY29udGFjdGVkIGZvciB0aGlzKVxyXG4gICAgICAgICAgICAgICAgc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBpbiBjYXNlIHRoZSBjb25maWd1cmF0aW9uIGlzIGluY29ycmVjdFxyXG4gICAgICAgICAgICAgICAgZXJyb3IsIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhc2tpbmcgcGVybWlzc2lvbiBmb3IgdGhlc2UgZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICB0eXBlczogbm90aWZpY2F0aW9uVHlwZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdGhlc2UgY2F0ZWdvcmllc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL0luaXRpYWxpemVzIHRoZSBwdXNoIGZ1bmN0aW9uYWxpdHkgb24gdGhlIGRldmljZS5cclxuICAgICAgICBfaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcihuZXcgRXZlcmxpdmVFcnJvcignUHVzaCBub3RpZmljYXRpb25zIGFyZSBjdXJyZW50bHkgaW5pdGlhbGl6aW5nLicpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVtdWxhdG9yTW9kZSAmJiAoIXdpbmRvdy5uYXZpZ2F0b3IgfHwgIXdpbmRvdy5uYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yKG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgZ2xvYmFsaXphdGlvbiBwbHVnaW4gaXMgbm90IGluaXRpYWxpemVkLicpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVtdWxhdG9yTW9kZSAmJiAoIXdpbmRvdy5wbHVnaW5zIHx8ICF3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IobmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBwdXNoIG5vdGlmaWNhdGlvbnMgcGx1Z2luIGlzIG5vdCBpbml0aWFsaXplZC4nKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRTdWNjZXNzQ2FsbGJhY2sgPSBzdWNjZXNzO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0RXJyb3JDYWxsYmFjayA9IGVycm9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2Vzcyh0aGlzLnB1c2hUb2tlbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVtdWxhdG9yTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3MoJ2Zha2VfcHVzaF90b2tlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgMTAwMFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gdGhpcy5fZ2xvYmFsRnVuY3Rpb25TdWZmaXg7XHJcbiAgICAgICAgICAgIGlmICghc3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBEYXRlLm5vdygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWxGdW5jdGlvblN1ZmZpeCA9IHN1ZmZpeDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHB1c2hOb3RpZmljYXRpb24gPSB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBsYXRmb3JtVHlwZSA9IHRoaXMuX2dldFBsYXRmb3JtVHlwZShkZXZpY2UucGxhdGZvcm0pO1xyXG4gICAgICAgICAgICBpZiAocGxhdGZvcm1UeXBlID09PSBQbGF0Zm9ybS5pT1MpIHtcclxuICAgICAgICAgICAgICAgIC8vSW5pdGlhbGl6ZSBnbG9iYWwgQVBOIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICB2YXIgYXBuQ2FsbGJhY2tOYW1lID0gJ2FwbkNhbGxiYWNrXycgKyBzdWZmaXg7XHJcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW2FwbkNhbGxiYWNrTmFtZV0gPSBfLmJpbmQodGhpcy5fb25Ob3RpZmljYXRpb25BUE4sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQ29uc3RydWN0IHJlZ2lzdHJhdGlvbiBvcHRpb25zIG9iamVjdCBhbmQgdmFsaWRhdGUgaU9TIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICB2YXIgYXBuUmVnaXN0cmF0aW9uT3B0aW9ucyA9IHRoaXMucHVzaFNldHRpbmdzLmlPUztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlSU9TU2V0dGluZ3MoYXBuUmVnaXN0cmF0aW9uT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBhcG5SZWdpc3RyYXRpb25PcHRpb25zLmVjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyBhcG5DYWxsYmFja05hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZWdpc3RlciBmb3IgQVBOXHJcbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9zdWNjZXNzZnVsUmVnaXN0cmF0aW9uQVBOLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fZmFpbGVkUmVnaXN0cmF0aW9uQVBOLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBhcG5SZWdpc3RyYXRpb25PcHRpb25zXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uQW5kcm9pZCkge1xyXG4gICAgICAgICAgICAgICAgLy9Jbml0aWFsaXplIGdsb2JhbCBHQ00gY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIHZhciBnY21DYWxsYmFja05hbWUgPSAnZ2NtQ2FsbGJhY2tfJyArIHN1ZmZpeDtcclxuICAgICAgICAgICAgICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3NbZ2NtQ2FsbGJhY2tOYW1lXSA9IF8uYmluZCh0aGlzLl9vbk5vdGlmaWNhdGlvbkdDTSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9Db25zdHJ1Y3QgcmVnaXN0cmF0aW9uIG9wdGlvbnMgb2JqZWN0IGFuZCB2YWxpZGF0ZSB0aGUgQW5kcm9pZCBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgdmFyIGdjbVJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB0aGlzLnB1c2hTZXR0aW5ncy5hbmRyb2lkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVBbmRyb2lkU2V0dGluZ3MoZ2NtUmVnaXN0cmF0aW9uT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBnY21SZWdpc3RyYXRpb25PcHRpb25zLmVjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyBnY21DYWxsYmFja05hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZWdpc3RlciBmb3IgR0NNXHJcbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9zdWNjZXNzU2VudFJlZ2lzdHJhdGlvbkdDTSwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMuX2Vycm9yU2VudFJlZ2lzdHJhdGlvbkdDTSwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgZ2NtUmVnaXN0cmF0aW9uT3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwbGF0Zm9ybVR5cGUgPT09IFBsYXRmb3JtLldpbmRvd3NQaG9uZSkge1xyXG4gICAgICAgICAgICAgICAgLy9Jbml0aWFsaXplIGdsb2JhbCBXUDggY2FsbGJhY2tzLlxyXG4gICAgICAgICAgICAgICAgdmFyIHdwOENhbGxiYWNrTmFtZSA9ICd3cDhDYWxsYmFja18nICsgc3VmZml4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHdwOFJlZ2lzdHJhdGlvblN1Y2Nlc3NDYWxsYmFja05hbWUgPSAnd3A4UmVnaXN0cmF0aW9uU3VjY2Vzc0NhbGxiYWNrXycgKyBzdWZmaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgd3A4UmVnaXN0cmF0aW9uRXJyb3JDYWxsYmFja05hbWUgPSAnd3A4UmVnaXN0cmF0aW9uRXJyb3JDYWxsYmFja18nICsgc3VmZml4O1xyXG5cclxuICAgICAgICAgICAgICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3Nbd3A4Q2FsbGJhY2tOYW1lXSA9IF8uYmluZCh0aGlzLl9vbk5vdGlmaWNhdGlvbldQOCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW3dwOFJlZ2lzdHJhdGlvblN1Y2Nlc3NDYWxsYmFja05hbWVdID0gXy5iaW5kKHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3NXUCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW3dwOFJlZ2lzdHJhdGlvbkVycm9yQ2FsbGJhY2tOYW1lXSA9IF8uYmluZCh0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQ29uc3RydWN0IHJlZ2lzdHJhdGlvbiBvcHRpb25zIG9iamVjdCBhbmQgdmFsaWRhdGUgdGhlIFdQOCAgc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgIHZhciB3cDhSZWdpc3RyYXRpb25PcHRpb25zID0gdGhpcy5wdXNoU2V0dGluZ3Mud3A4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVXUDhTZXR0aW5ncyh3cDhSZWdpc3RyYXRpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnMuZWNiID0gJ0V2ZXJsaXZlLlB1c2hDYWxsYmFja3MuJyArIHdwOENhbGxiYWNrTmFtZTtcclxuICAgICAgICAgICAgICAgIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnMudWNjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyB3cDhSZWdpc3RyYXRpb25TdWNjZXNzQ2FsbGJhY2tOYW1lO1xyXG4gICAgICAgICAgICAgICAgd3A4UmVnaXN0cmF0aW9uT3B0aW9ucy5lcnJjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyB3cDhSZWdpc3RyYXRpb25FcnJvckNhbGxiYWNrTmFtZTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgcHVzaE5vdGlmaWNhdGlvbi5yZWdpc3RlcihcclxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fc3VjY2Vzc1NlbnRSZWdpc3RyYXRpb25XUDgsIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9lcnJvclNlbnRSZWdpc3RyYXRpb25XUDgsIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnNcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBjdXJyZW50IHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQ6ICcgKyBkZXZpY2UucGxhdGZvcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3NXUDogZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKHJlc3VsdC51cmkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF92YWxpZGF0ZUFuZHJvaWRTZXR0aW5nczogZnVuY3Rpb24gKGFuZHJvaWRTZXR0aW5ncykge1xyXG4gICAgICAgICAgICBpZiAoIWFuZHJvaWRTZXR0aW5ncy5zZW5kZXJJRCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1NlbmRlciBJRCAocHJvamVjdCBudW1iZXIpIGlzIG5vdCBzZXQgaW4gdGhlIGFuZHJvaWQgc2V0dGluZ3MuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF92YWxpZGF0ZVdQOFNldHRpbmdzOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5jaGFubmVsTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ2NoYW5uZWxOYW1lIGlzIG5vdCBzZXQgaW4gdGhlIFdQOCBzZXR0aW5ncy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF92YWxpZGF0ZUlPU1NldHRpbmdzOiBmdW5jdGlvbiAoaU9TU2V0dGluZ3MpIHtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2NsZWFuUGxhdGZvcm1zUHVzaFNldHRpbmdzOiBmdW5jdGlvbiAocHVzaFNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGVhblNldHRpbmdzID0ge307XHJcbiAgICAgICAgICAgIHB1c2hTZXR0aW5ncyA9IHB1c2hTZXR0aW5ncyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtID0gZnVuY3Rpb24gYWRkU2V0dGluZ3NGb3JQbGF0Zm9ybShuZXdTZXR0aW5nc09iamVjdCwgcGxhdGZvcm0sIGFsbG93ZWRGaWVsZHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHVzaFNldHRpbmdzW3BsYXRmb3JtXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBuZXdTZXR0aW5nc09iamVjdFtwbGF0Zm9ybV0gPSBuZXdTZXR0aW5nc09iamVjdFtwbGF0Zm9ybV0gfHwge307XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGxhdGZvcm1TZXR0aW5ncyA9IHB1c2hTZXR0aW5nc1twbGF0Zm9ybV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBuZXdTZXR0aW5nc09iamVjdFtwbGF0Zm9ybV07XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goYWxsb3dlZEZpZWxkcywgZnVuY3Rpb24gKGFsbG93ZWRGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdQbGF0Zm9ybVNldHRpbmdzLmhhc093blByb3BlcnR5KGFsbG93ZWRGaWVsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NbYWxsb3dlZEZpZWxkXSA9IG5ld1BsYXRmb3JtU2V0dGluZ3NbYWxsb3dlZEZpZWxkXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGFkZFNldHRpbmdzRm9yUGxhdGZvcm0oY2xlYW5TZXR0aW5ncywgJ2lPUycsIFsnYmFkZ2UnLCAnc291bmQnLCAnYWxlcnQnLCAnaW50ZXJhY3RpdmVTZXR0aW5ncyddKTtcclxuICAgICAgICAgICAgYWRkU2V0dGluZ3NGb3JQbGF0Zm9ybShjbGVhblNldHRpbmdzLCAnYW5kcm9pZCcsIFsnc2VuZGVySUQnLCAncHJvamVjdE51bWJlciddKTtcclxuICAgICAgICAgICAgYWRkU2V0dGluZ3NGb3JQbGF0Zm9ybShjbGVhblNldHRpbmdzLCAnd3A4JywgWydjaGFubmVsTmFtZSddKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFja0ZpZWxkcyA9IFsnbm90aWZpY2F0aW9uQ2FsbGJhY2tBbmRyb2lkJywgJ25vdGlmaWNhdGlvbkNhbGxiYWNrSU9TJywgJ25vdGlmaWNhdGlvbkNhbGxiYWNrV1A4J107XHJcbiAgICAgICAgICAgIF8uZWFjaChjYWxsYmFja0ZpZWxkcywgZnVuY3Rpb24gKGNhbGxiYWNrRmllbGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHB1c2hTZXR0aW5nc1tjYWxsYmFja0ZpZWxkXTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBcIicgKyBjYWxsYmFja0ZpZWxkICsgJ1wiIG9mIHRoZSBwdXNoIHNldHRpbmdzIHNob3VsZCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjbGVhblNldHRpbmdzW2NhbGxiYWNrRmllbGRdID0gcHVzaFNldHRpbmdzW2NhbGxiYWNrRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwdXNoU2V0dGluZ3MuY3VzdG9tUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICAgICAgY2xlYW5TZXR0aW5ncy5jdXN0b21QYXJhbWV0ZXJzID0gcHVzaFNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjbGVhblNldHRpbmdzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9wb3B1bGF0ZVJlZ2lzdHJhdGlvbk9iamVjdDogZnVuY3Rpb24gKGRldmljZVJlZ2lzdHJhdGlvbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5wdXNoVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1B1c2ggdG9rZW4gaXMgbm90IGF2YWlsYWJsZS4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2dldExvY2FsZU5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChsb2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IHNlbGYuX2dldERldmljZUlkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFyZHdhcmVNb2RlbCA9IGRldmljZS5tb2RlbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGF0Zm9ybVR5cGUgPSBzZWxmLl9nZXRQbGF0Zm9ybVR5cGUoZGV2aWNlLnBsYXRmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lWm9uZSA9IGpzdHouZGV0ZXJtaW5lKCkubmFtZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB1c2hUb2tlbiA9IHNlbGYucHVzaFRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gbG9jYWxlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYXRmb3JtVmVyc2lvbiA9IGRldmljZS52ZXJzaW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5IYXJkd2FyZUlkID0gZGV2aWNlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uSGFyZHdhcmVNb2RlbCA9IGhhcmR3YXJlTW9kZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUGxhdGZvcm1UeXBlID0gcGxhdGZvcm1UeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlBsYXRmb3JtVmVyc2lvbiA9IHBsYXRmb3JtVmVyc2lvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5UaW1lWm9uZSA9IHRpbWVab25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlB1c2hUb2tlbiA9IHB1c2hUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5Mb2NhbGUgPSBsYW5ndWFnZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0TG9jYWxlTmFtZTogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVtdWxhdG9yTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcyh7dmFsdWU6ICdlbl9VUyd9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uLmdldExvY2FsZU5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGxvY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uLmdldExvY2FsZU5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RGV2aWNlSWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRldmljZS51dWlkO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vUmV0dXJucyB0aGUgRXZlcmxpdmUgZGV2aWNlIHBsYXRmb3JtIGNvbnN0YW50IGdpdmVuIGEgdmFsdWUgYXF1aXJlZCBmcm9tIGNvcmRvdmEncyBkZXZpY2UucGxhdGZvcm0uXHJcbiAgICAgICAgX2dldFBsYXRmb3JtVHlwZTogZnVuY3Rpb24gKHBsYXRmb3JtU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBwc0xvd2VyID0gcGxhdGZvcm1TdHJpbmcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgc3dpdGNoIChwc0xvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpb3MnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaXBob25lJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2lwYWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbGF0Zm9ybS5pT1M7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhbmRyb2lkJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGxhdGZvcm0uQW5kcm9pZDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3dpbmNlJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGxhdGZvcm0uV2luZG93c1Bob25lO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnd2luMzJudCc6IC8vIHJlYWwgd3A4IGRldmljZXMgcmV0dXJuIHRoaXMgc3RyaW5nIGFzIHBsYXRmb3JtIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtLldpbmRvd3NQaG9uZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtLlVua25vd247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZGV2aWNlUmVnaXN0cmF0aW9uRmFpbGVkOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoVG9rZW4gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRFcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RXJyb3JDYWxsYmFjayh7ZXJyb3I6IGVycm9yfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2VzczogZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaFRva2VuID0gdG9rZW47XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbml0U3VjY2Vzc0NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0U3VjY2Vzc0NhbGxiYWNrKHt0b2tlbjogdG9rZW59KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vT2NjdXJzIHdoZW4gdGhlIGRldmljZSByZWdpc3RyYXRpb24gaW4gQVBOIHN1Y2NlZWRzXHJcbiAgICAgICAgX3N1Y2Nlc3NmdWxSZWdpc3RyYXRpb25BUE46IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB1c2hTZXR0aW5ncy5pT1MgJiYgdGhpcy5wdXNoU2V0dGluZ3MuaU9TLmludGVyYWN0aXZlU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnRlcmFjdGl2ZVB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3MuaU9TLFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2Vzcyh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgaW50ZXJhY3RpdmUgcHVzaCBjb25maWd1cmF0aW9uIGlzIGluY29ycmVjdDogJyArIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3ModG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9PY2N1cnMgaWYgdGhlIGRldmljZSByZWdpc3RyYXRpb24gaW4gQVBOIGZhaWxzXHJcbiAgICAgICAgX2ZhaWxlZFJlZ2lzdHJhdGlvbkFQTjogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9PY2N1cnMgd2hlbiBkZXZpY2UgcmVnaXN0cmF0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZW50IHRvIEdDTVxyXG4gICAgICAgIF9zdWNjZXNzU2VudFJlZ2lzdHJhdGlvbkdDTTogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdWNjZXNzZnVsbHkgc2VudCByZXF1ZXN0IGZvciByZWdpc3RlcmluZyB3aXRoIEdDTS5cIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL09jY3VycyB3aGVuIGRldmljZSByZWdpc3RyYXRpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHNlbnQgZm9yIFdQOFxyXG4gICAgICAgIF9zdWNjZXNzU2VudFJlZ2lzdHJhdGlvbldQODogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdWNjZXNzZnVsbHkgc2VudCByZXF1ZXN0IGZvciByZWdpc3RlcmluZyBXUDggLlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vT2NjdXJzIHdoZW4gYW4gZXJyb3Igb2NjdXJlZCB3aGVuIHNlbmRpbmcgcmVnaXN0cmF0aW9uIHJlcXVlc3QgZm9yIFdQOFxyXG4gICAgICAgIF9lcnJvclNlbnRSZWdpc3RyYXRpb25XUDg6IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQoZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vT2NjdXJzIHdoZW4gYW4gZXJyb3Igb2NjdXJlZCB3aGVuIHNlbmRpbmcgcmVnaXN0cmF0aW9uIHJlcXVlc3QgdG8gR0NNXHJcbiAgICAgICAgX2Vycm9yU2VudFJlZ2lzdHJhdGlvbkdDTTogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9UaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIGFsbCBub3RpZmljYXRpb24gZXZlbnRzIGZyb20gQVBOXHJcbiAgICAgICAgX29uTm90aWZpY2F0aW9uQVBOOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50SU9TKGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9UaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIGFsbCBub3RpZmljYXRpb24gZXZlbnRzIGZvciBXUDhcclxuICAgICAgICBfb25Ob3RpZmljYXRpb25XUDg6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRXUDgoZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9UaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIGFsbCBub3RpZmljYXRpb24gZXZlbnRzIGZyb20gR0NNXHJcbiAgICAgICAgX29uTm90aWZpY2F0aW9uR0NNOiBmdW5jdGlvbiBvbk5vdGlmaWNhdGlvbkdDTShlKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZS5ldmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmVnaXN0ZXJlZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucmVnaWQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKGUucmVnaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2UnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wdXNoVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uRmFpbGVkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmFpc2VOb3RpZmljYXRpb25FdmVudEFuZHJvaWQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfcmFpc2VOb3RpZmljYXRpb25FdmVudEFuZHJvaWQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0FuZHJvaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrQW5kcm9pZChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRJT1M6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0lPUykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tJT1MoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50V1A4OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tXUDgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrV1A4KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQ3VycmVudERldmljZTtcclxufSgpKTsiLCJ2YXIgU2V0dXAgPSByZXF1aXJlKCcuL1NldHVwJyk7XHJcbnZhciBEYXRhID0gcmVxdWlyZSgnLi90eXBlcy9EYXRhJyk7XHJcbnZhciB1c2Vyc01vZHVsZSA9IHJlcXVpcmUoJy4vdHlwZXMvVXNlcnMnKTtcclxudmFyIGZpbGVzTW9kdWxlID0gcmVxdWlyZSgnLi90eXBlcy9GaWxlcycpO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG52YXIgYnVpbGRBdXRoSGVhZGVyID0gdXRpbHMuYnVpbGRBdXRoSGVhZGVyO1xyXG52YXIgZ2V0QXV0aEluZm8gPSB1dGlscy5nZXRBdXRoSW5mbztcclxudmFyIFB1c2ggPSByZXF1aXJlKCcuL1B1c2gnKTtcclxudmFyIG9mZmxpbmVNb2R1bGUgPSByZXF1aXJlKCcuL29mZmxpbmUvb2ZmbGluZScpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vUmVxdWVzdCcpO1xyXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIF8gPSBjb21tb24uXztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvLyBUaGUgY29uc3RydWN0b3Igb2YgRXZlcmxpdmUgaW5zdGFuY2VzLlxyXG4gICAgLy8gVGhlIGVudHJ5IHBvaW50IGZvciB0aGUgU0RLLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIEV2ZXJsaXZlXHJcbiAgICAgKiBAY2xhc3NkZXNjIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUge3tzaXRlLmJzfX0gKEV2ZXJsaXZlKSBKYXZhU2NyaXB0IFNESy4gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHRoZSBTREsuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBTZXR1cCBvYmplY3QuIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gcGFzcyBhIHN0cmluZyByZXByZXNlbnRpbmcgeW91ciBBUEkga2V5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYXBpS2V5IC0gWW91ciBBUEkga2V5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVybD0vL2FwaS5ldmVybGl2ZS5jb20vdjEvXSAtIFRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IFVSTC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b2tlbl0gLSBBbiBhdXRoZW50aWNhdGlvbiB0b2tlbi4gVGhlIGluc3RhbmNlIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBwcmV2aW91c2x5IG9idGFpbmVkIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRva2VuVHlwZT1iZWFyZXJdIC0gVGhlIHR5cGUgb2YgdGhlIHRva2VuIHRoYXQgaXMgdXNlZCBmb3IgYXV0aGVudGljYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2NoZW1lPWh0dHBdIC0gVGhlIFVSSSBzY2hlbWUgdXNlZCB0byBtYWtlIHJlcXVlc3RzLiBTdXBwb3J0ZWQgdmFsdWVzOiBodHRwLCBodHRwc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lT2JqZWN0cz1mYWxzZV0gLSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIFNESyB3aWxsIHBhcnNlIG9ubHkgY29tcGxldGUgZGF0ZSBzdHJpbmdzIChhY2NvcmRpbmcgdG8gdGhlIElTTyA4NjAxIHN0YW5kYXJkKS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW11bGF0b3JNb2RlPWZhbHNlXSAtIFNldCB0aGlzIG9wdGlvbiB0byB0cnVlIHRvIHNldCB0aGUgU0RLIGluIGVtdWxhdG9yIG1vZGUuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9ucy5vZmZsaW5lU3RvcmFnZV0gLSBTZXQgdGhpcyBvcHRpb24gdG8gdHJ1ZSB0byB1c2UgdGhlIGRlZmF1bHQgb2ZmbGluZSBzZXR0aW5ncy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2UuYXV0b1N5bmM9dHJ1ZV0gLSBXaGV0aGVyIHRvIHN5bmMgZGF0YSBhdXRvbWF0aWNhbGx5IHdoZW4gZ29pbmcgb25saW5lLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vZmZsaW5lU3RvcmFnZS5pc09ubGluZT10cnVlXSAtIFdoZXRoZXIgdGhlIHN0b3JhZ2UgaXMgaW4gb25saW5lIG1vZGUgaW5pdGlhbGx5LlxyXG4gICAgICogQHBhcmFtIHtDb25mbGljdFJlc29sdXRpb25TdHJhdGVneXxmdW5jdGlvbn0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2UuY29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3k9Q29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ2xpZW50V2luc10gLSBBIGNvbnN0YW50IHNwZWNpZnlpbmcgdGhlIGNvbmZsaWN0IHJlc29sdXRpb24gc3RyYXRlZ3kgb3IgYSBmdW5jdGlvbiB1c2VkIHRvIHJlc29sdmUgdGhlIGNvbmZsaWN0cy5cclxuICAgICAqIEBwYXJhbSB7U3RvcmFnZVByb3ZpZGVyc3xvYmplY3R9IFtvcHRpb25zLm9mZmxpbmVTdG9yYWdlLnN0b3JhZ2VQcm92aWRlclNldHRpbmdzPVN0b3JhZ2VQcm92aWRlcnMuTG9jYWxTdG9yYWdlXSAtIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHNldHRpbmdzIGZvciB0aGUgb2ZmbGluZSBzdG9yYWdlIHByb3ZpZGVyLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2Uuc3luY1N0YXJ0PW51bGxdIC0gQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBhIHN5bmNocm9uaXNhdGlvbiBzdGFydHMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5vZmZsaW5lU3RvcmFnZS5zeW5jRW5kPW51bGxdIC0gQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBzeW5jaHJvbml6YXRpb24gY29tcGxldGVzLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYSBsaXN0IG9mIHN5bmMgZXJyb3JzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBFdmVybGl2ZShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc2V0dXAgPSBuZXcgU2V0dXAob3B0aW9ucyk7XHJcbiAgICAgICAgXy5lYWNoKGluaXRpYWxpemF0aW9ucywgZnVuY3Rpb24gKGluaXQpIHtcclxuICAgICAgICAgICAgaW5pdC5mdW5jLmNhbGwoc2VsZiwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChFdmVybGl2ZS4kID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIEV2ZXJsaXZlLiQgPSBzZWxmO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gKEV2ZXJsaXZlKSBKYXZhU2NyaXB0IFNES1xyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgKiBAdHlwZSB7RXZlcmxpdmV9XHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLiQgPSBudWxsO1xyXG4gICAgRXZlcmxpdmUuaWRGaWVsZCA9IGNvbnN0YW50cy5pZEZpZWxkO1xyXG5cclxuXHJcbiAgICAvLyBBbiBhcnJheSBrZWVwaW5nIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9ucyBjYWxsZWQgYnkgdGhlIEV2ZXJsaXZlIGNvbnN0cnVjdG9yLlxyXG4gICAgLy8gVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgdXNlZCB0byBleHRlbmQgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gRXZlcmxpdmUgaW5zdGFuY2UuXHJcbiAgICB2YXIgaW5pdGlhbGl6YXRpb25zID0gW107XHJcblxyXG4gICAgLyoqIEFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSBpbnZva2VkIGR1cmluZyBpbnN0YW50aWF0aW9uIG9mIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IChFdmVybGl2ZSkgSmF2YVNjcmlwdCBTREsuXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbltdfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgRXZlcmxpdmUuaW5pdGlhbGl6YXRpb25zID0gaW5pdGlhbGl6YXRpb25zO1xyXG5cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gKEV2ZXJsaXZlKSBKYXZhIFNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybnMge0V2ZXJsaXZlfSBUaGUgaW5zdGFuY2Ugb2YgdGhlIHt7c2l0ZS5ic319IChFdmVybGl2ZSkgSmF2YVNjcmlwdCBTREsgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgRXZlcmxpdmUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgRXZlcmxpdmUuJCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVybGl2ZShvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoY29sbGVjdGlvbk5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGEodGhpcy5zZXR1cCwgY29sbGVjdGlvbk5hbWUsIHRoaXMuc3RvcmFnZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgVVJMIHRvIHRoZSB7e3NpdGUuYnN9fSBhcHBsaWNhdGlvbiBlbmRwb2ludCB0aGF0IHRoZSBTREsgdXNlcy5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgYnVpbGRVcmxcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBnZW5lcmF0ZWQgVVJMLlxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuYnVpbGRVcmwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkVXJsKHRoaXMuc2V0dXApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXJzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gKEV2ZXJsaXZlKSBKYXZhU2NyaXB0IFNESyB0byBtYWtlIHJlcXVlc3RzIHRvIHRoZSB7e3NpdGUuYnN9fSBzZXJ2ZXJzLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBdXRob3JpemF0aW9uSGVhZGVycyBUaGUgZ2VuZXJhdGVkIEF1dGhvcml6YXRpb24gaGVhZGVycyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5idWlsZEF1dGhIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkQXV0aEhlYWRlcih0aGlzLnNldHVwKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gcnN2cCBwcm9taXNlc1xyXG4gICAgRXZlcmxpdmUuZ2V0Q2FsbGJhY2tzID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHByb21pc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdWNjZXNzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBwcm9taXNlID0gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtwcm9taXNlOiBwcm9taXNlLCBzdWNjZXNzOiBzdWNjZXNzLCBlcnJvcjogZXJyb3J9O1xyXG4gICAgfTtcclxuXHJcbiAgICBFdmVybGl2ZS5kaXNhYmxlUmVxdWVzdENhY2hlID0gZnVuY3Rpb24gKHVybCwgbWV0aG9kKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcclxuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSB1cmwuaW5kZXhPZignPycpID4gLTEgPyAnJicgOiAnPyc7XHJcbiAgICAgICAgICAgIHVybCArPSBzZXBhcmF0b3IgKyAnX2VsPScgKyB0aW1lc3RhbXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgQXV0aFN0YXR1cyA9IGNvbnN0YW50cy5BdXRoU3RhdHVzO1xyXG4gICAgRXZlcmxpdmUuQXV0aFN0YXR1cyA9IEF1dGhTdGF0dXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIHN0YXR1cyBvZiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgYXV0aEluZm9cclxuICAgICAqIEBuYW1lIGF1dGhJbmZvXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRvIHRoZSBhdXRoZW50aWNhdGlvbiBzdGF0dXMuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGF1dGhJbmZvXHJcbiAgICAgKiBAbmFtZSBhdXRoSW5mb1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5hdXRoSW5mbyA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBnZXRBdXRoSW5mbyh0aGlzLnNldHVwLCBfLmJpbmQodGhpcy5Vc2Vycy5nZXRCeUlkLCB0aGlzLlVzZXJzLCAnbWUnKSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBIHV0aWxpdHkgbWV0aG9kIGZvciBjcmVhdGluZyByZXF1ZXN0cyBmb3IgdGhlIGN1cnJlbnQgRXZlcmxpdmUgaW5zdGFuY2VcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2UgYSByZXF1ZXN0IHRvIHRoZSBjdXJyZW50IHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLlxyXG4gICAgICogQG1ldGhvZCByZXF1ZXN0XHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPYmplY3QgdXNlZCB0byBjb25maWd1cmUgdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZW5kcG9pbnRdIFRoZSBlbmRwb2ludCBvZiB0aGUge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBBUEkgcmVsYXRpdmUgdG8gdGhlIEFQSSBrZXkgc2VjdGlvbi4gKEZvciBleGFtcGxlLCBvcHRpb25zLmVuZHBvaW50ID0gTXlUeXBlIHdpbGwgbWFrZSBhIHJlcXVlc3QgdG8gdGhlIE15VHlwZSB0eXBlLilcclxuICAgICAqIEBwYXJhbSB7SHR0cE1ldGhvZH0gW29wdGlvbnMubWV0aG9kXSBIVFRQIHJlcXVlc3QgbWV0aG9kLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmRhdGFdIERhdGEgdG8gYmUgc2VudCB3aXRoIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuc3VjY2Vzc10gU3VjY2VzcyBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXMgc3VjY2Vzc2Z1bGx5LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZXJyb3JdIEVycm9yIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBpbiBjYXNlIG9mIGFuIGVycm9yLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIEFkZGl0aW9uYWwgaGVhZGVycyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBwYXJhbSB7UXVlcnl8b2JqZWN0fSBbb3B0aW9ucy5maWx0ZXJdIFRoaXMgaXMgZWl0aGVyIGEge0BsaW5rIFF1ZXJ5fSBvciBhIFtmaWx0ZXJdKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBleHByZXNzaW9uLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRoSGVhZGVycz10cnVlXSBXaGVuIHNldCB0byBmYWxzZSwgbm8gQXV0aG9yaXphdGlvbiBoZWFkZXJzIHdpbGwgYmUgc2VudCB3aXRoIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSBUaGUgcmVxdWVzdCBjb25maWd1cmF0aW9uIG9iamVjdCBjb250YWluaW5nIHRoZSBgc2VuZGAgZnVuY3Rpb24gdGhhdCBzZW5kcyB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLnNldHVwLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGluaXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBBbiBpbnN0YW5jZSBvZiB0aGUgW1VzZXJzXXtAbGluayBVc2Vyc30gY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB1c2Vycy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtVc2Vyc30gVXNlcnNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLlVzZXJzID0gdGhpcy5kYXRhKCdVc2VycycpO1xyXG4gICAgICAgIHVzZXJzTW9kdWxlLmFkZFVzZXJzRnVuY3Rpb25zKHRoaXMuVXNlcnMpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtGaWxlc117QGxpbmsgRmlsZXN9IGNsYXNzIGZvciB3b3JraW5nIHdpdGggZmlsZXMuXHJcbiAgICAgICAgICogQG1lbWJlciB7RmlsZXN9IEZpbGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5GaWxlcyA9IHRoaXMuZGF0YSgnRmlsZXMnKTtcclxuICAgICAgICBmaWxlc01vZHVsZS5hZGRGaWxlc0Z1bmN0aW9ucyh0aGlzLkZpbGVzKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGluc3RhbmNlIG9mIHRoZSBbUHVzaF17QGxpbmsgUHVzaH0gY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCBwdXNoIG5vdGlmaWNhdGlvbnMuXHJcbiAgICAgICAgICogQG1lbWJlciB7UHVzaH0gUHVzaFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucHVzaCA9IG5ldyBQdXNoKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpbml0aWFsaXphdGlvbnMucHVzaCh7bmFtZTogJ29mZmxpbmVTdG9yYWdlJywgZnVuYzogb2ZmbGluZU1vZHVsZS5pbml0T2ZmbGluZVN0b3JhZ2V9KTtcclxuICAgIGluaXRpYWxpemF0aW9ucy5wdXNoKHtuYW1lOiAnZGVmYXVsdCcsIGZ1bmM6IGluaXREZWZhdWx0fSk7XHJcblxyXG4gICAgcmV0dXJuIEV2ZXJsaXZlO1xyXG59KCkpO1xyXG4iLCJ2YXIgRXZlcmxpdmVFcnJvcnMgPSB7XHJcbiAgICBpdGVtTm90Rm91bmQ6IHtcclxuICAgICAgICBjb2RlOiA4MDEsXHJcbiAgICAgICAgbWVzc2FnZTogJ0l0ZW0gbm90IGZvdW5kLidcclxuICAgIH0sXHJcbiAgICBzeW5jQ29uZmxpY3Q6IHtcclxuICAgICAgICBjb2RlOiA0MjQyLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdBIGNvbmZsaWN0IG9jY3VycmVkIHdoaWxlIHN5bmNpbmcgZGF0YSdcclxuICAgIH0sXHJcbiAgICBzeW5jQ2FuY2VsbGVkOiB7XHJcbiAgICAgICAgY29kZTogNDI0MyxcclxuICAgICAgICBtZXNzYWdlOiAnU3luY2hyb25pemF0aW9uIGNhbmNlbGxlZCBieSB1c2VyJ1xyXG4gICAgfSxcclxuICAgIHN5bmNJblByb2dyZXNzOiB7XHJcbiAgICAgICAgY29kZTogNDI0NCxcclxuICAgICAgICBtZXNzYWdlOiAnQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIHdoaWxlIHN5bmNocm9uaXphdGlvbiBpcyBpbiBwcm9ncmVzcydcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBFdmVybGl2ZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZXJsaXZlRXJyb3IoKSB7XHJcbiAgICAgICAgdmFyIHRtcCA9IEVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIHRtcC5uYW1lID0gdGhpcy5uYW1lID0gJ0V2ZXJsaXZlRXJyb3InO1xyXG5cclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0bXAubWVzc2FnZTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wLnN0YWNrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgRXZlcmxpdmVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcbiAgICBFdmVybGl2ZUVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEV2ZXJsaXZlRXJyb3I7XHJcbn0oKSk7XHJcblxyXG52YXIgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIERldmljZVJlZ2lzdHJhdGlvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yVHlwZSwgbWVzc2FnZSwgYWRkaXRpb25hbEluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgRXZlcmxpdmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuZXJyb3JUeXBlID0gZXJyb3JUeXBlO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxJbmZvcm1hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkaXRpb25hbEluZm9ybWF0aW9uID0gYWRkaXRpb25hbEluZm9ybWF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVybGl2ZUVycm9yLnByb3RvdHlwZSk7XHJcblxyXG4gICAgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IuZnJvbUV2ZXJsaXZlRXJyb3IgPSBmdW5jdGlvbiAoZXZlcmxpdmVFcnJvcikge1xyXG4gICAgICAgIHZhciBkZXZpY2VSZWdpc3RyYXRpb25FcnJvciA9IG5ldyBEZXZpY2VSZWdpc3RyYXRpb25FcnJvcihEZXZpY2VSZWdpc3RyYXRpb25FcnJvclR5cGVzLkV2ZXJsaXZlRXJyb3IsIGV2ZXJsaXZlRXJyb3IubWVzc2FnZSwgZXZlcmxpdmVFcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIGRldmljZVJlZ2lzdHJhdGlvbkVycm9yO1xyXG4gICAgfTtcclxuXHJcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5mcm9tUGx1Z2luRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JPYmopIHtcclxuICAgICAgICB2YXIgbWVzc2FnZSA9ICdBIHBsdWdpbiBlcnJvciBvY2N1cnJlZCc7XHJcbiAgICAgICAgaWYgKGVycm9yT2JqKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3JPYmouZXJyb3IgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3JPYmouZXJyb3I7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yT2JqLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3JPYmoubWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRldmljZVJlZ2lzdHJhdGlvbkVycm9yID0gbmV3IERldmljZVJlZ2lzdHJhdGlvbkVycm9yKERldmljZVJlZ2lzdHJhdGlvbkVycm9yVHlwZXMuUGx1Z2luRXJyb3IsIG1lc3NhZ2UsIGVycm9yT2JqKTtcclxuICAgICAgICByZXR1cm4gZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3I7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBEZXZpY2VSZWdpc3RyYXRpb25FcnJvclR5cGVzID0ge1xyXG4gICAgICAgIEV2ZXJsaXZlRXJyb3I6IDEsXHJcbiAgICAgICAgUGx1Z2luRXJyb3I6IDJcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIERldmljZVJlZ2lzdHJhdGlvbkVycm9yO1xyXG59KCkpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBFdmVybGl2ZUVycm9yOiBFdmVybGl2ZUVycm9yLFxyXG4gICAgRXZlcmxpdmVFcnJvcnM6IEV2ZXJsaXZlRXJyb3JzLFxyXG4gICAgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3I6IERldmljZVJlZ2lzdHJhdGlvbkVycm9yXHJcbn07IiwidmFyIFByb2Nlc3NvciA9IHJlcXVpcmUoJy4vY29tbW9uJykuUHJvY2Vzc29yO1xyXG52YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeS9EYXRhUXVlcnknKTtcclxudmFyIFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeS9RdWVyeScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9jZXNzb3Ioe1xyXG4gICAgICAgIGV4ZWN1dGlvbk5vZGVGdW5jdGlvbjogZnVuY3Rpb24gKG5vZGUsIGV4cGFuZENvbnRleHQsIGRvbmUpIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWQsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogbm9kZS50YXJnZXRUeXBlTmFtZSxcclxuICAgICAgICAgICAgICAgIGZpbHRlcjogbmV3IFF1ZXJ5KG5vZGUuZmlsdGVyLCBub2RlLnNlbGVjdCwgbm9kZS5zb3J0LCBub2RlLnNraXAsIG5vZGUudGFrZSlcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBleHBhbmRDb250ZXh0Lm9mZmxpbmVNb2R1bGUucHJvY2Vzc1F1ZXJ5KHF1ZXJ5KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKG51bGwsIGRhdGEucmVzdWx0KTtcclxuICAgICAgICAgICAgfSwgZG9uZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb246IGZ1bmN0aW9uIChyZWxhdGlvbk5hbWVzLCBtYXAsIHByZXBhcmVDb250ZXh0LCBkb25lKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHJlbCBpbiBtYXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkocmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFwW3JlbF0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFtyZWxdLnZhbGlkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSgpKTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvbihvcGVyYXRvciwgb3BlcmFuZHMpIHtcclxuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcbiAgICAgICAgdGhpcy5vcGVyYW5kcyA9IG9wZXJhbmRzIHx8IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGFkZE9wZXJhbmQ6IGZ1bmN0aW9uIChvcGVyYW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlcmFuZHMucHVzaChvcGVyYW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBFeHByZXNzaW9uO1xyXG59KCkpOyIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vVE9ETyBhZGQgYSBmdW5jdGlvbiBmb3IgY2FsY3VsYXRpbmcgdGhlIGRpc3RhbmNlcyBpbiBnZW9zcGF0aWFsIHF1ZXJpZXNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBjbGFzcyByZXByZXNlbnRpbmcgYSB2YWx1ZSBmb3IgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gR2VvUG9pbnQgZmllbGQuXHJcbiAgICAgKiBAY2xhc3MgR2VvUG9pbnRcclxuICAgICAqIEBwYXJhbSBsb25naXR1ZGUgTG9uZ2l0dWRlIG9mIHRoZSBHZW9Qb2ludCBpbiBkZWNpbWFsIGRlZ3JlZXMgKHJhbmdlOiAtMTgwIHRvIDE4MCkuIEV4YW1wbGU6IGAxMjMuMzIzOTQ2N2BcclxuICAgICAqIEBwYXJhbSBsYXRpdHVkZSBMYXRpdHVkZSBvZiB0aGUgR2VvUG9pbnQgaW4gZGVjaW1hbCBkZWdyZWVzIChyYW5nZTogLTkwIHRvIDkwKS4gRXhhbXBsZTogYDQyLjY5NTQzMjJgXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEdlb1BvaW50KGxvbmdpdHVkZSwgbGF0aXR1ZGUpIHtcclxuICAgICAgICB0aGlzLmxvbmdpdHVkZSA9IGxvbmdpdHVkZSB8fCAwO1xyXG4gICAgICAgIHRoaXMubGF0aXR1ZGUgPSBsYXRpdHVkZSB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBHZW9Qb2ludDtcclxufSgpKTsiLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBidWlsZFByb21pc2UgPSB1dGlscy5idWlsZFByb21pc2U7XHJcbnZhciBEZXZpY2VSZWdpc3RyYXRpb25SZXN1bHQgPSB1dGlscy5EZXZpY2VSZWdpc3RyYXRpb25SZXN1bHQ7XHJcbnZhciBldmVybGl2ZUVycm9yTW9kdWxlID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIERldmljZVJlZ2lzdHJhdGlvbkVycm9yID0gZXZlcmxpdmVFcnJvck1vZHVsZS5EZXZpY2VSZWdpc3RyYXRpb25FcnJvcjtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSBldmVybGl2ZUVycm9yTW9kdWxlLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBDdXJyZW50RGV2aWNlID0gcmVxdWlyZSgnLi9DdXJyZW50RGV2aWNlJyk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgUHVzaFxyXG4gICAgICogQGNsYXNzZGVzYyBBIGNsYXNzIGZvciBtYW5hZ2luZyBwdXNoIG5vdGlmaWNhdGlvbnMgaW4geW91ciBhcHBsaWNhdGlvbi4gU3VwcG9ydGVkIGFyZSBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIGh5YnJpZCBhcHBzIG9uIEFuZHJvaWQgYW5kIGlPUy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBlbCB7RXZlcmxpdmV9IEV2ZXJsaXZlIE9iamVjdFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQdXNoKGVsKSB7XHJcbiAgICAgICAgdGhpcy5fZWwgPSBlbDtcclxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBlbC5kYXRhKCdQdXNoL05vdGlmaWNhdGlvbnMnKTtcclxuICAgICAgICB0aGlzLmRldmljZXMgPSBlbC5kYXRhKCdQdXNoL0RldmljZXMnKTtcclxuICAgIH1cclxuXHJcbiAgICBQdXNoLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5zdXJlcyB0aGF0IHRoZSBUZWxlcmlrIFB1c2ggTm90aWZpY2F0aW9ucyBwbHVnLWluIGhhcyBiZWVuIGxvYWRlZCBhbmQgaXMgcmVhZHkgdG8gdXNlLiBBbiB7RXZlcmxpdmVFcnJvcn0gaXMgcmV0dXJuZWQgaWYgdGhlIHBsdWctaW4gaXMgbm90IGF2YWlsYWJsZS5cclxuICAgICAgICAgKiBAbWV0aG9kIGVuc3VyZVB1c2hJc0F2YWlsYWJsZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVuc3VyZVB1c2hJc0F2YWlsYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaXNQdXNoTm90aWZpY2F0aW9uUGx1Z2luQXZhaWxhYmxlID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wbHVnaW5zICYmIHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc1B1c2hOb3RpZmljYXRpb25QbHVnaW5BdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKFwiVGhlIHB1c2ggbm90aWZpY2F0aW9uIHBsdWdpbiBpcyBub3QgYXZhaWxhYmxlLiBFbnN1cmUgdGhhdCB0aGUgcHVzaE5vdGlmaWNhdGlvbiBwbHVnaW4gaXMgaW5jbHVkZWQgXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJhbmQgdXNlIGFmdGVyIGBkZXZpY2VyZWFkeWAgZXZlbnQgaGFzIGJlZW4gZmlyZWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRldmljZSBmb3Igc2VuZGluZyBwdXNoIG5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMi43XHJcbiAgICAgICAgICogQHNlZSBbUHVzaC5yZWdpc3Rlcl17QGxpbmsgcHVzaC5yZWdpc3Rlcn1cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGN1cnJlbnREZXZpY2VcclxuICAgICAgICAgKiBAbmFtZSBjdXJyZW50RGV2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIFtlbXVsYXRvck1vZGVdIHtCb29sZWFufSBJZiBzZXQgdG8gdHJ1ZSwgZW11bGF0b3IgbW9kZSBpcyBlbmFibGVkIG1lYW5pbmcgeW91IGNhbm5vdCBzZW5kIHB1c2ggbm90aWZpY2F0aW9ucy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7Q3VycmVudERldmljZX0gUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDdXJyZW50RGV2aWNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGN1cnJlbnREZXZpY2U6IGZ1bmN0aW9uIChlbXVsYXRvck1vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBlbXVsYXRvck1vZGUgPSB0aGlzLl9lbC5zZXR1cC5fZW11bGF0b3JNb2RlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5jb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignRXJyb3I6IGN1cnJlbnREZXZpY2UoKSBjYW4gb25seSBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBoeWJyaWQgbW9iaWxlIGFwcCwgYWZ0ZXIgXFwnZGV2aWNlcmVhZHlcXCcgZXZlbnQgaGFzIGJlZW4gZmlyZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudERldmljZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudERldmljZSA9IG5ldyBDdXJyZW50RGV2aWNlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RGV2aWNlLmVtdWxhdG9yTW9kZSA9IGVtdWxhdG9yTW9kZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RGV2aWNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZXMgcHVzaCBub3RpZmljYXRpb25zIG9uIHRoZSBkZXZpY2UgYW5kIHJlZ2lzdGVycyBpdCBmb3IgdGhlIGZlYXR1cmUgd2l0aCB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZC4gSWYgaXQgaGFzIGJlZW4gcmVnaXN0ZXJlZCwgdGhlIHJlZ2lzdHJhdGlvbiBkZXRhaWxzIGFyZSB1cGRhdGVkLlxyXG4gICAgICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAbmFtZSByZWdpc3RlclxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncyBBbiBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi4gSXQgY2FuIGluY2x1ZGUgY3VzdG9tIHBhcmFtZXRlcnMgdG8gYmUgc3RvcmVkIGJ5IHt7c2l0ZS5ic319LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy5pT1M9bnVsbCBpT1Mtc3BlY2lmaWMgc2V0dGluZ3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBzZXR0aW5ncy5pT1MuYWxlcnQ9dHJ1ZSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHB1c2ggbm90aWZpY2F0aW9uIHdpbGwgZGlzcGxheSBhcyBhIHN0YW5kYXJkIGlPUyBhbGVydC5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHNldHRpbmdzLmlPUy5iYWRnZT0nKzEnIFNwZWNpZmllcyB0aGUgYmFkZ2UgY291bnRlciB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIGRldmljZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5zb3VuZD10cnVlIElmIHNldCB0byB0cnVlLCB0aGUgZGV2aWNlIHdpbGwgcGxheSBhIG5vdGlmaWNhdGlvbiBzb3VuZC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MuYW5kcm9pZD1udWxsIEFuZHJvaWQtc3BlY2lmaWMgc2V0dGluZ3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmFuZHJvaWQuc2VuZGVySUQ9bnVsbCBZb3VyIEdvb2dsZSBBUEkgcHJvamVjdCBudW1iZXIuIEl0IGlzIHJlcXVpcmVkIHdoZW4gb2J0YWluaW5nIGEgcHVzaCB0b2tlbiBmb3IgYW4gQW5kcm9pZCBkZXZpY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmFuZHJvaWQucHJvamVjdE51bWJlcj1udWxsIFN5bm9ueW0gZm9yIGFuZHJvaWQuc2VuZGVySUQuIEF2YWlsYWJsZSBpbiBKYXZhU2NyaXB0IFNESyB2ZXJzaW9ucyAxLjIuNyBhbmQgbGF0ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLndwOD1udWxsIFdpbmRvd3MgUGhvbmUgc3BlY2lmaWMgc2V0dGluZ3MuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBvbiB0aGUgZGV2aWNlIGFuZCByZWdpc3RlcnMgaXQgZm9yIHRoZSBmZWF0dXJlIHdpdGgge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuIElmIGl0IGhhcyBiZWVuIHJlZ2lzdGVyZWQsIHRoZSByZWdpc3RyYXRpb24gZGV0YWlscyBhcmUgdXBkYXRlZC5cclxuICAgICAgICAgKiBUZWxlcmlrIEJhY2tlbmQgU2VydmljZXMgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLlxyXG4gICAgICAgICAqIElmIGl0IHdhcyByZWdpc3RlcmVkIHRoZSByZWdpc3RyYXRpb24gZGV0YWlscyBhcmUgdXBkYXRlZC5cclxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgU2V0dGluZ3MgZm9yIHRoZSByZWdpc3RyYXRpb24uIENhbiBpbmNsdWRlIGN1c3RvbSBwYXJhbWV0ZXJzIHRvIGJlIHNhdmVkIGluIGJhY2tlbmQgc2VydmljZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLmlPUz1udWxsIGlPUyBzcGVjaWZpYyBzZXR0aW5nc1xyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2V0dGluZ3MuaU9TLmFsZXJ0PXRydWUgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRldmljZSB3aWxsIGRpc3BsYXkgYW4gYWxlcnQgbWVzc2FnZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHNldHRpbmdzLmlPUy5iYWRnZT0nKzEnIFNwZWNpZmllcyB0aGUgYmFkZ2UgY291bnRlciB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIGRldmljZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5zb3VuZD10cnVlIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBkZXZpY2Ugd2lsbCBwbGF5IGEgc291bmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLmFuZHJvaWQ9bnVsbCBBbmRyb2lkIHNwZWNpZmljIHNldHRpbmdzXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmFuZHJvaWQuc2VuZGVySUQ9bnVsbCBUaGlzIGlzIHlvdXIgR29vZ2xlIEFQSSBwcm9qZWN0IG51bWJlci4gSXQgaXMgcmVxdWlyZWQgd2hlbiBvYnRhaW5pbmcgYSBwdXNoIHRva2VuIGZvciBhbiBBbmRyb2lkIGRldmljZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2V0dGluZ3MuYW5kcm9pZC5wcm9qZWN0TnVtYmVyPW51bGwgU3lub255bSBmb3IgYW5kcm9pZC5zZW5kZXJJRC4gQXZhaWxhYmxlIGluIEphdmFTY3JpcHQgU0RLIHZlcnNpb25zIDEuMi43IGFuZCBsYXRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3Mud3A4PW51bGwgV2luZG93cyBQaG9uZSBzcGVjaWZpYyBzZXR0aW5nc1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24gKHNldHRpbmdzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnREZXZpY2UgPSB0aGlzLmN1cnJlbnREZXZpY2UoKTtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFuZHJvaWQpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFuZHJvaWQuc2VuZGVySUQgPSBzZXR0aW5ncy5hbmRyb2lkLnByb2plY3ROdW1iZXIgfHwgc2V0dGluZ3MuYW5kcm9pZC5zZW5kZXJJRDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uICh0b2tlbiwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9uUmVzdWx0KHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgZXJyb3JDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uRXJyb3IgPSBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5mcm9tRXZlcmxpdmVFcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVnaXN0cmF0aW9uRXJyb3IpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGNsZWFyQmFkZ2VJZk5lZWRlZCA9IGZ1bmN0aW9uICh0b2tlbiwgc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGxhdGZvcm1UeXBlID0gY3VycmVudERldmljZS5fZ2V0UGxhdGZvcm1UeXBlKGRldmljZS5wbGF0Zm9ybSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xlYXJCYWRnZSA9IHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uaU9TO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhckJhZGdlICYmIHNldHRpbmdzLmlPUykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQmFkZ2UgPSBzZXR0aW5ncy5pT1MuY2xlYXJCYWRnZSAhPT0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyQmFkZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyQmFkZ2VOdW1iZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHRva2VuLCBzdWNjZXNzQ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIsIGVycm9yQ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2sodG9rZW4sIHN1Y2Nlc3NDYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzQ2IsIGVycm9yQ2IpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuZW5hYmxlTm90aWZpY2F0aW9ucyhzZXR0aW5ncywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gcmVzcG9uc2UudG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbVBhcmFtZXRlcnMgPSBzZXR0aW5ncy5jdXN0b21QYXJhbWV0ZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuZ2V0UmVnaXN0cmF0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERldmljZS51cGRhdGVSZWdpc3RyYXRpb24oY3VzdG9tUGFyYW1ldGVycywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyQmFkZ2VJZk5lZWRlZCh0b2tlbiwgc3VjY2Vzc0NiLCBlcnJvckNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVyciwgZXJyb3JDYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSA4MDEpIHsgLy9Ob3QgcmVnaXN0ZXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UucmVnaXN0ZXIoY3VzdG9tUGFyYW1ldGVycywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckJhZGdlSWZOZWVkZWQodG9rZW4sIHN1Y2Nlc3NDYiwgZXJyb3JDYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3JDYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyLCBlcnJvckNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRldmljZVJlZ2lzdHJhdGlvbkVycm9yID0gRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IuZnJvbVBsdWdpbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYihkZXZpY2VSZWdpc3RyYXRpb25FcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uIFRoZSBkZXZpY2Ugd2lsbCBhbHNvIGJlIHVucmVnaXN0ZXJlZCBmcm9tIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uXHJcbiAgICAgICAgICogQG1ldGhvZCB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZXMgcHVzaCBub3RpZmljYXRpb25zIGZvciB0aGUgY3VycmVudCBkZXZpY2UuIFRoaXMgbWV0aG9kIGludmFsaWRhdGVzIGFueSBwdXNoIHRva2VucyB0aGF0IHdlcmUgb2J0YWluZWQgZm9yIHRoZSBkZXZpY2UgZnJvbSB0aGUgY3VycmVudCBhcHBsaWNhdGlvbi4gVGhlIGRldmljZSB3aWxsIGFsc28gYmUgdW5yZWdpc3RlcmVkIGZyb20ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fS5cclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uXHJcbiAgICAgICAgICogVGhlIGRldmljZSB3aWxsIGFsc28gYmUgdW5yZWdpc3RlcmVkIGZyb20gVGVsZXJpayBCYWNrZW5kIFNlcnZpY2VzLlxyXG4gICAgICAgICAqIEBtZXRob2QgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uIChvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5jdXJyZW50RGV2aWNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGV2aWNlLmRpc2FibGVOb3RpZmljYXRpb25zLmFwcGx5KGN1cnJlbnREZXZpY2UsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcmVnaXN0cmF0aW9uIG9mIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB7dW5kZWZpbmVkfSwgY3VzdG9tUGFyYW1ldGVycyBhcmUgbm90IHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB7dW5kZWZpbmVkfSwgY3VzdG9tUGFyYW1ldGVycyBhcmUgbm90IHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGVSZWdpc3RyYXRpb246IGZ1bmN0aW9uIChjdXN0b21QYXJhbWV0ZXJzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5jdXJyZW50RGV2aWNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGV2aWNlLnVwZGF0ZVJlZ2lzdHJhdGlvbi5hcHBseShjdXJyZW50RGV2aWNlLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGJhZGdlIG51bWJlciBvbiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBzZXJ2ZXIuXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBuYW1lIHNldEJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBiYWRnZSBUaGUgbnVtYmVyIHRvIGJlIHNldCBhcyBhIGJhZGdlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgYmFkZ2UgbnVtYmVyIG9uIHRoZSBzZXJ2ZXJcclxuICAgICAgICAgKiBAbWV0aG9kIHNldEJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG5hbWUgc2V0QmFkZ2VOdW1iZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGJhZGdlIFRoZSBudW1iZXIgdG8gYmUgc2V0IGFzIGEgYmFkZ2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRCYWRnZU51bWJlcjogZnVuY3Rpb24gKGJhZGdlLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIGJhZGdlID0gcGFyc2VJbnQoYmFkZ2UpO1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4oYmFkZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yKG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgYmFkZ2UgbXVzdCBoYXZlIGEgbnVtZXJpYyB2YWx1ZScpKTtcclxuICAgICAgICAgICAgICAgIH0sIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkZXZpY2VSZWdpc3RyYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnREZXZpY2UgPSB0aGlzLmN1cnJlbnREZXZpY2UoKTtcclxuICAgICAgICAgICAgdmFyIGRldmljZUlkID0gY3VycmVudERldmljZS5fZ2V0RGV2aWNlSWQoKTtcclxuICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLklkID0gJ0hhcmR3YXJlSWQvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCk7XHJcbiAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5CYWRnZUNvdW50ZXIgPSBiYWRnZTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGV2aWNlLl9wdXNoSGFuZGxlci5kZXZpY2VzLnVwZGF0ZVNpbmdsZShkZXZpY2VSZWdpc3RyYXRpb24pLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LnBsdWdpbnMgJiYgd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb24uc2V0QXBwbGljYXRpb25JY29uQmFkZ2VOdW1iZXIoc3VjY2Vzc0NiLCBlcnJvckNiLCBiYWRnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzc0NiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvckNiKVxyXG4gICAgICAgICAgICB9LCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGUgYmFkZ2UgbnVtYmVyIG9uIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHNlcnZlciB0byAwLlxyXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBuYW1lIGNsZWFyQmFkZ2VOdW1iZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyB0aGUgYmFkZ2UgbnVtYmVyIG9uIHRoZSBzZXJ2ZXIgYnkgc2V0dGluZyBpdCB0byAwXHJcbiAgICAgICAgICogQG1ldGhvZCBjbGVhckJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG5hbWUgY2xlYXJCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xlYXJCYWRnZU51bWJlcjogZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0QmFkZ2VOdW1iZXIoMCwgb25TdWNjZXNzLCBvbkVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwdXNoIG5vdGlmaWNhdGlvbnMgcmVnaXN0cmF0aW9uIGZvciB0aGUgY3VycmVudCBkZXZpY2UuXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbmFtZSBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHB1c2ggcmVnaXN0cmF0aW9uIGZvciB0aGUgY3VycmVudCBkZXZpY2UuXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbmFtZSBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFJlZ2lzdHJhdGlvbjogZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnREZXZpY2UgPSB0aGlzLmN1cnJlbnREZXZpY2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZXZpY2UuZ2V0UmVnaXN0cmF0aW9uLmFwcGx5KGN1cnJlbnREZXZpY2UsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VuZHMgYSBwdXNoIG5vdGlmaWNhdGlvbi5cclxuICAgICAgICAgKiBAbWV0aG9kIHNlbmRcclxuICAgICAgICAgKiBAbmFtZSBzZW5kXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vdGlmaWNhdGlvbiBUaGUgcHVzaCBub3RpZmljYXRpb24gb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlbmRzIGEgcHVzaCBtZXNzYWdlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZW5kXHJcbiAgICAgICAgICogQG5hbWUgc2VuZFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZmljYXRpb24gVGhlIHB1c2ggbm90aWZpY2F0aW9uIG9iamVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2VuZDogZnVuY3Rpb24gKG5vdGlmaWNhdGlvbiwgb25TdWNjZXNzLCBvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3RpZmljYXRpb25zLmNyZWF0ZS5hcHBseSh0aGlzLm5vdGlmaWNhdGlvbnMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBkaWZmZXJlbnQgb3BlcmF0aW9uIG9uIGVhY2ggc3VwcG9ydGVkIHBsYXRmb3JtOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLSBPbiBpT1M6IENoZWNrcyBpZiBOb3RpZmljYXRpb25zIGlzIGVuYWJsZWQgZm9yIHRoaXMgYXBwbGljYXRpb24gaW4gdGhlIGRldmljZSdzIE5vdGlmaWNhdGlvbiBDZW50ZXIuXHJcbiAgICAgICAgICogLSBPbiBXaW5kb3dzIFBob25lOiBDaGVja3MgaWYgdGhlIGFwcGxpY2F0aW9uIGhhcyBhbiBhY3RpdmUgb3BlbiBjaGFubmVsIGZvciBjb21tdW5pY2F0aW9uIHdpdGggdGhlIE1pY3Jvc29mdCBQdXNoIE5vdGlmaWNhdGlvbiBTZXJ2aWNlLiBUaGUgb3V0Y29tZSBkb2VzIG5vdCBkZXBlbmQgb24gdGhlIGRldmljZSdzIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cclxuICAgICAgICAgKiAtIE9uIEFuZHJvaWQ6IENoZWNrcyBpZiB0aGUgYXBwbGljYXRpb24gaGFzIGVzdGFibGlzaGVkIGEgY29ubmVjdGlvbiB3aXRoIEdvb2dsZSBDbG91ZCBNZXNzYWdpbmcuIFRoZSBvdXRjb21lIGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgZGV2aWNlJ3Mgbm90aWZpY2F0aW9uIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEBtZXRob2QgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWRcclxuICAgICAgICAgKiBAbmFtZSBhcmVOb3RpZmljYXRpb25zRW5hYmxlZFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBwYXNzZWQgdG8gdGhlIFB1c2ggTm90aWZpY2F0aW9uIHBsdWdpbidzIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkIG1ldGhvZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogaU9TOiBDaGVja3MgaWYgdGhlIE5vdGlmaWNhdGlvbnMgYXJlIGVuYWJsZWQgZm9yIHRoaXMgQXBwbGljYXRpb24gaW4gdGhlIERldmljZSdzIE5vdGlmaWNhdGlvbiBDZW50ZXIuXHJcbiAgICAgICAgICogV2luZG93cyBQaG9uZTogQ2hlY2tzIGlmIHRoZSBBcHBsaWNhdGlvbiBoYXMgYW4gYWN0aXZlIG9wZW5lZCBDaGFubmVsIGZvciBjb21tdW5pY2F0aW9uIHdpdGggdGhlIE5vdGlmaWNhdGlvbiBTZXJ2aWNlLiBOb3QgcmVseWluZyBvbiB0aGUgZGV2aWNlIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cclxuICAgICAgICAgKiBBbmRyb2lkOiBDaGVja3MgaWYgdGhlIEFwcGxpY2F0aW9uIGhhcyBlc3RhYmxpc2hlZCBjb25uZWN0aW9uIHdpdGggdGhlIE5vdGlmaWNhdGlvbiBTZXJ2aWNlLiBOb3QgcmVseWluZyBvbiB0aGUgZGV2aWNlIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cclxuICAgICAgICAgKiBAbWV0aG9kIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkXHJcbiAgICAgICAgICogQG5hbWUgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWRcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhbiBvYmplY3QgcGFzc2VkIHRvIHRoZSBQdXNoIE5vdGlmaWNhdGlvbiBwbHVnaW4ncyBhcmVOb3RpZmljYXRpb25zRW5hYmxlZCBtZXRob2QuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3NmdWwgY2hlY2suIFBhc3NlcyBhIHNpbmdsZSBib29sZWFuIHZhbHVlOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBlcnJvciBpbiB0aGUgcHVzaCBwbHVnaW4gaGFzIG9jY3VycmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkOiBmdW5jdGlvbiAob3B0aW9ucywgb25TdWNjZXNzLCBvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgdmFyIHB1c2hOb3RpZmljYXRpb24gPSB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLmFyZU5vdGlmaWNhdGlvbnNFbmFibGVkKHN1Y2Nlc3NDYiwgZXJyb3JDYiwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH0sIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUHVzaDtcclxufSgpKTsiLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBidWlsZEF1dGhIZWFkZXIgPSB1dGlscy5idWlsZEF1dGhIZWFkZXI7XHJcbnZhciBwYXJzZVV0aWxpdGllcyA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzO1xyXG52YXIgZ3VhcmRVbnNldCA9IHV0aWxzLmd1YXJkVW5zZXQ7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xyXG52YXIgcmVxd2VzdCA9IGNvbW1vbi5yZXF3ZXN0O1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgSGVhZGVycyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuSGVhZGVycztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBfc2VsZjtcclxuXHJcbiAgICAvLyBUaGUgUmVxdWVzdCB0eXBlIGlzIGFuIGFic3RyYWN0aW9uIG92ZXIgQWpheCBsaWJyYXJpZXNcclxuICAgIC8vIEEgUmVxdWVzdCBvYmplY3QgbmVlZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIEV2ZXJsaXZlIGNvbm5lY3Rpb24gYW5kIGluaXRpYWxpemF0aW9uIG9wdGlvbnNcclxuXHJcbiAgICBmdW5jdGlvbiBSZXF1ZXN0KHNldHVwLCBvcHRpb25zKSB7XHJcbiAgICAgICAgZ3VhcmRVbnNldChzZXR1cCwgJ3NldHVwJyk7XHJcbiAgICAgICAgZ3VhcmRVbnNldChvcHRpb25zLCAnb3B0aW9ucycpO1xyXG4gICAgICAgIHRoaXMuc2V0dXAgPSBzZXR1cDtcclxuICAgICAgICB0aGlzLm1ldGhvZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTtcclxuICAgICAgICAvLyBUT0RPIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcyBzaG91bGQgYmUgdW5pZm9ybWVkIGZvciBhbGwgYWpheCBsaWJzXHJcbiAgICAgICAgdGhpcy5zdWNjZXNzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcnNlID0gUmVxdWVzdC5wYXJzZXJzLnNpbXBsZTtcclxuICAgICAgICBfLmV4dGVuZCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICBfc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBSZXF1ZXN0LnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvLyBDYWxscyB0aGUgdW5kZXJseWluZyBBamF4IGxpYnJhcnlcclxuICAgICAgICBzZW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3Quc2VuZFJlcXVlc3QodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBSZXR1cm5zIGFuIGF1dGhvcml6YXRpb24gaGVhZGVyIHVzZWQgYnkgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBsb2dnZWQgaW4gdXNlciBmb3IgdGhlIEV2ZXJsaXZlIGluc3RhbmNlIHRoZW4gaGVyL2hpcyBhdXRoZW50aWNhdGlvbiB3aWxsIGJlIHVzZWQuXHJcbiAgICAgICAgYnVpbGRBdXRoSGVhZGVyOiBidWlsZEF1dGhIZWFkZXIsXHJcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBVUkwgb2YgdGhlIHRhcmdldCBFdmVybGl2ZSBzZXJ2aWNlXHJcbiAgICAgICAgYnVpbGRVcmw6IGZ1bmN0aW9uIGJ1aWxkVXJsKHNldHVwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5idWlsZFVybChzZXR1cCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIHF1ZXJ5IHRvIHJldHVybiBhcHByb3ByaWF0ZSBoZWFkZXJzIHRvIGJlIHVzZWQgYnkgdGhlIHJlcXVlc3RcclxuICAgICAgICBidWlsZFF1ZXJ5SGVhZGVyczogZnVuY3Rpb24gYnVpbGRRdWVyeUhlYWRlcnMocXVlcnkpIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkgaW5zdGFuY2VvZiBFdmVybGl2ZS5RdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZXF1ZXN0LnByb3RvdHlwZS5fYnVpbGRRdWVyeUhlYWRlcnMocXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlcXVlc3QucHJvdG90eXBlLl9idWlsZEZpbHRlckhlYWRlcihxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIFJlcXVlc3Qgb2JqZWN0IGJ5IHVzaW5nIHRoZSBwYXNzZWQgb3B0aW9uc1xyXG4gICAgICAgIF9pbml0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBfLmV4dGVuZCh0aGlzLmhlYWRlcnMsIHRoaXMuYnVpbGRBdXRoSGVhZGVyKHRoaXMuc2V0dXAsIG9wdGlvbnMpLCB0aGlzLmJ1aWxkUXVlcnlIZWFkZXJzKG9wdGlvbnMuZmlsdGVyKSwgb3B0aW9ucy5oZWFkZXJzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFRyYW5zbGF0ZXMgYW4gRXZlcmxpdmUuUXVlcnkgdG8gcmVxdWVzdCBoZWFkZXJzXHJcbiAgICAgICAgX2J1aWxkUXVlcnlIZWFkZXJzOiBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5idWlsZCgpO1xyXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAocXVlcnkuJHdoZXJlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuZmlsdGVyXSA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LiR3aGVyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LiRzZWxlY3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy5zZWxlY3RdID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuJHNlbGVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LiRzb3J0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuc29ydF0gPSBKU09OLnN0cmluZ2lmeShxdWVyeS4kc29ydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LiRza2lwICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuc2tpcF0gPSBxdWVyeS4kc2tpcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocXVlcnkuJHRha2UgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy50YWtlXSA9IHF1ZXJ5LiR0YWtlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS4kZXhwYW5kICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuZXhwYW5kXSA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LiRleHBhbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQ3JlYXRlcyBhIGhlYWRlciBmcm9tIGEgc2ltcGxlIGZpbHRlclxyXG4gICAgICAgIF9idWlsZEZpbHRlckhlYWRlcjogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xyXG4gICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuZmlsdGVyXSA9IEpTT04uc3RyaW5naWZ5KGZpbHRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmcgPSBfc2VsZiAmJiBfc2VsZi5zZXR1cCAmJiBfc2VsZi5zZXR1cC5wYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lT2JqZWN0cztcclxuXHJcbiAgICB2YXIgcmV2aXZlciA9IHBhcnNlVXRpbGl0aWVzLmdldFJldml2ZXIocGFyc2VPbmx5Q29tcGxldGVEYXRlVGltZVN0cmluZyk7XHJcblxyXG4gICAgUmVxdWVzdC5wYXJzZXJzID0ge1xyXG4gICAgICAgIHNpbXBsZToge1xyXG4gICAgICAgICAgICByZXN1bHQ6IHBhcnNlVXRpbGl0aWVzLnBhcnNlUmVzdWx0LmJpbmQobnVsbCwgcmV2aXZlciksXHJcbiAgICAgICAgICAgIGVycm9yOiBwYXJzZVV0aWxpdGllcy5wYXJzZUVycm9yLmJpbmQobnVsbCwgcmV2aXZlcilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpbmdsZToge1xyXG4gICAgICAgICAgICByZXN1bHQ6IHBhcnNlVXRpbGl0aWVzLnBhcnNlU2luZ2xlUmVzdWx0LmJpbmQobnVsbCwgcmV2aXZlciksXHJcbiAgICAgICAgICAgIGVycm9yOiBwYXJzZVV0aWxpdGllcy5wYXJzZUVycm9yLmJpbmQobnVsbCwgcmV2aXZlcilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZToge1xyXG4gICAgICAgICAgICByZXN1bHQ6IHBhcnNlVXRpbGl0aWVzLnBhcnNlVXBkYXRlUmVzdWx0LmJpbmQobnVsbCwgcmV2aXZlciksXHJcbiAgICAgICAgICAgIGVycm9yOiBwYXJzZVV0aWxpdGllcy5wYXJzZUVycm9yLmJpbmQobnVsbCwgcmV2aXZlcilcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRPRE8gYnVpbHQgZm9yIHJlcXVlc3RcclxuICAgIGlmICh0eXBlb2YgUmVxdWVzdC5zZW5kUmVxdWVzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBSZXF1ZXN0LnNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcclxuICAgICAgICAgICAgdmFyIHVybCA9IHJlcXVlc3QuYnVpbGRVcmwocmVxdWVzdC5zZXR1cCkgKyByZXF1ZXN0LmVuZHBvaW50O1xyXG4gICAgICAgICAgICB1cmwgPSBFdmVybGl2ZS5kaXNhYmxlUmVxdWVzdENhY2hlKHVybCwgcmVxdWVzdC5tZXRob2QpO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJlcXVlc3QubWV0aG9kID09PSAnR0VUJyA/IHJlcXVlc3QuZGF0YSA6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QuZGF0YSk7XHJcblxyXG4gICAgICAgICAgICByZXF3ZXN0KHtcclxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICAvL3Byb2Nlc3NEYXRhOiByZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIixcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc3VjY2Vzcy5jYWxsKHJlcXVlc3QsIHJlcXVlc3QucGFyc2UucmVzdWx0KGRhdGEpKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZXJyb3IuY2FsbChyZXF1ZXN0LCByZXF1ZXN0LnBhcnNlLmVycm9yKGpxWEhSLnJlc3BvbnNlVGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBSZXF1ZXN0O1xyXG59KCkpOyIsInZhciBfID0gcmVxdWlyZSgnLi9jb21tb24nKS5fO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgZXZlcmxpdmVVcmwgPSBjb25zdGFudHMuZXZlcmxpdmVVcmw7XHJcblxyXG4gICAgLy8gQW4gb2JqZWN0IHRoYXQga2VlcHMgaW5mb3JtYXRpb24gYWJvdXQgYW4gRXZlcmxpdmUgY29ubmVjdGlvblxyXG4gICAgZnVuY3Rpb24gU2V0dXAob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudXJsID0gZXZlcmxpdmVVcmw7XHJcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubWFzdGVyS2V5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRva2VuID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRva2VuVHlwZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zY2hlbWUgPSAnaHR0cCc7IC8vIGh0dHAgb3IgaHR0cHNcclxuICAgICAgICB0aGlzLnBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVPYmplY3RzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmFwaUtleSA9IG9wdGlvbnM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZW11bGF0b3JNb2RlID0gb3B0aW9ucy5lbXVsYXRvck1vZGU7XHJcbiAgICAgICAgICAgIF8uZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gU2V0dXA7XHJcblxyXG59KCkpOyIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjb21tb24gPSB7fTtcclxuXHJcbiAgICB2YXIgcGxhdGZvcm0gPSByZXF1aXJlKCcuL2V2ZXJsaXZlLnBsYXRmb3JtJyk7XHJcbiAgICB2YXIgaXNOYXRpdmVTY3JpcHQgPSBwbGF0Zm9ybS5pc05hdGl2ZVNjcmlwdDtcclxuICAgIHZhciBpc05vZGVqcyA9IHBsYXRmb3JtLmlzTm9kZWpzO1xyXG5cclxuICAgIGlmICghaXNOb2RlanMgJiYgIWlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgY29tbW9uLnJlcXdlc3QgPSByZXF1aXJlKCdyZXF3ZXN0Jyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG4gICAgICAgIGNvbW1vbi5yZXF3ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGh0dHBSZXF1ZXN0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIHVybDogb3B0aW9ucy51cmwsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IHt9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBodHRwUmVxdWVzdE9wdGlvbnMuY29udGVudCA9IG9wdGlvbnMuZGF0YTsgLy8gTk9URTogSWYgd2UgcGFzcyBudWxsL3VuZGVmaW5lZCwgaXQgd2lsbCByYWlzZSBhbiBleGNlcHRpb24gaW4gdGhlIGh0dHAgbW9kdWxlLlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBodHRwUmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICAgICAgICAgIGh0dHBSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcclxuXHJcbiAgICAgICAgICAgIHZhciBub29wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyB8fCBub29wO1xyXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yIHx8IG5vb3A7XHJcbiAgICAgICAgICAgIGh0dHAucmVxdWVzdChodHRwUmVxdWVzdE9wdGlvbnMpLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFN0cmluZyA9IHJlc3BvbnNlLmNvbnRlbnQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDQwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzIGNhbGxiYWNrIGNhbGxzIGEgY3VzdG9tIHBhcnNlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoY29udGVudFN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3IgY2FsbGJhY2sgcmVsaWVzIG9uIGEgSlNPTiBPYmplY3Qgd2l0aCBSZXNwb25zZVRleHQgaW5zaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogY29udGVudFN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yOiBmdW5jdGlvbihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aW1lb3V0aW5nIGZvciBleGFtcGxlIChpLmUuIG5vIGludGVybmV0IGNvbm5lY3Rpdml0eSksIHdlIGdldCBhbiBlcnIgd2l0aCBjb250ZW50IHsgbWVzc2FnZTogXCJ0aW1lb3V0Li4uXCIsIHN0YWNrOiBudWxsIH1cclxuICAgICAgICAgICAgICAgICAgICBlcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgIGNvbW1vbi5yb290ID0gZ2xvYmFsO1xyXG4gICAgfSBlbHNlIGlmIChpc05vZGVqcykge1xyXG4gICAgICAgIGNvbW1vbi5yb290ID0gZ2xvYmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29tbW9uLnJvb3QpIHtcclxuICAgICAgICAvL2Jyb3dzZXIvcmVxdWlyZWpzL2NvcmRvdmFcclxuICAgICAgICBjb21tb24ucm9vdCA9IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZW5zdXJlRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIGVuc3VyZURlcGVuZGVuY3koZ2xvYmFsTmFtZSwgbG9jYWxOYW1lKSB7XHJcbiAgICAgICAgaWYgKCFsb2NhbE5hbWUpIHtcclxuICAgICAgICAgICAgbG9jYWxOYW1lID0gZ2xvYmFsTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoY29tbW9uW2xvY2FsTmFtZV0pLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb21tb25bbG9jYWxOYW1lXSA9IGNvbW1vbi5yb290W2dsb2JhbE5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy9mb3IgdGhlIGV2ZXJsaXZlIGJ1bmRsZSB3aXRob3V0IGRlcGVuZGVuY2llcyBpbmNsdWRlZCBicm93c2VyaWZ5IHJlcGxhY2VzIHRoZW0gd2l0aCBlbXB0eSBvYmplY3RzXHJcbiAgICBjb21tb24uXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxuICAgIGVuc3VyZURlcGVuZGVuY3koJ18nKTtcclxuXHJcbiAgICBjb21tb24uanN0eiA9IHJlcXVpcmUoJ2pzdGltZXpvbmVkZXRlY3QnKTtcclxuICAgIGVuc3VyZURlcGVuZGVuY3koJ2pzdHonKTtcclxuXHJcbiAgICBjb21tb24ubW9uZ29RdWVyeSA9IHJlcXVpcmUoJ21vbmdvLXF1ZXJ5Jyk7XHJcbiAgICBlbnN1cmVEZXBlbmRlbmN5KCdtb25nb1F1ZXJ5Jyk7XHJcblxyXG4gICAgY29tbW9uLk1pbmdvID0gcmVxdWlyZSgnbWluZ28nKTtcclxuICAgIGVuc3VyZURlcGVuZGVuY3koJ01pbmdvJyk7XHJcblxyXG4gICAgY29tbW9uLnV1aWQgPSByZXF1aXJlKCd1dWlkJyk7XHJcbiAgICBlbnN1cmVEZXBlbmRlbmN5KCd1dWlkJyk7XHJcblxyXG4gICAgY29tbW9uLlByb2Nlc3NvciA9IHJlcXVpcmUoJy4uL3NjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3NvcicpO1xyXG4gICAgZW5zdXJlRGVwZW5kZW5jeSgnUHJvY2Vzc29yJyk7XHJcblxyXG4gICAgY29tbW9uLnJzdnAgPSByZXF1aXJlKCdyc3ZwJyk7XHJcbiAgICBlbnN1cmVEZXBlbmRlbmN5KCdSU1ZQJywgJ3JzdnAnKTtcclxuXHJcbiAgICBpZiAoIWlzTm9kZWpzICYmICFpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgIGVuc3VyZURlcGVuZGVuY3koJ3JlcXdlc3QnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29tbW9uO1xyXG59KCkpOyIsInZhciBfID0gcmVxdWlyZSgnLi9jb21tb24nKS5fO1xyXG5cclxudmFyIGNvbnN0YW50cyA9IHtcclxuICAgIGlkRmllbGQ6ICdJZCcsXHJcbiAgICBldmVybGl2ZVVybDogJy8vYXBpLmV2ZXJsaXZlLmNvbS92MS8nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNsYXNzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBjb25mbGljdCByZXNvbHV0aW9uIHN0cmF0ZWdpZXMuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gQ2xpZW50V2luc1xyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFNlcnZlcldpbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDdXN0b21cclxuICAgICAqIEB0eXBlZGVmIHtzdHJpbmd9IEV2ZXJsaXZlLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5XHJcbiAgICAgKi9cclxuICAgIENvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5OiB7XHJcbiAgICAgICAgQ2xpZW50V2luczogJ2NsaWVudFdpbnMnLFxyXG4gICAgICAgIFNlcnZlcldpbnM6ICdzZXJ2ZXJXaW5zJyxcclxuICAgICAgICBDdXN0b206ICdjdXN0b20nXHJcbiAgICB9LFxyXG4gICAgQ29uZmxpY3RSZXNvbHV0aW9uOiB7XHJcbiAgICAgICAgS2VlcFNlcnZlcjogJ2tlZXBTZXJ2ZXInLFxyXG4gICAgICAgIEtlZXBDbGllbnQ6ICdrZWVwQ2xpZW50JyxcclxuICAgICAgICBDdXN0b206ICdjdXN0b20nXHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNsYXNzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBhdmFpbGFibGUgc3RvcmFnZSBwcm92aWRlcnMuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gTG9jYWxTdG9yYWdlXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gRmlsZVN5c3RlbVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IEN1c3RvbVxyXG4gICAgICogQHR5cGVkZWYge3N0cmluZ30gRXZlcmxpdmUuU3RvcmFnZVByb3ZpZGVyc1xyXG4gICAgICovXHJcbiAgICBTdG9yYWdlUHJvdmlkZXJzOiB7XHJcbiAgICAgICAgTG9jYWxTdG9yYWdlOiAnbG9jYWxTdG9yYWdlJyxcclxuICAgICAgICBGaWxlU3lzdGVtOiAnZmlsZVN5c3RlbScsXHJcbiAgICAgICAgQ3VzdG9tOiAnY3VzdG9tJ1xyXG4gICAgfSxcclxuICAgIC8vIFRoZSBoZWFkZXJzIHVzZWQgYnkgdGhlIEV2ZXJsaXZlIHNlcnZpY2VzXHJcbiAgICBIZWFkZXJzOiB7XHJcbiAgICAgICAgZmlsdGVyOiAnWC1FdmVybGl2ZS1GaWx0ZXInLFxyXG4gICAgICAgIHNlbGVjdDogJ1gtRXZlcmxpdmUtRmllbGRzJyxcclxuICAgICAgICBzb3J0OiAnWC1FdmVybGl2ZS1Tb3J0JyxcclxuICAgICAgICBza2lwOiAnWC1FdmVybGl2ZS1Ta2lwJyxcclxuICAgICAgICB0YWtlOiAnWC1FdmVybGl2ZS1UYWtlJyxcclxuICAgICAgICBleHBhbmQ6ICdYLUV2ZXJsaXZlLUV4cGFuZCcsXHJcbiAgICAgICAgc2luZ2xlRmllbGQ6ICdYLUV2ZXJsaXZlLVNpbmdsZS1GaWVsZCcsXHJcbiAgICAgICAgaW5jbHVkZUNvdW50OiAnWC1FdmVybGl2ZS1JbmNsdWRlLUNvdW50JyxcclxuICAgICAgICBwb3dlckZpZWxkczogJ1gtRXZlcmxpdmUtUG93ZXItRmllbGRzJyxcclxuICAgICAgICBkZWJ1ZzogJ1gtRXZlcmxpdmUtRGVidWcnLFxyXG4gICAgICAgIG92ZXJyaWRlU3lzdGVtRmllbGRzOiAnWC1FdmVybGl2ZS1PdmVycmlkZS1TeXN0ZW0tRmllbGRzJ1xyXG4gICAgfSxcclxuICAgIC8vQ29uc3RhbnRzIGZvciBkaWZmZXJlbnQgcGxhdGZvcm1zIGluIEV2ZXJsaXZlXHJcbiAgICBQbGF0Zm9ybToge1xyXG4gICAgICAgIFdpbmRvd3NQaG9uZTogMSxcclxuICAgICAgICBXaW5kb3dzOiAyLFxyXG4gICAgICAgIEFuZHJvaWQ6IDMsXHJcbiAgICAgICAgaU9TOiA0LFxyXG4gICAgICAgIE9TWDogNSxcclxuICAgICAgICBCbGFja2JlcnJ5OiA2LFxyXG4gICAgICAgIE5va2lhOiA3LFxyXG4gICAgICAgIFVua25vd246IDEwMFxyXG4gICAgfSxcclxuICAgIE9wZXJhdG9yVHlwZToge1xyXG4gICAgICAgIHF1ZXJ5OiAxLFxyXG5cclxuICAgICAgICB3aGVyZTogMTAwLFxyXG4gICAgICAgIGZpbHRlcjogMTAxLFxyXG5cclxuICAgICAgICBhbmQ6IDExMCxcclxuICAgICAgICBvcjogMTExLFxyXG4gICAgICAgIG5vdDogMTEyLFxyXG5cclxuICAgICAgICBlcXVhbDogMTIwLFxyXG4gICAgICAgIG5vdF9lcXVhbDogMTIxLFxyXG4gICAgICAgIGx0OiAxMjIsXHJcbiAgICAgICAgbHRlOiAxMjMsXHJcbiAgICAgICAgZ3Q6IDEyNCxcclxuICAgICAgICBndGU6IDEyNSxcclxuICAgICAgICBpc2luOiAxMjYsXHJcbiAgICAgICAgbm90aW46IDEyNyxcclxuICAgICAgICBhbGw6IDEyOCxcclxuICAgICAgICBzaXplOiAxMjksXHJcbiAgICAgICAgcmVnZXg6IDEzMCxcclxuICAgICAgICBjb250YWluczogMTMxLFxyXG4gICAgICAgIHN0YXJ0c1dpdGg6IDEzMixcclxuICAgICAgICBlbmRzV2l0aDogMTMzLFxyXG5cclxuICAgICAgICBuZWFyU2hwZXJlOiAxNDAsXHJcbiAgICAgICAgd2l0aGluQm94OiAxNDEsXHJcbiAgICAgICAgd2l0aGluUG9seWdvbjogMTQyLFxyXG4gICAgICAgIHdpdGhpblNocGVyZTogMTQzLFxyXG5cclxuICAgICAgICBzZWxlY3Q6IDIwMCxcclxuICAgICAgICBleGNsdWRlOiAyMDEsXHJcblxyXG4gICAgICAgIG9yZGVyOiAzMDAsXHJcbiAgICAgICAgb3JkZXJfZGVzYzogMzAxLFxyXG5cclxuICAgICAgICBza2lwOiA0MDAsXHJcbiAgICAgICAgdGFrZTogNDAxLFxyXG4gICAgICAgIGV4cGFuZDogNDAyXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjbGFzcyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdW5hdXRoZW50aWNhdGVkIEluZGljYXRlcyB0aGF0IG5vIHVzZXIgaXMgYXV0aGVudGljYXRlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXN0ZXJLZXkgSW5kaWNhdGVzIHRoYXQgYSBtYXN0ZXIga2V5IGF1dGhlbnRpY2F0aW9uIGlzIHVzZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gaW52YWxpZEF1dGhlbnRpY2F0aW9uIEluZGljYXRlcyBhbiBhdXRoZW50aWNhdGlvbiBoYXMgYmVlbiBhdHRlbXB0ZWQsIGJ1dCBpdCB3YXMgaW52YWxpZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdXRoZW50aWNhdGVkIEluZGljYXRlcyB0aGF0IGEgdXNlciBpcyBhdXRoZW50aWNhdGVkLlxyXG4gICAgICogQHR5cGVkZWYge3N0cmluZ30gRXZlcmxpdmUuQXV0aFN0YXR1c1xyXG4gICAgICovXHJcbiAgICBBdXRoU3RhdHVzOiB7XHJcbiAgICAgICAgdW5hdXRoZW50aWNhdGVkOiAndW5hdXRoZW50aWNhdGVkJyxcclxuICAgICAgICBtYXN0ZXJLZXk6ICdtYXN0ZXJLZXknLFxyXG4gICAgICAgIGludmFsaWRBdXRoZW50aWNhdGlvbjogJ2ludmFsaWRBdXRoZW50aWNhdGlvbicsXHJcbiAgICAgICAgYXV0aGVudGljYXRlZDogJ2F1dGhlbnRpY2F0ZWQnXHJcbiAgICB9LFxyXG4gICAgb2ZmbGluZUl0ZW1TdGF0ZXM6IHtcclxuICAgICAgICBjcmVhdGVkOiAnY3JlYXRlZCcsXHJcbiAgICAgICAgbW9kaWZpZWQ6ICdtb2RpZmllZCcsXHJcbiAgICAgICAgZGVsZXRlZDogJ2RlbGV0ZWQnXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSFRUUCBNZXRob2RzXHJcbiAgICAgKiBAZW51bSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBIdHRwTWV0aG9kOiB7XHJcbiAgICAgICAgR0VUOiAnR0VUJyxcclxuICAgICAgICBQT1NUOiAnUE9TVCcsXHJcbiAgICAgICAgUFVUOiAnUFVUJyxcclxuICAgICAgICBERUxFVEU6ICdERUxFVEUnXHJcbiAgICB9LFxyXG4gICAgbWF4RGlzdGFuY2VDb25zdHM6IHtcclxuICAgICAgICByYWRpYW5zOiAnJG1heERpc3RhbmNlJyxcclxuICAgICAgICBrbTogJyRtYXhEaXN0YW5jZUluS2lsb21ldGVycycsXHJcbiAgICAgICAgbWlsZXM6ICckbWF4RGlzdGFuY2VJbk1pbGVzJ1xyXG4gICAgfSxcclxuICAgIHJhZGl1c0NvbnN0czoge1xyXG4gICAgICAgIHJhZGlhbnM6ICdyYWRpdXMnLFxyXG4gICAgICAgIGttOiAncmFkaXVzSW5LaWxvbWV0ZXJzJyxcclxuICAgICAgICBtaWxlczogJ3JhZGl1c0luTWlsZXMnXHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyB1c2luZyBhbiBpbnZhbGlkIGZpZWxkIG5hbWUgaW4gdGhlIGNvbnRleHQgb2YgRXZlcmxpdmVcclxuLy8gdG8gZW5zdXJlIG5vIG5hbWluZyBjb2xsaXNpb25zIGNhbiBvY2N1clxyXG5jb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXIgPSAnX19ldmVybGl2ZV9vZmZsaW5lX3N0YXRlJztcclxuXHJcbi8vIHRoZSBtaW5pbXVtIGludGVydmFsIGJldHdlZW4gc3luYyByZXF1ZXN0c1xyXG5jb25zdGFudHMuZGVmYXVsdFN5bmNJbnRlcnZhbCA9IDEwMDAgKiA2MCAqIDEwOyAvLyAxMCBtaW51dGVzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50czsiLCJ2YXIgaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbiA9IEJvb2xlYW4oKCh0eXBlb2YgYW5kcm9pZCAhPT0gJ3VuZGVmaW5lZCcgJiYgYW5kcm9pZCAmJiBhbmRyb2lkLndpZGdldCAmJiBhbmRyb2lkLndpZGdldC5CdXR0b24pXHJcbiAgICB8fCAodHlwZW9mIFVJQnV0dG9uICE9PSAndW5kZWZpbmVkJyAmJiBVSUJ1dHRvbikpKTtcclxuXHJcbmlmIChpc05hdGl2ZVNjcmlwdEFwcGxpY2F0aW9uKSB7XHJcbiAgICBnbG9iYWwuaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbiA9IGlzTmF0aXZlU2NyaXB0QXBwbGljYXRpb247XHJcbiAgICBnbG9iYWwuaXNDb3Jkb3ZhQXBwbGljYXRpb24gPSBmYWxzZTtcclxuXHJcbiAgICBnbG9iYWwud2luZG93ID0ge1xyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2U6IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uICgpIHsgfSAvL3NoaW0gZm9yIG1vbmdvLXF1ZXJ5IHVuZGVyIG5hdGl2ZXNjcmlwdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgdmFyIGlzQ29yZG92YUFwcGxpY2F0aW9uID0gL15maWxlOlxcL3szfVteXFwvXS9pLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpICYmIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxufVxyXG5cclxudmFyIGlzTm9kZWpzID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xyXG52YXIgaXNSZXF1aXJlanMgPSB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGlzQ29yZG92YTogaXNDb3Jkb3ZhQXBwbGljYXRpb24sXHJcbiAgICBpc05hdGl2ZVNjcmlwdDogaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbixcclxuICAgIGlzTm9kZWpzOiBpc05vZGVqcyxcclxuICAgIGlzUmVxdWlyZWpzOiBpc1JlcXVpcmVqc1xyXG59OyIsIi8qIVxyXG4gRXZlcmxpdmUgU0RLXHJcbiBWZXJzaW9uIDEuMi4xNFxyXG4gKi9cclxuLypnbG9iYWwgZGV2aWNlLCBkZWZpbmUsIHdpbmRvdywgbmF2aWdhdG9yKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgRXZlcmxpdmUgPSByZXF1aXJlKCcuL0V2ZXJsaXZlJyk7XHJcbiAgICB2YXIgcGxhdGZvcm0gPSByZXF1aXJlKCcuL2V2ZXJsaXZlLnBsYXRmb3JtJyk7XHJcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxuICAgIGNvbW1vbi5yb290LkV2ZXJsaXZlID0gRXZlcmxpdmU7XHJcblxyXG4gICAgaWYgKCFwbGF0Zm9ybS5pc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgIHZhciBrZW5kbyA9IHJlcXVpcmUoJy4va2VuZG8va2VuZG8uZXZlcmxpdmUnKTtcclxuICAgICAgICBFdmVybGl2ZS5jcmVhdGVEYXRhU291cmNlID0ga2VuZG8uY3JlYXRlRGF0YVNvdXJjZTtcclxuICAgICAgICBFdmVybGl2ZS5jcmVhdGVIaWVyYXJjaGljYWxEYXRhU291cmNlID0ga2VuZG8uY3JlYXRlSGllcmFyY2hpY2FsRGF0YVNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvL0dsb2JhbCBldmVudCBoYW5kbGVycyBmb3IgcHVzaCBub3RpZmljYXRpb24gZXZlbnRzLiBSZXF1aXJlZCBieSB0aGUgY29yZG92YSBQdXNoTm90aWZpY2F0aW9ucyBwbHVnaW4gdGhhdCB3ZSB1c2UuXHJcbiAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzID0ge307XHJcbiAgICBFdmVybGl2ZS5PZmZsaW5lID0ge307XHJcblxyXG4gICAgRXZlcmxpdmUuUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5L1F1ZXJ5Jyk7XHJcbiAgICBFdmVybGl2ZS5RdWVyeUJ1aWxkZXIgPSByZXF1aXJlKCcuL3F1ZXJ5L1F1ZXJ5QnVpbGRlcicpO1xyXG4gICAgRXZlcmxpdmUuR2VvUG9pbnQgPSByZXF1aXJlKCcuL0dlb1BvaW50Jyk7XHJcbiAgICBFdmVybGl2ZS5Db25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG4gICAgRXZlcmxpdmUuUmVxdWVzdCA9IHJlcXVpcmUoJy4vUmVxdWVzdCcpO1xyXG4gICAgRXZlcmxpdmUuRGF0YSA9IHJlcXVpcmUoJy4vdHlwZXMvRGF0YScpO1xyXG4gICAgRXZlcmxpdmUuX3RyYXZlcnNlQW5kUmV2aXZlID0gcmVxdWlyZSgnLi91dGlscycpLnBhcnNlVXRpbGl0aWVzLnRyYXZlcnNlQW5kUmV2aXZlO1xyXG5cclxuICAgIHZhciBwZXJzaXN0ZXJzTW9kdWxlID0gcmVxdWlyZSgnLi9vZmZsaW5lL29mZmxpbmVQZXJzaXN0ZXJzJyk7XHJcbiAgICBFdmVybGl2ZS5wZXJzaXN0ZXIgPSB7XHJcbiAgICAgICAgTG9jYWxTdG9yYWdlOiBwZXJzaXN0ZXJzTW9kdWxlLkxvY2FsU3RvcmFnZVBlcnNpc3RlcixcclxuICAgICAgICBGaWxlU3lzdGVtOiBwZXJzaXN0ZXJzTW9kdWxlLkZpbGVTeXN0ZW1QZXJzaXN0ZXJcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29tbW9uLnJvb3QuRXZlcmxpdmU7XHJcbiAgICB9XHJcbn0oKSk7IiwidmFyIFF1ZXJ5QnVpbGRlciA9IHJlcXVpcmUoJy4uL3F1ZXJ5L1F1ZXJ5QnVpbGRlcicpO1xyXG52YXIgUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9RdWVyeScpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcclxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLl87XHJcbnZhciBFdmVybGl2ZSA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlJyk7XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyICQgPSB3aW5kb3cualF1ZXJ5O1xyXG4gICAgdmFyIGtlbmRvID0gd2luZG93LmtlbmRvO1xyXG5cclxuICAgIGlmICgkID09PSB1bmRlZmluZWQgfHwga2VuZG8gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXh0ZW5kID0gJC5leHRlbmQ7XHJcblxyXG4gICAgdmFyIGV2ZXJsaXZlVHJhbnNwb3J0ID0ga2VuZG8uZGF0YS5SZW1vdGVUcmFuc3BvcnQuZXh0ZW5kKHtcclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZXJsaXZlJCA9IG9wdGlvbnMuZGF0YVByb3ZpZGVyIHx8IEV2ZXJsaXZlLiQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5ldmVybGl2ZSQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaW5zdGFuY2Ugb2YgdGhlIEJhY2tlbmQgc2VydmljZXMgc2RrIG11c3QgYmUgcHJvdmlkZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50eXBlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHR5cGUgbmFtZSBtdXN0IGJlIHByb3ZpZGVkLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRhdGFDb2xsZWN0aW9uID0gdGhpcy5ldmVybGl2ZSQuZGF0YShvcHRpb25zLnR5cGVOYW1lKTtcclxuICAgICAgICAgICAga2VuZG8uZGF0YS5SZW1vdGVUcmFuc3BvcnQuZm4uaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IHRyYW5zbGF0ZUtlbmRvUXVlcnkob3B0aW9ucy5kYXRhKTtcclxuICAgICAgICAgICAgdmFyIGV2ZXJsaXZlUXVlcnkgPSBuZXcgUXVlcnkocXVlcnkuJHdoZXJlLCBudWxsLCBxdWVyeS4kc29ydCwgcXVlcnkuJHNraXAsIHF1ZXJ5LiR0YWtlKTtcclxuICAgICAgICAgICAgdmFyIGlkID0gb3B0aW9ucy5kYXRhLklkO1xyXG4gICAgICAgICAgICBpZiAoaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS5nZXRCeUlkKGlkKS50aGVuKG9wdGlvbnMuc3VjY2Vzcywgb3B0aW9ucy5lcnJvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb2xsZWN0aW9uLndpdGhIZWFkZXJzKHRoaXMuaGVhZGVycykuZ2V0KGV2ZXJsaXZlUXVlcnkpLnRoZW4ob3B0aW9ucy5zdWNjZXNzLCBvcHRpb25zLmVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGlzTXVsdGlwbGUgPSBfLmlzQXJyYXkob3B0aW9ucy5kYXRhLm1vZGVscyk7XHJcbiAgICAgICAgICAgIGlmIChpc011bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoIHVwZGF0ZSBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1Gb3JVcGRhdGUgPSBvcHRpb25zLmRhdGE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29sbGVjdGlvbi53aXRoSGVhZGVycyh0aGlzLmhlYWRlcnMpLnVwZGF0ZVNpbmdsZShpdGVtRm9yVXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKG9wdGlvbnMuc3VjY2Vzcy5iaW5kKHRoaXMsIGl0ZW1Gb3JVcGRhdGUpLCBvcHRpb25zLmVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGlzTXVsdGlwbGUgPSBfLmlzQXJyYXkob3B0aW9ucy5kYXRhLm1vZGVscyk7XHJcbiAgICAgICAgICAgIHZhciBjcmVhdGVEYXRhID0gaXNNdWx0aXBsZSA/IG9wdGlvbnMuZGF0YS5tb2RlbHMgOiBvcHRpb25zLmRhdGE7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29sbGVjdGlvbi53aXRoSGVhZGVycyh0aGlzLmhlYWRlcnMpLmNyZWF0ZShjcmVhdGVEYXRhKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4ob3B0aW9ucy5zdWNjZXNzLmJpbmQodGhpcywgY3JlYXRlRGF0YSksIG9wdGlvbnMuZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBpc011bHRpcGxlID0gXy5pc0FycmF5KG9wdGlvbnMuZGF0YS5tb2RlbHMpO1xyXG4gICAgICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXRjaCBkZXN0cm95IGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS5kZXN0cm95KG9wdGlvbnMuZGF0YSlcclxuICAgICAgICAgICAgICAgIC50aGVuKG9wdGlvbnMuc3VjY2Vzcywgb3B0aW9ucy5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgJC5leHRlbmQodHJ1ZSwga2VuZG8uZGF0YSwge1xyXG4gICAgICAgIHRyYW5zcG9ydHM6IHtcclxuICAgICAgICAgICAgZXZlcmxpdmU6IGV2ZXJsaXZlVHJhbnNwb3J0XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2hlbWFzOiB7XHJcbiAgICAgICAgICAgIGV2ZXJsaXZlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogJ2NvdW50JyxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucmVzdWx0IHx8IGRhdGE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbW9kZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzLmlkRmllbGRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZUtlbmRvUXVlcnkoZGF0YSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5za2lwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuJHNraXAgPSBkYXRhLnNraXA7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5za2lwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnRha2UpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC4kdGFrZSA9IGRhdGEudGFrZTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLnRha2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEuc29ydCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvcnRFeHByZXNzaW9ucyA9IGRhdGEuc29ydDtcclxuICAgICAgICAgICAgICAgIHZhciBzb3J0ID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNBcnJheShzb3J0RXhwcmVzc2lvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydEV4cHJlc3Npb25zID0gW3NvcnRFeHByZXNzaW9uc107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAkLmVhY2goc29ydEV4cHJlc3Npb25zLCBmdW5jdGlvbiAoaWR4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvcnRbdmFsdWUuZmllbGRdID0gdmFsdWUuZGlyID09PSAnYXNjJyA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LiRzb3J0ID0gc29ydDtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLnNvcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gZmlsdGVyQnVpbGRlci5idWlsZChkYXRhLmZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuJHdoZXJlID0gZmlsdGVyO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEuZmlsdGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlZ2V4T3BlcmF0aW9ucyA9IFsnc3RhcnRzd2l0aCcsICdzdGFydHNXaXRoJywgJ2VuZHN3aXRoJywgJ2VuZHNXaXRoJywgJ2NvbnRhaW5zJ107XHJcblxyXG4gICAgdmFyIGZpbHRlckJ1aWxkZXIgPSB7XHJcbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckJ1aWxkZXIuX2J1aWxkKGZpbHRlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYnVpbGQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGZpbHRlckJ1aWxkZXIuX2lzUmF3KGZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9yYXcoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJCdWlsZGVyLl9pc1NpbXBsZShmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fc2ltcGxlKGZpbHRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyQnVpbGRlci5faXNSZWdleChmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fcmVnZXgoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJCdWlsZGVyLl9pc0FuZChmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fYW5kKGZpbHRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyQnVpbGRlci5faXNPcihmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fb3IoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzUmF3OiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIub3BlcmF0b3IgPT09ICdfcmF3JztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yYXc6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkVGVybSA9IHt9O1xyXG4gICAgICAgICAgICBmaWVsZFRlcm1bZmlsdGVyLmZpZWxkXSA9IGZpbHRlci52YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc1NpbXBsZTogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZpbHRlci5sb2dpYyA9PT0gJ3VuZGVmaW5lZCcgJiYgIWZpbHRlckJ1aWxkZXIuX2lzUmVnZXgoZmlsdGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zaW1wbGU6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHRlcm0gPSB7fSwgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IGZpbHRlckJ1aWxkZXIuX3RyYW5zbGF0ZW9wZXJhdG9yKGZpbHRlci5vcGVyYXRvcik7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdGVybVtvcGVyYXRvcl0gPSBmaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtID0gZmlsdGVyLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtmaWx0ZXIuZmllbGRdID0gdGVybTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc1JlZ2V4OiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkLmluQXJyYXkoZmlsdGVyLm9wZXJhdG9yLCByZWdleE9wZXJhdGlvbnMpICE9PSAtMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZWdleDogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIHZhciByZWdleCA9IGZpbHRlckJ1aWxkZXIuX2dldFJlZ2V4KGZpbHRlcik7XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtmaWx0ZXIuZmllbGRdID0gZmlsdGVyQnVpbGRlci5fZ2V0UmVnZXhWYWx1ZShyZWdleCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFRlcm07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0UmVnZXg6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBmaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJPcGVyYXRvciA9IGZpbHRlci5vcGVyYXRvcjtcclxuICAgICAgICAgICAgc3dpdGNoIChmaWx0ZXJPcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY29udGFpbnMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiLipcIiArIHBhdHRlcm4gKyBcIi4qXCIsIFwiaVwiKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0c1dpdGgnOiAvLyByZW1vdmluZyB0aGUgY2FtZWwgY2FzZSBvcGVyYXRvcnMgd2lsbCBiZSBhIGJyZWFraW5nIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnRzd2l0aCc6IC8vIHRoZSBLZW5kbyBVSSBvcGVyYXRvcnMgYXJlIGluIGxvd2VyIGNhc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIiArIHBhdHRlcm4sIFwiaVwiKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZHNXaXRoJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZHN3aXRoJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuICsgXCIkXCIsIFwiaVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yIHR5cGUuXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFJlZ2V4VmFsdWU6IGZ1bmN0aW9uIChyZWdleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUXVlcnlCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UmVnZXhWYWx1ZS5jYWxsKHRoaXMsIHJlZ2V4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc0FuZDogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyLmxvZ2ljID09PSAnYW5kJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hbmQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIHRlcm0sIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIuZmlsdGVycztcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9wZXJhbmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGVybSA9IGZpbHRlckJ1aWxkZXIuX2J1aWxkKG9wZXJhbmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckJ1aWxkZXIuX2FuZEFwcGVuZChyZXN1bHQsIHRlcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYW5kQXBwZW5kOiBmdW5jdGlvbiAoYW5kT2JqLCBuZXdPYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIFF1ZXJ5QnVpbGRlci5wcm90b3R5cGUuX2FuZEFwcGVuZC5jYWxsKHRoaXMsIGFuZE9iaiwgbmV3T2JqKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc09yOiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIubG9naWMgPT09ICdvcic7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfb3I6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIHRlcm0sIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIuZmlsdGVycztcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9wZXJhbmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGVybSA9IGZpbHRlckJ1aWxkZXIuX2J1aWxkKG9wZXJhbmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRlcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7JG9yOiByZXN1bHR9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3RyYW5zbGF0ZW9wZXJhdG9yOiBmdW5jdGlvbiAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXEnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbmVxJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkbmVcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2d0JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkZ3RcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2x0JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkbHRcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2d0ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJGd0ZVwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbHRlJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkbHRlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvciB0eXBlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBnZXRVcmxHZW5lcmF0b3JGb3JOb2RlID0gZnVuY3Rpb24gKGJhc2VVcmwsIGV4cGFuZEFycmF5KSB7XHJcbiAgICAgICAgdmFyIGV4cGFuZEZpZWxkID0gZ2V0UmVsYXRpb25GaWVsZEZvckV4cGFuZE5vZGUoZXhwYW5kQXJyYXlbZXhwYW5kQXJyYXkubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgIHZhciBwYXRoQXJyYXkgPSBleHBhbmRBcnJheS5zbGljZSgwLCBleHBhbmRBcnJheS5sZW5ndGggLSAxKTtcclxuICAgICAgICB2YXIgcGF0aFVybCA9ICcvX2V4cGFuZCc7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGF0aFVybCArPSAnLycgKyBnZXRSZWxhdGlvbkZpZWxkRm9yRXhwYW5kTm9kZShwYXRoQXJyYXlbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChwYXRoVXJsLCBleHBhbmRGaWVsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBiYXNlVXJsICsgJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5JZCAmJiBleHBhbmRGaWVsZCkgey8vaWYgd2UgYXJlIGV4cGFuZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSBwYXRoVXJsICsgJy8nICsgb3B0aW9ucy5JZCArICcvJyArIGV4cGFuZEZpZWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0ocGF0aFVybCwgZXhwYW5kRmllbGQpKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGdldEhlYWRlcnNGb3JFeHBhbmROb2RlID0gZnVuY3Rpb24gKGV4cGFuZE5vZGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV4cGFuZE5vZGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdmFyIGV4cGFuZE9iamVjdCA9IHt9O1xyXG4gICAgICAgICAgICBleHBhbmRPYmplY3RbZXhwYW5kTm9kZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHtcclxuICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLUV4cGFuZCc6IEpTT04uc3RyaW5naWZ5KGV4cGFuZE9iamVjdCksXHJcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1TaW5nbGUtRmllbGQnOiBleHBhbmROb2RlXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaGVhZGVycztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtRmlsdGVyJzogSlNPTi5zdHJpbmdpZnkoZXhwYW5kTm9kZS5maWx0ZXIpLFxyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtU29ydCc6IEpTT04uc3RyaW5naWZ5KGV4cGFuZE5vZGUuc29ydCksXHJcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1TaW5nbGUtRmllbGQnOiBleHBhbmROb2RlLnNpbmdsZUZpZWxkLFxyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtU2tpcCc6IGV4cGFuZE5vZGUuc2tpcCxcclxuICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLVRha2UnOiBleHBhbmROb2RlLnRha2UsXHJcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1GaWVsZHMnOiBKU09OLnN0cmluZ2lmeShleHBhbmROb2RlLmZpZWxkcylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIGdldFJlbGF0aW9uRmllbGRGb3JFeHBhbmROb2RlID0gZnVuY3Rpb24gKGV4cGFuZE5vZGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV4cGFuZE5vZGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZE5vZGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGV4cGFuZE5vZGUucmVsYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmROb2RlLnJlbGF0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBhICdyZWxhdGlvbicgZm9yIGFuIGV4cGFuZCBub2RlIHdoZW4gdXNpbmcgdGhlIG9iamVjdCBub3RhdGlvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFtIaWVyYXJjaGljYWxEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2hpZXJhcmNoaWNhbGRhdGFzb3VyY2UpIHRoYXQgbWFuYWdlcyBhIGNlcnRhaW4gQmFja2VuZCBTZXJ2aWNlcyBjb250ZW50IHR5cGUgYW5kIGNhbiBleHBhbmQgYSBjaGFpbiBvZiByZWxhdGlvbnMuXHJcbiAgICAgKiBLZW5kbyBVSSBbSGllcmFyY2hpY2FsRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9oaWVyYXJjaGljYWxkYXRhc291cmNlKSBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgS2VuZG8gd2lkZ2V0cyAoc3VjaCBhcyBbVHJlZVZpZXddKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL3dlYi90cmVldmlldy9vdmVydmlldykpIHRvIHJlbmRlciBkYXRhIGZyb20gQmFja2VuZCBTZXJ2aWNlcyBpbiBhIHN0cnVjdHVyZWQgd2F5LlxyXG4gICAgICogVGhlIGNoYWluIG9mIHJlbGF0aW9ucyBpcyBkZWZpbmVkIGJ5IHNwZWNpZnlpbmcgdGhlIGZpZWxkIG5hbWVzIHRoYXQgY29udGFpbiB0aGUgcmVsYXRpb24gb24gZWFjaCBsZXZlbC4gRm9yIGV4YW1wbGUgYSBnZW5lcmljIGhpZXJhcmNoeSBjaGFpbiBpcyBhIGNvbnRlbnQgdHlwZSAnQ29udGluZW50cycgd2l0aCByZWxhdGlvbiB0byAnQ291bnRyaWVzJywgd2hpY2ggaW4gdHVybiBjb250YWlucyBhIHJlbGF0aW9uIHRvICdUb3ducycuXHJcbiAgICAgKiAqaW5jbHVkaW5nIEtlbmRvIHNjcmlwdHMgaXMgcmVxdWlyZWQqLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZGF0YSBzb3VyY2Ugb3B0aW9ucyBmb3IgW0hpZXJhcmNoaWNhbERhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvaGllcmFyY2hpY2FsZGF0YXNvdXJjZSkuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50eXBlTmFtZSBuYW1lIG9mIHRoZSBtYWluIGNvbnRlbnQgdHlwZSBmb3IgdGhlIGRhdGEgc291cmNlLlxyXG4gICAgICogQHBhcmFtIHtFeHBhbmREZWZpbml0aW9uW119IG9wdGlvbnMuZXhwYW5kIGFuIGFycmF5IG9mIGV4cGFuZCBkZWZpbml0aW9ucy4gSXQgZGVmaW5lcyB0aGUgbGV2ZWxzIG9mIGhpZXJhcmNoeSBieSBzcGVjaWZ5aW5nIHRoZSByZWxhdGlvbiBmaWVsZHMuIEFuIGV4cGFuZCBkZWZpbml0aW9uIGNhbiBlaXRoZXIgYmUgdGhlIGZpZWxkIG5hbWUgYXMgYSAqKnN0cmluZyoqLCBvciBhbiAqKm9iamVjdCoqIHRoYXQgYWxsb3dzIGFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBFeHBhbmREZWZpbml0aW9uIC0gVGhlIGZpZWxkIG5hbWUgb2YgdGhlIHJlbGF0aW9uIHRoYXQgd2lsbCBiZSBleHBhbmRlZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBFeHBhbmREZWZpbml0aW9uLnJlbGF0aW9uIC0gKlJlcXVpcmVkKi4gVGhlIGZpZWxkIG5hbWUgb2YgdGhlIHJlbGF0aW9uIHRoYXQgd2lsbCBiZSBleHBhbmRlZC5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBFeHBhbmREZWZpbml0aW9uLmZpbHRlciAtIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbi5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBFeHBhbmREZWZpbml0aW9uLnNvcnQgLSBhbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgc29ydCBleHByZXNzaW9uLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEV4cGFuZERlZmluaXRpb24uc2tpcCAtIGEgbnVtYmVyIHNwZWNpZnlpbmcgdGhlIHNraXAgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXhwYW5kRGVmaW5pdGlvbi50YWtlIC0gYSBudW1iZXIgc3BlY2lmeWluZyB0aGUgdGFrZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBFeHBhbmREZWZpbml0aW9uLmZpZWxkcyAtIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBmaWVsZHMgZXhwcmVzc2lvbi5cclxuICAgICAqIEByZXR1cm5zIHtIaWVyYXJjaGljYWxEYXRhU291cmNlfSBBIG5ldyBpbnN0YW5jZSBvZiBLZW5kbyBVSSBIaWVyYXJjaGljYWxEYXRhU291cmNlLiBTZWUgS2VuZG8gVUkgZG9jdW1lbnRhdGlvbiBmb3IgW0hpZXJhcmNoaWNhbERhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvaGllcmFyY2hpY2FsZGF0YXNvdXJjZSlcclxuICAgICAqIEBleGFtcGxlIGBgYGpzXHJcbiAgICAgKiB2YXIgZWwgPSBuZXcgRXZlcmxpdmUoJ3lvdXItYXBpLWtleS1oZXJlJyk7XHJcbiAgICAgKiB2YXIgY29udGluZW50cyA9IEV2ZXJsaXZlLmNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2Uoe1xyXG4gKiAgIFwidHlwZU5hbWVcIjogXCJDb250aW5lbnRzXCIsXHJcbiAqICAgXCJleHBhbmRcIjogW1wiQ291bnRyaWVzXCIsIFwiVG93bnNcIl1cclxuICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogLi4uXHJcbiAgICAgKiAoXCIjdHJlZXZpZXdcIikua2VuZG9UcmVlVmlldyh7XHJcbiAqICAgZGF0YVNvdXJjZTogY29udGluZW50cyxcclxuICogICBkYXRhVGV4dEZpZWxkOiBbXCJDb250aW5lbnROYW1lXCIsIFwiQ291bnRyeU5hbWVcIiwgXCJUb3duTmFtZVwiXVxyXG4gKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB2YXIgY3JlYXRlSGllcmFyY2hpY2FsRGF0YVNvdXJjZSA9IGZ1bmN0aW9uIGNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2Uob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBleHBhbmQgPSBvcHRpb25zLmV4cGFuZDtcclxuICAgICAgICB2YXIgdHlwZU5hbWUgPSBvcHRpb25zLnR5cGVOYW1lO1xyXG4gICAgICAgIHZhciBldmVybGl2ZSQgPSBvcHRpb25zLmRhdGFQcm92aWRlciB8fCBFdmVybGl2ZS4kO1xyXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmV4cGFuZDtcclxuICAgICAgICBkZWxldGUgb3B0aW9ucy50eXBlTmFtZTtcclxuICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhUHJvdmlkZXI7XHJcbiAgICAgICAgdmFyIGJhc2VVcmw7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnVybCkge1xyXG4gICAgICAgICAgICBiYXNlVXJsID0gb3B0aW9ucy51cmw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChldmVybGl2ZSQgJiYgdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgYmFzZVVybCA9IFJlcXVlc3QucHJvdG90eXBlLmJ1aWxkVXJsKGV2ZXJsaXZlJC5zZXR1cCkgKyB0eXBlTmFtZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWV2ZXJsaXZlJCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gaW5zdGFudGlhdGUgYW4gRXZlcmxpdmUgaW5zdGFuY2UgaW4gb3JkZXIgdG8gY3JlYXRlIGEga2VuZG8gSGllcmFyY2hpY2FsRGF0YVNvdXJjZS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0eXBlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBhICd0eXBlTmFtZScgaW4gb3JkZXIgdG8gY3JlYXRlIGEga2VuZG8gSGllcmFyY2hpY2FsRGF0YVNvdXJjZS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBleHBhbmRTY2hlbWE7XHJcbiAgICAgICAgaWYgKGV4cGFuZCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZXhwYW5kLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRTY2hlbWEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW46IGdldFJlbGF0aW9uRmllbGRGb3JFeHBhbmROb2RlKGV4cGFuZFtpXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZXJsaXZlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3ZpZGVyOiBldmVybGl2ZSQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVyc0ZvckV4cGFuZE5vZGUoZXhwYW5kW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZXhwYW5kU2NoZW1hXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRhdGFTb3VyY2VPcHRpb25zID0ge307XHJcbiAgICAgICAgZGF0YVNvdXJjZU9wdGlvbnMudHlwZSA9ICdldmVybGl2ZSc7XHJcbiAgICAgICAgZGF0YVNvdXJjZU9wdGlvbnMudHJhbnNwb3J0ID0ge1xyXG4gICAgICAgICAgICB0eXBlTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgIGRhdGFQcm92aWRlcjogZXZlcmxpdmUkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBkYXRhU291cmNlT3B0aW9ucy5zY2hlbWEgPSBleHBhbmRTY2hlbWE7XHJcbiAgICAgICAgZXh0ZW5kKHRydWUsIGRhdGFTb3VyY2VPcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gbmV3IGtlbmRvLmRhdGEuSGllcmFyY2hpY2FsRGF0YVNvdXJjZShkYXRhU291cmNlT3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBLZW5kbyBVSSBbRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9kYXRhc291cmNlKSB0aGF0IG1hbmFnZXMgYSBjZXJ0YWluIEJhY2tlbmQgU2VydmljZXMgY29udGVudCB0eXBlLlxyXG4gICAgICogS2VuZG8gVUkgW0RhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvZGF0YXNvdXJjZSkgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEtlbmRvIFVJIHdpZGdldHMgKHN1Y2ggYXMgW0xpc3RWaWV3XShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS93ZWIvbGlzdHZpZXcvb3ZlcnZpZXcpIGFuZCBbR3JpZF0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvd2ViL2dyaWQvb3ZlcnZpZXcpKSB0byBwcm92aWRlIGFuIGVhc3kgd2F5IHRvIHJlbmRlciBkYXRhIGZyb20gQmFja2VuZCBTZXJ2aWNlcy5cclxuICAgICAqICppbmNsdWRpbmcgS2VuZG8gc2NyaXB0cyBpcyByZXF1aXJlZCouXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBkYXRhIHNvdXJjZSBvcHRpb25zLiBTZWUgS2VuZG8gVUkgZG9jdW1lbnRhdGlvbiBvZiBbRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9kYXRhc291cmNlKSBmb3IgbW9yZSBpbmZvLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNwb3J0LnR5cGVOYW1lIHRoZSBjb250ZW50IHR5cGUgbmFtZSBpbiBCYWNrZW5kIFNlcnZpY2VzIHRoYXQgd2lsbCBiZSBtYW5hZ2VkLlxyXG4gICAgICogQHJldHVybnMge0RhdGFTb3VyY2V9IEEgbmV3IGluc3RhbmNlIG9mIEtlbmRvIFVJIERhdGFTb3VyY2UuIFNlZSBLZW5kbyBVSSBkb2N1bWVudGF0aW9uIG9mIFtEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2RhdGFzb3VyY2UpIGZvciBtb3JlIGluZm8uXHJcbiAgICAgKiBAZXhhbXBsZSBgYGBqc1xyXG4gICAgICogdmFyIGJvb2tzRGF0YVNvdXJjZSA9IEV2ZXJsaXZlLmNyZWF0ZURhdGFTb3VyY2Uoe1xyXG4gKiAgIHRyYW5zcG9ydDoge1xyXG4gKiAgICAgdHlwZU5hbWU6ICdCb29rcydcclxuICogICB9XHJcbiAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHZhciBjcmVhdGVEYXRhU291cmNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB2YXIgdHlwZU5hbWUgPSBvcHRpb25zLnR5cGVOYW1lO1xyXG4gICAgICAgIHZhciBldmVybGl2ZSQgPSBvcHRpb25zLmRhdGFQcm92aWRlciB8fCBFdmVybGl2ZS4kO1xyXG4gICAgICAgIGlmICghZXZlcmxpdmUkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIGluc3RhbnRpYXRlIGFuIEV2ZXJsaXZlIGluc3RhbmNlIGluIG9yZGVyIHRvIGNyZWF0ZSBhIGtlbmRvIERhdGFTb3VyY2UuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHNwZWNpZnkgYSAndHlwZU5hbWUnIGluIG9yZGVyIHRvIGNyZWF0ZSBhIGtlbmRvIERhdGFTb3VyY2UuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgb3B0aW9ucy50eXBlTmFtZTtcclxuICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhUHJvdmlkZXI7XHJcblxyXG4gICAgICAgIHZhciBkYXRhU291cmNlT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGRhdGFTb3VyY2VPcHRpb25zLnR5cGUgPSAnZXZlcmxpdmUnO1xyXG4gICAgICAgIGRhdGFTb3VyY2VPcHRpb25zLnRyYW5zcG9ydCA9IHtcclxuICAgICAgICAgICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxyXG4gICAgICAgICAgICBkYXRhUHJvdmlkZXI6IGV2ZXJsaXZlJFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZXh0ZW5kKHRydWUsIGRhdGFTb3VyY2VPcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gbmV3IGtlbmRvLmRhdGEuRGF0YVNvdXJjZShkYXRhU291cmNlT3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgICAgIGNyZWF0ZURhdGFTb3VyY2U6IGNyZWF0ZURhdGFTb3VyY2UsXHJcbiAgICAgICAgY3JlYXRlSGllcmFyY2hpY2FsRGF0YVNvdXJjZTogY3JlYXRlSGllcmFyY2hpY2FsRGF0YVNvdXJjZVxyXG4gICAgfTtcclxufSgpKTsiLCJ2YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XHJcbnZhciBldmVybGl2ZUVycm9yTW9kdWxlID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IGV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcjtcclxudmFyIEV2ZXJsaXZlRXJyb3JzID0gZXZlcmxpdmVFcnJvck1vZHVsZS5FdmVybGl2ZUVycm9ycztcclxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xyXG52YXIgb2ZmbGluZUl0ZW1TdGF0ZXMgPSBjb25zdGFudHMub2ZmbGluZUl0ZW1TdGF0ZXM7XHJcbnZhciBIZWFkZXJzID0gY29uc3RhbnRzLkhlYWRlcnM7XHJcbnZhciBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIgPSByZXF1aXJlKCcuLi9xdWVyeS9SZXF1ZXN0T3B0aW9uc0J1aWxkZXInKTtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgbWluZ28gPSBjb21tb24uTWluZ287XHJcbnZhciBtb25nb1F1ZXJ5ID0gY29tbW9uLm1vbmdvUXVlcnk7XHJcbnZhciB1dWlkID0gY29tbW9uLnV1aWQ7XHJcbnZhciBfID0gY29tbW9uLl87XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcbnZhciBidWlsZFByb21pc2UgPSB1dGlscy5idWlsZFByb21pc2U7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgZXhwYW5kUHJvY2Vzc29yID0gcmVxdWlyZSgnLi4vRXhwYW5kUHJvY2Vzc29yJyk7XHJcbnZhciBvZmZsaW5lVHJhbnNmb3JtYXRpb25zID0gcmVxdWlyZSgnLi9vZmZsaW5lVHJhbnNmb3JtYXRpb25zJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIE9mZmxpbmVNb2R1bGVcclxuICogQGNsYXNzRGVzYyBBIGNsYXNzIHByb3ZpZGluZyBhY2Nlc3MgdG8gc29tZSBvZmZsaW5lIHN0b3JhZ2UgZnVuY3Rpb25hbGl0aWVzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSB7QGxpbmsgT2ZmbGluZU1vZHVsZX0gY2xhc3MuXHJcbiAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICogQG1lbWJlciB7T2ZmbGluZU1vZHVsZX0gc3RvcmFnZVxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9mZmxpbmVNb2R1bGUoZXZlcmxpdmUsIG9wdGlvbnMsIHBlcnNpc3Rlcikge1xyXG4gICAgICAgIHRoaXMuZXZlcmxpdmUgPSBldmVybGl2ZTtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLmxvY2FsID0gcGVyc2lzdGVyO1xyXG4gICAgICAgIHRoaXMuX2lzU3luY2hyb25pemluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb25DYWNoZSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBnZXRTeW5jRmlsdGVyRm9ySXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSWQ6IGl0ZW0uSWQsXHJcbiAgICAgICAgICAgIE1vZGlmaWVkQXQ6IGl0ZW0uTW9kaWZpZWRBdFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRVc2Vyc0Vycm9yTWVzc2FnZShkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgb3BlcmF0aW9uID0gZGF0YVF1ZXJ5Lm9wZXJhdGlvbjtcclxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5XaXRoUHJvdmlkZXIgfHxcclxuICAgICAgICAgICAgb3BlcmF0aW9uID09PSBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTGlua1dpdGhQcm92aWRlciB8fFxyXG4gICAgICAgICAgICBvcGVyYXRpb24gPT09IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJVbmxpbmtGcm9tUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uICs9IGRhdGFRdWVyeS5kYXRhLlByb3ZpZGVyIHx8IGRhdGFRdWVyeS5kYXRhLklkZW50aXR5LlByb3ZpZGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICdUaGUgVXNlcnMgb3BlcmF0aW9uICcgKyBvcGVyYXRpb24gKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gb2ZmbGluZSBtb2RlJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnMgPSB7fTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZV0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZVNpbmdsZV0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmF3VXBkYXRlXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy5zZXRBY2xdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnNldE93bmVyXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5XaXRoUHJvdmlkZXJdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMaW5rV2l0aFByb3ZpZGVyXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyVW5saW5rRnJvbVByb3ZpZGVyXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5dID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dvdXRdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJDaGFuZ2VQYXNzd29yZF0gPSB0cnVlO1xyXG5cclxuICAgIHZhciB1bnN1cHBvcnRlZE9mZmxpbmVIZWFkZXJzID0gW0hlYWRlcnMucG93ZXJGaWVsZHNdO1xyXG5cclxuICAgIE9mZmxpbmVNb2R1bGUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIHByb2Nlc3NRdWVyeTogZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgICAgICB2YXIgdW5zdXBwb3J0ZWRDbGllbnRPcE1lc3NhZ2UgPSB0aGlzLmdldFVuc3VwcG9ydGVkQ2xpZW50T3BNZXNzYWdlKGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIGlmICh1bnN1cHBvcnRlZENsaWVudE9wTWVzc2FnZSAmJiAhZGF0YVF1ZXJ5LmlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcih1bnN1cHBvcnRlZENsaWVudE9wTWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzb3J0ID0gZGF0YVF1ZXJ5LmdldEhlYWRlckFzSlNPTihIZWFkZXJzLnNvcnQpO1xyXG4gICAgICAgICAgICB2YXIgbGltaXQgPSBkYXRhUXVlcnkuZ2V0SGVhZGVyQXNKU09OKEhlYWRlcnMudGFrZSk7XHJcbiAgICAgICAgICAgIHZhciBza2lwID0gZGF0YVF1ZXJ5LmdldEhlYWRlckFzSlNPTihIZWFkZXJzLnNraXApO1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ID0gZGF0YVF1ZXJ5LmdldEhlYWRlckFzSlNPTihIZWFkZXJzLnNlbGVjdCk7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBkYXRhUXVlcnkuZ2V0SGVhZGVyQXNKU09OKEhlYWRlcnMuZmlsdGVyKTtcclxuICAgICAgICAgICAgdmFyIGV4cGFuZCA9IGRhdGFRdWVyeS5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5leHBhbmQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGFRdWVyeS5maWx0ZXIgaW5zdGFuY2VvZiBFdmVybGl2ZS5RdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlck9iaiA9IGRhdGFRdWVyeS5maWx0ZXIuYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlck9iai4kd2hlcmUgfHwgZmlsdGVyO1xyXG4gICAgICAgICAgICAgICAgc29ydCA9IGZpbHRlck9iai4kc29ydCB8fCBzb3J0O1xyXG4gICAgICAgICAgICAgICAgbGltaXQgPSBmaWx0ZXJPYmouJHRha2UgfHwgbGltaXQ7XHJcbiAgICAgICAgICAgICAgICBza2lwID0gZmlsdGVyT2JqLiRza2lwIHx8IHNraXA7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3QgPSBmaWx0ZXJPYmouJHNlbGVjdCB8fCBzZWxlY3Q7XHJcbiAgICAgICAgICAgICAgICBleHBhbmQgPSBmaWx0ZXJPYmouJGV4cGFuZCB8fCBleHBhbmQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBkYXRhUXVlcnkuZmlsdGVyIHx8IGZpbHRlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlciA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5zdXBwb3J0ZWRPcGVyYXRvcnMgPSB1dGlscy5nZXRVbnN1cHBvcnRlZE9wZXJhdG9ycyhmaWx0ZXIpO1xyXG4gICAgICAgICAgICB2YXIgdW5zdXBwb3J0ZWRPcGVyYXRvckNvdW50ID0gdW5zdXBwb3J0ZWRPcGVyYXRvcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAodW5zdXBwb3J0ZWRPcGVyYXRvckNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodW5zdXBwb3J0ZWRPcGVyYXRvckNvdW50ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdUaGUgb3BlcmF0b3IgJyArIHVuc3VwcG9ydGVkT3BlcmF0b3JzWzBdICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZS4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdUaGUgb3BlcmF0b3JzICcgKyB1bnN1cHBvcnRlZE9wZXJhdG9ycy5qb2luKCcsJykgKyAnYXJlIG5vdCBzdXBwb3J0ZWQgaW4gb2ZmbGluZSBtb2RlLic7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcihlcnJvck1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnRyYXZlcnNlQW5kVHJhbnNmb3JtRmlsdGVySWQoZmlsdGVyKTtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0YVF1ZXJ5Lm9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQoZGF0YVF1ZXJ5LCBmaWx0ZXIsIHNvcnQsIHNraXAsIGxpbWl0LCBzZWxlY3QsIGV4cGFuZCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWRCeUlkOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRCeUlkKGRhdGFRdWVyeSwgZXhwYW5kKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY291bnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQoZGF0YVF1ZXJ5LCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJhd1VwZGF0ZTpcclxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShkYXRhUXVlcnksIGZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoZGF0YVF1ZXJ5LCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLl9pZCA9IGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoZGF0YVF1ZXJ5LCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhUXVlcnkuaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEV2ZXJsaXZlRXJyb3IoZGF0YVF1ZXJ5Lm9wZXJhdGlvbiArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFVuc3VwcG9ydGVkQ2xpZW50T3BNZXNzYWdlOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5zdXBwb3J0ZWRPZmZsaW5lSGVhZGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IHVuc3VwcG9ydGVkT2ZmbGluZUhlYWRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVF1ZXJ5LmdldEhlYWRlcihoZWFkZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdUaGUgaGVhZGVyICcgKyBoZWFkZXIgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gb2ZmbGluZSBtb2RlJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZmlsZXMnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ09wZXJhdGlvbnMgb24gZmlsZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gb2ZmbGluZSBtb2RlJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndXNlcnMnICYmIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW2RhdGFRdWVyeS5vcGVyYXRpb25dKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRVc2Vyc0Vycm9yTWVzc2FnZShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldENyZWF0ZVJlc3VsdDogZnVuY3Rpb24gKGNyZWF0ZWRJdGVtcykge1xyXG4gICAgICAgICAgICBpZiAoY3JlYXRlZEl0ZW1zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3JlYXRlZEF0OiB1dGlscy5jbG9uZURhdGUoY3JlYXRlZEl0ZW1zWzBdLkNyZWF0ZWRBdCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIElkOiBjcmVhdGVkSXRlbXNbMF0uX2lkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG11bHRpcGxlQ3JlYXRlUmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goY3JlYXRlZEl0ZW1zLCBmdW5jdGlvbiAoY3JlYXRlZEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZUNyZWF0ZVJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3JlYXRlZEF0OiB1dGlscy5jbG9uZURhdGUoY3JlYXRlZEl0ZW0uQ3JlYXRlZEF0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgSWQ6IGNyZWF0ZWRJdGVtLl9pZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IG11bHRpcGxlQ3JlYXRlUmVzdWx0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgdGhlIGl0ZW1zIG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSBkYXRhUXVlcnlcclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fY3JlYXRlSXRlbXMoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lLCBkYXRhUXVlcnkuZGF0YSwgZGF0YVF1ZXJ5LmlzU3luYywgZnVuY3Rpb24gKGNyZWF0ZWRJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjcmVhdGVSZXN1bHQgPSBzZWxmLl9nZXRDcmVhdGVSZXN1bHQoY3JlYXRlZEl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNyZWF0ZVJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgaXRlbXMgZnJvbSBhIGNvbnRlbnQgdHlwZSwgYmFzZWQgb24gYSBmaWx0ZXJcclxuICAgICAgICAgKiBAcGFyYW0gZGF0YVF1ZXJ5IHtPYmplY3R9IC0gdGhlIGRhdGEgcXVlcnkgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIGZpbHRlclxyXG4gICAgICAgICAqIEBwYXJhbSBzb3J0XHJcbiAgICAgICAgICogQHBhcmFtIHNraXBcclxuICAgICAgICAgKiBAcGFyYW0gbGltaXRcclxuICAgICAgICAgKiBAcGFyYW0gc2VsZWN0XHJcbiAgICAgICAgICogQHBhcmFtIGV4cGFuZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtSU1ZQLlByb21pc2V9IC0gZmlsdGVyZWQgcmVzdWx0c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGZpbHRlciwgc29ydCwgc2tpcCwgbGltaXQsIHNlbGVjdCwgZXhwYW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uTGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuX3ByZXBhcmVFeHBhbmQoZXhwYW5kLCBkYXRhUXVlcnksIHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHByZXBhcmVFeHBhbmRSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXBhcmVFeHBhbmRSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdCA9IHByZXBhcmVFeHBhbmRSZXN1bHQubWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldENvbGxlY3Rpb24oZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VsZi5fcmVhZEludGVybmFsKGNvbGxlY3Rpb24sIGZpbHRlciwgc29ydCwgc2tpcCwgbGltaXQsIHNlbGVjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2lwIHx8IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbGwgPSBzZWxmLl9yZWFkSW50ZXJuYWwoY29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25MZW5ndGggPSBhbGwubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9leHBhbmRSZXN1bHQocHJlcGFyZUV4cGFuZFJlc3VsdCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBzZWxmLl90cmFuc2Zvcm1PZmZsaW5lUmVzdWx0KHJlc3VsdCwgY29sbGVjdGlvbkxlbmd0aCwgZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JlYWRJbnRlcm5hbDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGZpbHRlciwgc29ydCwgc2tpcCwgbGltaXQsIHNlbGVjdCkge1xyXG4gICAgICAgICAgICBmaWx0ZXIgPSBfLmV4dGVuZCh7fSwgZmlsdGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2V0V2l0aG91dERlbGV0ZWRGaWx0ZXIoZmlsdGVyKTtcclxuICAgICAgICAgICAgb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy50cmF2ZXJzZUFuZFRyYW5zZm9ybUZpbHRlcklkKGZpbHRlcik7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG1pbmdvLlF1ZXJ5KGZpbHRlcik7XHJcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSBtaW5nby5DdXJzb3IoY29sbGVjdGlvbiwgcXVlcnksIHNlbGVjdCk7XHJcbiAgICAgICAgICAgIGlmIChzb3J0KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3Iuc29ydChzb3J0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNraXApIHtcclxuICAgICAgICAgICAgICAgIGN1cnNvci5za2lwKHNraXApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGltaXQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnNvci5saW1pdChsaW1pdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfLm1hcChjdXJzb3IuYWxsKCksIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5leHRlbmQoe30sIGl0ZW0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZWFkQnlJZDogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZXhwYW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9wcmVwYXJlRXhwYW5kKGV4cGFuZCwgZGF0YVF1ZXJ5LCBmYWxzZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChwcmVwYXJlRXhwYW5kUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldENvbGxlY3Rpb24oZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc2VsZi5fZ2V0QnlJZChjb2xsZWN0aW9uLCBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChFdmVybGl2ZUVycm9ycy5pdGVtTm90Rm91bmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuaWRUcmFuc2Zvcm0oaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2V4cGFuZFJlc3VsdChwcmVwYXJlRXhwYW5kUmVzdWx0LCBpdGVtKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHNlbGYuX3RyYW5zZm9ybU9mZmxpbmVSZXN1bHQocmVzdWx0LCBudWxsLCBkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9wcmVwYXJlRXhwYW5kOiBmdW5jdGlvbiAoZXhwYW5kLCBkYXRhUXVlcnksIGlzQXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZFByb2Nlc3Nvci5wcmVwYXJlKGV4cGFuZCwgZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lLCBpc0FycmF5LCBkYXRhUXVlcnkuZmllbGRzLCBudWxsLCBudWxsLCBmdW5jdGlvbiAoZXJyLCBwcmVwYXJlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHByZXBhcmVSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9leHBhbmRSZXN1bHQ6IGZ1bmN0aW9uIChwcmVwYXJlRXhwYW5kUmVzdWx0LCByZXN1bHQpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJlcGFyZUV4cGFuZFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZFByb2Nlc3Nvci5leHBhbmQocHJlcGFyZUV4cGFuZFJlc3VsdC5yZWxhdGlvbnNUcmVlLCByZXN1bHQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmbGluZU1vZHVsZTogc2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldFdpdGhvdXREZWxldGVkRmlsdGVyOiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlciB8fCB7fTtcclxuICAgICAgICAgICAgZmlsdGVyW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPSB7JyRuZSc6IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWR9O1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSBpdGVtcyBvZiBhIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSBkYXRhUXVlcnkge0RhdGFRdWVyeX0gLSB0aGUgZGF0YSBxdWVyeVxyXG4gICAgICAgICAqIEBwYXJhbSBbZmlsdGVyXSB7T2JqZWN0fS0gVGhlIGZpbHRlciB0byBhcHBseSB3aGVuIHVwZGF0aW5nXHJcbiAgICAgICAgICogQHBhcmFtIGlzU3luY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUl0ZW1zKGRhdGFRdWVyeSwgZGF0YVF1ZXJ5LmRhdGEsIGZpbHRlciwgZGF0YVF1ZXJ5LmlzU3luYywgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlIGl0ZW1zIGZyb20gYSBjb250ZW50IHR5cGUsIGJhc2VkIG9uIGEgZmlsdGVyXHJcbiAgICAgICAgICogQHBhcmFtIGRhdGFRdWVyeSB7RGF0YVF1ZXJ5fSAtIHRoZSBkYXRhIHF1ZXJ5XHJcbiAgICAgICAgICogQHBhcmFtIFtmaWx0ZXJdIHtPYmplY3R9IC0gRmlsdGVyIHRvIGFwcGx5IHdoZW4gcmVtb3ZpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZUl0ZW1zKGRhdGFRdWVyeSwgZmlsdGVyLCBkYXRhUXVlcnkuaXNTeW5jLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjb3VudDogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2dldENvbGxlY3Rpb24oZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJSZXN1bHQgPSBzZWxmLl9yZWFkSW50ZXJuYWwoY29sbGVjdGlvbiwgZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7cmVzdWx0OiBmaWx0ZXJSZXN1bHQubGVuZ3RofSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ29PbmxpbmU6IGZ1bmN0aW9uIChhdXRvU3luYykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Mub2ZmbGluZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGF1dG9TeW5jID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGF1dG9TeW5jID0gdGhpcy5zZXR0aW5ncy5hdXRvU3luYztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGF1dG9TeW5jKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdvT2ZmbGluZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLm9mZmxpbmUgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzT25saW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5zZXR0aW5ncy5vZmZsaW5lO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsZWFyQWxsOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbkNhY2hlID0ge307XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWwuY2xlYXJBbGwoc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9wcmVwYXJlU3luY0RhdGE6IGZ1bmN0aW9uIChjb250ZW50VHlwZXNGb3JTeW5jKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZXNTeW5jRGF0YSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgY29uZmxpY3RzID0gW107XHJcbiAgICAgICAgICAgIF8ubWFwKGNvbnRlbnRUeXBlc0ZvclN5bmMsIGZ1bmN0aW9uIChjb250ZW50VHlwZSwgdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzeW5jSXRlbXMgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLmlkVHJhbnNmb3JtKGNvbnRlbnRUeXBlLm9mZmxpbmVJdGVtc1RvU3luYyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3luY0RhdGEgPSBzZWxmLl9nZXRTeW5jSXRlbVN0YXRlcyh0eXBlTmFtZSwgc3luY0l0ZW1zLCBjb250ZW50VHlwZS5zZXJ2ZXJJdGVtcyk7XHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHMucHVzaChzeW5jRGF0YS5jb25mbGljdHMpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVzU3luY0RhdGFbdHlwZU5hbWVdID0gc3luY0RhdGEuaXRlbXNGb3JTeW5jO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHM6IGNvbmZsaWN0cyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlc1N5bmNEYXRhOiBjb250ZW50VHlwZXNTeW5jRGF0YVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9yZXNvbHZlQ29uZmxpY3RzOiBmdW5jdGlvbiAoc3luY0RhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlSZXNvbHV0aW9uU3RyYXRlZ3koc3luY0RhdGEuY29uZmxpY3RzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oc2VsZi5fbWVyZ2VSZXNvbHZlZENvbmZsaWN0cy5iaW5kKHNlbGYsIHN5bmNEYXRhLmNvbmZsaWN0cywgc3luY0RhdGEuY29udGVudFR5cGVzU3luY0RhdGEpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW5jRGF0YS5jb250ZW50VHlwZXNTeW5jRGF0YTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzU3luY2hyb25pemluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNTeW5jaHJvbml6aW5nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9maXJlU3luY1N0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5faXNTeW5jaHJvbml6aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faXNTeW5jaHJvbml6aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHRpbmdzLnN5bmNTdGFydChmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3luY09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmV4dGVuZChzeW5jT3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzeW5jT3B0aW9ucy5jYW5jZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2lzU3luY2hyb25pemluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KEV2ZXJsaXZlRXJyb3JzLnN5bmNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2ZpcmVTeW5jRW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzU3luY2hyb25pemluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnN5bmNFbmQuYXBwbHkodGhpcy5ldmVybGl2ZSwgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYWRkVXBkYXRlZEl0ZW1zRm9yU3luYzogZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBfLmVhY2goY29udGVudFR5cGVEYXRhLm1vZGlmaWVkSXRlbXMsIGZ1bmN0aW9uIChtb2RpZmllZEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZEl0ZW1GaWx0ZXIgPSBnZXRTeW5jRmlsdGVyRm9ySXRlbShtb2RpZmllZEl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgc3luY1Byb21pc2VzW21vZGlmaWVkSXRlbS5JZF0gPVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFDb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGUobW9kaWZpZWRJdGVtLCBtb2RpZmllZEl0ZW1GaWx0ZXIsIHtpc1N5bmM6IHRydWUsIGFwcGx5T2ZmbGluZTogZmFsc2V9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb25TeW5jUmVzcG9uc2UocmVzLCBtb2RpZmllZEl0ZW0sIGRhdGFDb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfb25TeW5jUmVzcG9uc2U6IGZ1bmN0aW9uIChyZXMsIGl0ZW0sIGNvbGxlY3Rpb25OYW1lLCBvcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHJlcy5yZXN1bHQgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoRXZlcmxpdmVFcnJvcnMuc3luY0NvbmZsaWN0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaXRlbSxcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsRGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5JZFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3luYzogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1F1ZXJ5KHVwZGF0ZVF1ZXJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hZGREZWxldGVkSXRlbXNGb3JTeW5jOiBmdW5jdGlvbiAoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaChjb250ZW50VHlwZURhdGEuZGVsZXRlZEl0ZW1zLCBmdW5jdGlvbiAoZGVsZXRlZEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWxldGVkSXRlbUZpbHRlciA9IGdldFN5bmNGaWx0ZXJGb3JJdGVtKGRlbGV0ZWRJdGVtKTtcclxuICAgICAgICAgICAgICAgIHN5bmNQcm9taXNlc1tkZWxldGVkSXRlbS5JZF0gPVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFDb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZXN0cm95KGRlbGV0ZWRJdGVtRmlsdGVyLCB7aXNTeW5jOiB0cnVlLCBhcHBseU9mZmxpbmU6IGZhbHNlfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29uU3luY1Jlc3BvbnNlKHJlcywgZGVsZXRlZEl0ZW0sIGRhdGFDb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3luYzogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZmlyZVN5bmNTdGFydCgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyAvLyBvbWl0IGFueSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNsaWVudCBzeW5jU3RhcnQgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3N5bmNHZXRTZXJ2ZXJJdGVtcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oc2VsZi5fcHJlcGFyZVN5bmNEYXRhLmJpbmQoc2VsZikpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oc2VsZi5fcmVzb2x2ZUNvbmZsaWN0cy5iaW5kKHNlbGYpKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50VHlwZVN5bmNEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW5jUHJvbWlzZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy5tYXAoY29udGVudFR5cGVTeW5jRGF0YSwgZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhQ29sbGVjdGlvbiA9IHNlbGYuZXZlcmxpdmUuZGF0YSh0eXBlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVEYXRhLmNyZWF0ZWRJdGVtcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jUHJvbWlzZXNbJ2NyZWF0ZSddID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUNvbGxlY3Rpb24uY3JlYXRlKGNvbnRlbnRUeXBlRGF0YS5jcmVhdGVkSXRlbXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3luYzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5T2ZmbGluZTogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya09mZmxpbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY29udGVudFR5cGVEYXRhLmNyZWF0ZWRJdGVtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTeW5jOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGF0YS5tb2RpZmllZEl0ZW1zLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZFVwZGF0ZWRJdGVtc0ZvclN5bmMoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVEYXRhLmRlbGV0ZWRJdGVtcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGREZWxldGVkSXRlbXNGb3JTeW5jKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJzdnAuaGFzaFNldHRsZWQoc3luY1Byb21pc2VzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzeW5jUmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbGVkU3luY1JlcXVlc3RzID0gXy5maWx0ZXIoc3luY1Jlc3VsdHMsIGZ1bmN0aW9uIChzeW5jUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3luY1Jlc3VsdCAmJiBzeW5jUmVzdWx0LnN0YXRlID09PSAncmVqZWN0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZhaWxlZFN5bmNSZXF1ZXN0cy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnN5bmMoc3VjY2Vzc0NiLCBlcnJvckNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpcmVTeW5jRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzc0NiKHN5bmNSZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZmlyZVN5bmNFbmQoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2hhbmRsZUtlZXBTZXJ2ZXI6IGZ1bmN0aW9uICh0eXBlTmFtZSwgY29uZmxpY3RpbmdJdGVtLCBvZmZsaW5lU3luY09wZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIHNlcnZlckl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uc2VydmVySXRlbTtcclxuICAgICAgICAgICAgdmFyIGNsaWVudEl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uY2xpZW50SXRlbTtcclxuICAgICAgICAgICAgdmFyIHN5bmNRdWVyeTtcclxuICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0gJiYgY2xpZW50SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBpdGVtIG9mZmxpbmVcclxuICAgICAgICAgICAgICAgIHN5bmNRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB0eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogc2VydmVySXRlbS5JZFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VydmVySXRlbVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VydmVySXRlbSAmJiAhY2xpZW50SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGl0ZW0gb2ZmbGluZVxyXG4gICAgICAgICAgICAgICAgc3luY1F1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNlcnZlckl0ZW1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzZXJ2ZXJJdGVtICYmIGNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBpdGVtIG9mZmxpbmVcclxuICAgICAgICAgICAgICAgIHN5bmNRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB0eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZVNpbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2xpZW50SXRlbS5JZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0JvdGggc2VydmVySXRlbSBhbmQgY2xpZW50SXRlbSBhcmUgbm90IHNldCB3aGVuIHN5bmNpbmcgZGF0YSB3aXRoIFwiS2VlcFNlcnZlclwiIHJlc29sdXRpb24gc3RyYXRlZ3kuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN5bmNRdWVyeS5pc1N5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICBvZmZsaW5lU3luY09wZXJhdGlvbnMucHVzaCh0aGlzLnByb2Nlc3NRdWVyeShzeW5jUXVlcnkpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfaGFuZGxlS2VlcENsaWVudDogZnVuY3Rpb24gKGNvbmZsaWN0aW5nSXRlbSwgY29udGVudFR5cGVTeW5jRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgc2VydmVySXRlbSA9IGNvbmZsaWN0aW5nSXRlbS5zZXJ2ZXJJdGVtO1xyXG4gICAgICAgICAgICB2YXIgY2xpZW50SXRlbSA9IGNvbmZsaWN0aW5nSXRlbS5jbGllbnRJdGVtO1xyXG4gICAgICAgICAgICBpZiAoc2VydmVySXRlbSAmJiBjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWRPYmplY3QgPSBfLmV4dGVuZChjbGllbnRJdGVtLCB7TW9kaWZpZWRBdDogbmV3IERhdGUoc2VydmVySXRlbS5Nb2RpZmllZEF0KX0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0aW5nSXRlbS5yZXN1bHQuZm9yY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbW9kaWZpZWRPYmplY3QuTW9kaWZpZWRBdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLm1vZGlmaWVkSXRlbXMucHVzaChtb2RpZmllZE9iamVjdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VydmVySXRlbSAmJiAhY2xpZW50SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5kZWxldGVkSXRlbXMucHVzaChzZXJ2ZXJJdGVtKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghc2VydmVySXRlbSAmJiBjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLmNyZWF0ZWRJdGVtcy5wdXNoKGNsaWVudEl0ZW0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0JvdGggc2VydmVySXRlbSBhbmQgY2xpZW50SXRlbSBhcmUgbm90IHNldCB3aGVuIHN5bmNpbmcgZGF0YSB3aXRoIFwiS2VlcENsaWVudFwiIHJlc29sdXRpb24gc3RyYXRlZ3kuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfaGFuZGxlQ3VzdG9tOiBmdW5jdGlvbiAoY29uZmxpY3RpbmdJdGVtLCB0eXBlTmFtZSwgb2ZmbGluZVN5bmNPcGVyYXRpb25zLCBjb250ZW50VHlwZVN5bmNEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJJdGVtID0gY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW07XHJcbiAgICAgICAgICAgIHZhciBjbGllbnRJdGVtID0gY29uZmxpY3RpbmdJdGVtLmNsaWVudEl0ZW07XHJcbiAgICAgICAgICAgIHZhciBjdXN0b21JdGVtID0gY29uZmxpY3RpbmdJdGVtLnJlc3VsdC5pdGVtO1xyXG4gICAgICAgICAgICBpZiAoc2VydmVySXRlbSAmJiBjdXN0b21JdGVtICYmICFjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlSXRlbU9mZmxpbmVRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB0eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdXN0b21JdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBTeW5jQ2hlY2s6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG9mZmxpbmVTeW5jT3BlcmF0aW9ucy5wdXNoKHRoaXMucHJvY2Vzc1F1ZXJ5KGNyZWF0ZUl0ZW1PZmZsaW5lUXVlcnkpKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEubW9kaWZpZWRJdGVtcy5wdXNoKGN1c3RvbUl0ZW0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZlckl0ZW0gJiYgIWN1c3RvbUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuZGVsZXRlZEl0ZW1zLnB1c2goc2VydmVySXRlbSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNlcnZlckl0ZW0gJiYgY3VzdG9tSXRlbSAmJiBjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlSXRlbU9mZmxpbmVRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB0eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdXN0b21JdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjbGllbnRJdGVtLklkXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBza2lwU3luY0NoZWNrOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBvZmZsaW5lU3luY09wZXJhdGlvbnMucHVzaCh0aGlzLnByb2Nlc3NRdWVyeSh1cGRhdGVJdGVtT2ZmbGluZVF1ZXJ5KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5jcmVhdGVkSXRlbXMucHVzaChjdXN0b21JdGVtKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEubW9kaWZpZWRJdGVtcy5wdXNoKGN1c3RvbUl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX21lcmdlUmVzb2x2ZWRDb25mbGljdHM6IGZ1bmN0aW9uIChjb25mbGljdHMsIHN5bmNEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZsaW5lU3luY09wZXJhdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgXy5lYWNoKGNvbmZsaWN0cywgZnVuY3Rpb24gKGNvbmZsaWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSBjb25mbGljdC5jb250ZW50VHlwZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goY29uZmxpY3QuY29uZmxpY3RpbmdJdGVtcywgZnVuY3Rpb24gKGNvbmZsaWN0aW5nSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZVN5bmNEYXRhID0gc3luY0RhdGFbdHlwZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29uZmxpY3RpbmdJdGVtLnJlc3VsdC5yZXNvbHV0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uS2VlcFNlcnZlcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZUtlZXBTZXJ2ZXIodHlwZU5hbWUsIGNvbmZsaWN0aW5nSXRlbSwgb2ZmbGluZVN5bmNPcGVyYXRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uS2VlcENsaWVudDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZUtlZXBDbGllbnQoY29uZmxpY3RpbmdJdGVtLCBjb250ZW50VHlwZVN5bmNEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uQ3VzdG9tOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlQ3VzdG9tKGNvbmZsaWN0aW5nSXRlbSwgdHlwZU5hbWUsIG9mZmxpbmVTeW5jT3BlcmF0aW9ucywgY29udGVudFR5cGVTeW5jRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcnN2cC5hbGwob2ZmbGluZVN5bmNPcGVyYXRpb25zKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0U3luY0l0ZW1TdGF0ZXM6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgb2ZmbGluZUl0ZW1zLCBzZXJ2ZXJJdGVtcykge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGVTeW5jRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGl0ZW1zRm9yU3luYzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRJdGVtczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJdGVtczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEl0ZW1zOiBbXVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvbmZsaWN0czoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlTmFtZTogY29udGVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtczogW11cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaChvZmZsaW5lSXRlbXMsIGZ1bmN0aW9uIChvZmZsaW5lSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlckl0ZW0gPSBfLmZpbmRXaGVyZShzZXJ2ZXJJdGVtcywge0lkOiBvZmZsaW5lSXRlbS5JZH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzVXBkYXRlQ29uZmxpY3QgPSBzZXJ2ZXJJdGVtLk1vZGlmaWVkQXQgJiYgKCFvZmZsaW5lSXRlbS5Nb2RpZmllZEF0IHx8IHNlcnZlckl0ZW0uTW9kaWZpZWRBdC5nZXRUaW1lKCkgIT09IG9mZmxpbmVJdGVtLk1vZGlmaWVkQXQuZ2V0VGltZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVXBkYXRlQ29uZmxpY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5jb25mbGljdHMuY29uZmxpY3RpbmdJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpdGVtIHdhcyBtb2RpZmllZCBvbiB0aGUgc2VydmVyIGFuZCBkZWxldGVkIGxvY2FsbHkgd2UgaGF2ZSBhIGNvbmZsaWN0IGFuZCBzZXQgdGhlIGNsaWVudCBpdGVtIHRvIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpdCBpcyBhIHNpbXBsZSBtb2RpZmljYXRpb24gY29uZmxpY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudEl0ZW06IG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQgPyBudWxsIDogb2ZmbGluZUl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJJdGVtOiBzZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5pdGVtc0ZvclN5bmMuZGVsZXRlZEl0ZW1zLnB1c2gob2ZmbGluZUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5pdGVtc0ZvclN5bmMubW9kaWZpZWRJdGVtcy5wdXNoKG9mZmxpbmVJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaW4gbWVtb3J5IGhhcyBiZWVuIG1vZGlmaWVkLCBidXQgdGhlIGl0ZW0gb24gdGhlIHNlcnZlciBoYXMgYmVlbiBkZWxldGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuY29uZmxpY3RzLmNvbmZsaWN0aW5nSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJdGVtOiBvZmZsaW5lSXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckl0ZW06IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuaXRlbXNGb3JTeW5jLmNyZWF0ZWRJdGVtcy5wdXNoKG9mZmxpbmVJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUeXBlU3luY0RhdGE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3NldFJlc29sdXRpb25UeXBlRm9ySXRlbTogZnVuY3Rpb24gKHJlc29sdXRpb25UeXBlLCBmb3JjZSwgY29uZmxpY3RpbmdJdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbS5yZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uVHlwZTogcmVzb2x1dGlvblR5cGUsXHJcbiAgICAgICAgICAgICAgICBmb3JjZTogZm9yY2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYXBwbHlSZXNvbHV0aW9uU3RyYXRlZ3k6IGZ1bmN0aW9uIChjb25mbGljdHMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kgPSBzZWxmLnNldHRpbmdzLmNvbmZsaWN0UmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25mbGljdFJlc29sdXRpb25TdHJhdGVneShjb25mbGljdHMsIHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmxpY3RLZXlzID0gT2JqZWN0LmtleXMoY29uZmxpY3RzKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZsaWN0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gY29uZmxpY3RLZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmxpY3QgPSBjb25mbGljdHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0LmNvbmZsaWN0aW5nSXRlbXMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuU2VydmVyV2luczpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNvbmZsaWN0LmNvbmZsaWN0aW5nSXRlbXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zZXRSZXNvbHV0aW9uVHlwZUZvckl0ZW0uYmluZChzZWxmLCBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uLktlZXBTZXJ2ZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ2xpZW50V2luczpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNvbmZsaWN0LmNvbmZsaWN0aW5nSXRlbXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zZXRSZXNvbHV0aW9uVHlwZUZvckl0ZW0uYmluZChzZWxmLCBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uLktlZXBDbGllbnQsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcignSW52YWxpZCByZXNvbHV0aW9uIHN0cmF0ZWd5IHByb3ZpZGVkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3N5bmNHZXRTZXJ2ZXJJdGVtczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBbGxDb2xsZWN0aW9ucygpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBfLm1hcChjb2xsZWN0aW9ucywgZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2NvbnRlbnRUeXBlXSA9IG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZmxpbmVJdGVtc1RvU3luYyA9IHNlbGYuX2dldERpcnR5SXRlbXMoY29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3luY0lkcyA9IF8ucGx1Y2sob2ZmbGluZUl0ZW1zVG9TeW5jLCAnX2lkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJZCc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRpbic6IHN5bmNJZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogY29udGVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZmxpbmVJdGVtc1RvU3luYzogb2ZmbGluZUl0ZW1zVG9TeW5jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVySXRlbXM6IHJlcy5yZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiByZWplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRSZXF1ZXN0T3B0aW9uc0Zyb21RdWVyeSA9IFJlcXVlc3RPcHRpb25zQnVpbGRlcltkYXRhUXVlcnkub3BlcmF0aW9uXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IGdldFJlcXVlc3RPcHRpb25zRnJvbVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHNlbGYuZXZlcmxpdmUuc2V0dXAsIHJlcXVlc3RPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJzdnAuaGFzaChwcm9taXNlcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RGlydHlJdGVtczogZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGZpbHRlciA9IHt9O1xyXG4gICAgICAgICAgICBmaWx0ZXJbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9IHskZXhpc3RzOiB0cnVlfTtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbWluZ28uUXVlcnkoZmlsdGVyKTtcclxuICAgICAgICAgICAgdmFyIGN1cnNvciA9IG1pbmdvLkN1cnNvcihjb2xsZWN0aW9uLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IuYWxsKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldEFsbENvbGxlY3Rpb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKHRoaXMubG9jYWwuZ2V0QWxsRGF0YS5iaW5kKHRoaXMubG9jYWwpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0Q29sbGVjdGlvbjogZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBwZXJzaXN0ZXIgaWYgdGhlcmUgaXMgbm8gZGF0YSBpbiB0aGUgY29sbGVjdGlvbiBjYWNoZSBmb3IgdGhpcyBjb250ZW50IHR5cGVcclxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5fY29sbGVjdGlvbkNhY2hlW2NvbnRlbnRUeXBlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9jYWwuZ2V0RGF0YShjb250ZW50VHlwZSwgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY29sbGVjdGlvbkNhY2hlW2NvbnRlbnRUeXBlXSA9IGRhdGEgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fY29sbGVjdGlvbkNhY2hlW2NvbnRlbnRUeXBlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLl9jb2xsZWN0aW9uQ2FjaGVbY29udGVudFR5cGVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3BlcnNpc3REYXRhOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZURhdGEgPSB0aGlzLl9jb2xsZWN0aW9uQ2FjaGVbY29udGVudFR5cGVdO1xyXG4gICAgICAgICAgICB0aGlzLmxvY2FsLnNhdmVEYXRhKGNvbnRlbnRUeXBlLCBjb250ZW50VHlwZURhdGEsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0QnlJZDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkKSB7XHJcbiAgICAgICAgICAgIGlmICghaWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdJZCBmaWVsZCBpcyBtYW5kYXRvcnkgd2hlbiB1c2luZyBvZmZsaW5lIHN0b3JhZ2UnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25baWRdKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF8uZXh0ZW5kKHt9LCBjb2xsZWN0aW9uW2lkXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNEZWxldGVkID0gaXRlbSAmJiBpdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGVsZXRlZCA/IHVuZGVmaW5lZCA6IGl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2V0SXRlbTogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGl0ZW0sIHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc09ubGluZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPSBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb2xsZWN0aW9uW2l0ZW0uX2lkXSA9IGl0ZW07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2NyZWF0ZUl0ZW1zOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGl0ZW1zLCBpc1N5bmMsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fZ2V0Q29sbGVjdGlvbihjb250ZW50VHlwZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1zVG9DcmVhdGUgPSBfLmlzQXJyYXkoaXRlbXMpID8gaXRlbXMgOiBbaXRlbXNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjcmVhdGVkSXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zVG9DcmVhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Ub0NyZWF0ZSA9IGl0ZW1zVG9DcmVhdGVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtQ29weSA9IF8uZXh0ZW5kKHt9LCBpdGVtVG9DcmVhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvcHkuX2lkID0gaXRlbUNvcHkuSWQgfHwgdXVpZC52MSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbUNvcHkuSWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUV4aXN0cyA9IGl0ZW1Db3B5Ll9pZCAmJiAhIXNlbGYuX2dldEJ5SWQoY29sbGVjdGlvbiwgaXRlbUNvcHkuX2lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1FeGlzdHMgJiYgIWlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogW29mZmxpbmVdIHJldHVybiB0aGUgc2FtZSBlcnJvciBhcyB0aGUgc2VydmVyIGRvZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihuZXcgRXJyb3IoJ0FuIGl0ZW0gd2l0aCB0aGUgc3BlY2lmaWVkIGlkIGFscmVhZHkgZXhpc3RzJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVRvQ3JlYXRlLkNyZWF0ZWRBdCAmJiBpdGVtQ29weS5DcmVhdGVkQXQgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29weS5DcmVhdGVkQXQgPSB1dGlscy5jbG9uZURhdGUoaXRlbVRvQ3JlYXRlLkNyZWF0ZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29weS5DcmVhdGVkQXQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVRvQ3JlYXRlLk1vZGlmaWVkQXQgJiYgaXRlbXNUb0NyZWF0ZS5Nb2RpZmllZEF0IGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvcHkuTW9kaWZpZWRBdCA9IHV0aWxzLmNsb25lRGF0ZShpdGVtVG9DcmVhdGUuTW9kaWZpZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29weS5Nb2RpZmllZEF0ID0gdXRpbHMuY2xvbmVEYXRlKGl0ZW1Db3B5LkNyZWF0ZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGlzU3luYyA/IHVuZGVmaW5lZCA6IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQ7IC8vIHNldCB0aGUgc3RhdGUgdG8gY3JlYXRlZCBvbmx5IGlmIG5vdCBzeW5jaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NldEl0ZW0oY29sbGVjdGlvbiwgaXRlbUNvcHksIHN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEl0ZW1zLnB1c2goaXRlbUNvcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGVyc2lzdERhdGEoY29udGVudFR5cGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhjcmVhdGVkSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0sIGVycm9yKVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hcHBseVVwZGF0ZU9wZXJhdGlvbjogZnVuY3Rpb24gKG9yaWdpbmFsVXBkYXRlRXhwcmVzc2lvbiwgaXRlbVRvVXBkYXRlLCBjb2xsZWN0aW9uLCBoYXNEYk9wZXJhdG9yLCBpc1N5bmMpIHtcclxuICAgICAgICAgICAgdmFyIHVwZGF0ZUV4cHJlc3Npb247XHJcbiAgICAgICAgICAgIGlmICghaGFzRGJPcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRXhwcmVzc2lvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkc2V0OiBfLmV4dGVuZCh7fSwgb3JpZ2luYWxVcGRhdGVFeHByZXNzaW9uKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUV4cHJlc3Npb24gPSBfLmV4dGVuZCh7fSwgb3JpZ2luYWxVcGRhdGVFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXBkYXRlRXhwcmVzc2lvbi4kc2V0ID0gXy5leHRlbmQoe30sIHVwZGF0ZUV4cHJlc3Npb24uJHNldCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVFeHByZXNzaW9uLiRzZXQuTW9kaWZpZWRBdCA9IHV0aWxzLmNsb25lRGF0ZShpdGVtVG9VcGRhdGUuTW9kaWZpZWRBdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVFeHByZXNzaW9uLiRzZXQuTW9kaWZpZWRBdCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1vbmdvUXVlcnkoaXRlbVRvVXBkYXRlLCB7fSwgdXBkYXRlRXhwcmVzc2lvbiwge3N0cmljdDogdHJ1ZX0pOyAvLyBTZXR0aW5nIHN0cmljdCB0byB0cnVlIHNvIG9ubHkgZXhhY3QgbWF0Y2hlcyB3b3VsZCBiZSB1cGRhdGVkXHJcblxyXG4gICAgICAgICAgICBpdGVtVG9VcGRhdGUuX2lkID0gaXRlbVRvVXBkYXRlLl9pZCB8fCB1cGRhdGVFeHByZXNzaW9uLl9pZCB8fCB1cGRhdGVFeHByZXNzaW9uLklkO1xyXG4gICAgICAgICAgICBkZWxldGUgaXRlbVRvVXBkYXRlLklkO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1N0YXRlO1xyXG4gICAgICAgICAgICBpZiAoaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbVRvVXBkYXRlW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0SXRlbShjb2xsZWN0aW9uLCBpdGVtVG9VcGRhdGUsIG5ld1N0YXRlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfdXBkYXRlSXRlbXM6IGZ1bmN0aW9uIChkYXRhUXVlcnksIHVwZGF0ZUV4cHJlc3Npb24sIGZpbHRlciwgaXNTeW5jLCByZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5fZ2V0Q29sbGVjdGlvbihkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVJdGVtcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRiT3BlcmF0b3JzID0gdXRpbHMuZ2V0RGJPcGVyYXRvcnModXBkYXRlRXhwcmVzc2lvbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0RiT3BlcmF0b3IgPSBkYk9wZXJhdG9ycy5sZW5ndGggIT09IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMgJiYgZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ub1VwZGF0ZSA9IHNlbGYuX2dldEJ5SWQoY29sbGVjdGlvbiwgZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYXBwbHlVcGRhdGVPcGVyYXRpb24odXBkYXRlRXhwcmVzc2lvbiwgaXRlbVRvVXBkYXRlLCBjb2xsZWN0aW9uLCBoYXNEYk9wZXJhdG9yLCBpc1N5bmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtcyA9IFtpdGVtVG9VcGRhdGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW1zID0gc2VsZi5fcmVhZEludGVybmFsKGNvbGxlY3Rpb24sIGZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlSXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVG9VcGRhdGUgPSB1cGRhdGVJdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtRXhpc3RzID0gISFzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGl0ZW1Ub1VwZGF0ZS5faWQudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtRXhpc3RzICYmICFpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KEV2ZXJsaXZlRXJyb3JzLml0ZW1Ob3RGb3VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYXBwbHlVcGRhdGVPcGVyYXRpb24odXBkYXRlRXhwcmVzc2lvbiwgaXRlbVRvVXBkYXRlLCBjb2xsZWN0aW9uLCBoYXNEYk9wZXJhdG9yLCBpc1N5bmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wZXJzaXN0RGF0YShkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vZGlmaWVkQXQ6IHVwZGF0ZUl0ZW1zWzBdLk1vZGlmaWVkQXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHVwZGF0ZUl0ZW1zLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfY2xlYXJJdGVtOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaXRlbSkge1xyXG4gICAgICAgICAgICBkZWxldGUgY29sbGVjdGlvbltpdGVtLl9pZF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JlbW92ZUl0ZW1zOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCBmaWx0ZXIsIGlzU3luYywgcmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHNlbGYuX2dldENvbGxlY3Rpb24oZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXNUb1JlbW92ZSA9IHNlbGYuX3JlYWRJbnRlcm5hbChjb2xsZWN0aW9uLCBmaWx0ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zVG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Ub1JlbW92ZSA9IGl0ZW1zVG9SZW1vdmVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ub1JlbW92ZS5faWQgPSBpdGVtVG9SZW1vdmUuX2lkIHx8IGl0ZW1Ub1JlbW92ZS5JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1FeGlzdHMgPSAhIXNlbGYuX2dldEJ5SWQoY29sbGVjdGlvbiwgaXRlbVRvUmVtb3ZlLl9pZC50b1N0cmluZygpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbUV4aXN0cyAmJiAhaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFdmVybGl2ZUVycm9yKCdDYW5ub3QgZGVsZXRlIGl0ZW0gLSBpdGVtIHdpdGggaWQgJyArIGl0ZW1Ub1JlbW92ZS5faWQgKyAnIGRvZXMgbm90IGV4aXN0LicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZUZyb21NZW1vcnkgPSBpdGVtVG9SZW1vdmVbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCB8fCBpc1N5bmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVGcm9tTWVtb3J5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9jbGVhckl0ZW0oY29sbGVjdGlvbiwgaXRlbVRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NldEl0ZW0oY29sbGVjdGlvbiwgaXRlbVRvUmVtb3ZlLCBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGVyc2lzdERhdGEoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHNlbGYuX3RyYW5zZm9ybU9mZmxpbmVSZXN1bHQoaXRlbXNUb1JlbW92ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FwcGx5VHJhbnNmb3JtYXRpb25zOiBmdW5jdGlvbiAodHJhbnNmb3JtZWRSZXN1bHQsIHRyYW5zZm9ybWF0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2godHJhbnNmb3JtYXRpb25zLCBmdW5jdGlvbiAodHJhbnNmb3JtYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQubWFwKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdFtrZXldID0gdHJhbnNmb3JtYXRpb24odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2godHJhbnNmb3JtYXRpb25zLCBmdW5jdGlvbiAodHJhbnNmb3JtYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQgPSB0cmFuc2Zvcm1hdGlvbih0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfdHJhbnNmb3JtT2ZmbGluZVJlc3VsdDogZnVuY3Rpb24gKHJlc3VsdFNldCwgY291bnQsIGRhdGFRdWVyeSwgYWRkaXRpb25hbFRyYW5zZm9ybWF0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRSZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFNldCxcclxuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCB8fCAocmVzdWx0U2V0IHx8IFtdKS5sZW5ndGhcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICgoY291bnQgIT09IHVuZGVmaW5lZCAmJiBjb3VudCAhPT0gbnVsbCkgfHwgQXJyYXkuaXNBcnJheShyZXN1bHRTZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFJlc3VsdC5jb3VudCA9IGNvdW50IHx8IHJlc3VsdFNldC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2gob2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMucmVtb3ZlTWFya2Vyc1RyYW5zZm9ybSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5jbHVkZUNvdW50ID0gZGF0YVF1ZXJ5LmdldEhlYWRlcihIZWFkZXJzLmluY2x1ZGVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUNvdW50ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1lZFJlc3VsdC5jb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlRmllbGRFeHByZXNzaW9uID0gZGF0YVF1ZXJ5LmdldEhlYWRlcihIZWFkZXJzLnNpbmdsZUZpZWxkKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2luZ2xlRmllbGRFeHByZXNzaW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuc2luZ2xlRmllbGRUcmFuc2Zvcm0uYmluZCh0aGlzLCBzaW5nbGVGaWVsZEV4cHJlc3Npb24pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxUcmFuc2Zvcm1hdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucyA9IHRyYW5zZm9ybWF0aW9ucy5jb25jYXQoYWRkaXRpb25hbFRyYW5zZm9ybWF0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5VHJhbnNmb3JtYXRpb25zKHRyYW5zZm9ybWVkUmVzdWx0LCB0cmFuc2Zvcm1hdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVkUmVzdWx0LmNvdW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1lZFJlc3VsdC5jb3VudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIE9mZmxpbmVNb2R1bGU7XHJcbn0pKCk7IiwidmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xyXG52YXIgcGVyc2lzdGVyc01vZHVsZSA9IHJlcXVpcmUoJy4vb2ZmbGluZVBlcnNpc3RlcnMnKTtcclxudmFyIExvY2FsU3RvcmFnZVBlcnNpc3RlciA9IHBlcnNpc3RlcnNNb2R1bGUuTG9jYWxTdG9yYWdlUGVyc2lzdGVyO1xyXG52YXIgRmlsZVN5c3RlbVBlcnNpc3RlciA9IHBlcnNpc3RlcnNNb2R1bGUuRmlsZVN5c3RlbVBlcnNpc3RlcjtcclxudmFyIE9mZmxpbmVTdG9yYWdlTW9kdWxlID0gcmVxdWlyZSgnLi9PZmZsaW5lU3RvcmFnZU1vZHVsZScpO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XHJcbnZhciBfID0gY29tbW9uLl87XHJcbnZhciByc3ZwID0gY29tbW9uLnJzdnA7XHJcblxyXG52YXIgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyA9IHtcclxuICAgIGF1dG9TeW5jOiB0cnVlLFxyXG4gICAgY29uZmxpY3RSZXNvbHV0aW9uOiBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ2xpZW50V2lucyxcclxuICAgIG9mZmxpbmU6IGZhbHNlLFxyXG4gICAgcHJvdmlkZXJUeXBlOiBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVycy5Mb2NhbFN0b3JhZ2UsXHJcbiAgICBzeW5jU3RhcnQ6IGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgIGNiKCk7XHJcbiAgICB9LFxyXG4gICAgc3luY0VuZDogXy5ub29wLFxyXG4gICAgc3luY0ludGVydmFsOiBjb25zdGFudHMuZGVmYXVsdFN5bmNJbnRlcnZhbFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBjb25mbGljdFJlc29sdXRpb25TdHJhdGVnaWVzID0ge307XHJcblxyXG4gICAgY29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ2llc1tjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ2xpZW50V2luc10gPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgbG9jYWwsIHNlcnZlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUobG9jYWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25mbGljdFJlc29sdXRpb25TdHJhdGVnaWVzW2NvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneS5TZXJ2ZXJXaW5zXSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBsb2NhbCwgc2VydmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShzZXJ2ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgYnVpbGRPZmZsaW5lU3RvcmFnZU1vZHVsZSA9IGZ1bmN0aW9uIChzdG9yYWdlT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHRpb25zO1xyXG4gICAgICAgIGlmIChzdG9yYWdlT3B0aW9ucyA9PT0gdHJ1ZSkgeyAvLyBleHBsaWNpdCBjaGVjayBmb3Igc2hvcnRoYW5kIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zKTtcclxuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3Qoc3RvcmFnZU9wdGlvbnMpICYmIHN0b3JhZ2VPcHRpb25zLnByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHN0b3JhZ2VPcHRpb25zLCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcGVyc2lzdGVyO1xyXG4gICAgICAgIHZhciBwZXJzaXN0ZXJUeXBlID0gb3B0aW9ucy5wcm92aWRlclR5cGU7XHJcbiAgICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBzdG9yYWdlT3B0aW9ucy5uYW1lIHx8ICdldmVybGl2ZU9mZmxpbmVTdG9yYWdlXycgKyB0aGlzLnNldHVwLmFwaUtleTtcclxuICAgICAgICBpZiAodHlwZW9mIHBlcnNpc3RlclR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcGVyc2lzdGVyID0gbmV3IHN0b3JhZ2VPcHRpb25zLnByb3ZpZGVyVHlwZShzdG9yYWdlS2V5LCBzdG9yYWdlT3B0aW9ucy5jdXN0b21PcHRpb25zKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0N1c3RvbSBzdG9yYWdlIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3dpdGNoIChwZXJzaXN0ZXJUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5TdG9yYWdlUHJvdmlkZXJzLkxvY2FsU3RvcmFnZTpcclxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZXIgPSBuZXcgTG9jYWxTdG9yYWdlUGVyc2lzdGVyKHN0b3JhZ2VLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVycy5GaWxlU3lzdGVtOlxyXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlciA9IG5ldyBGaWxlU3lzdGVtUGVyc2lzdGVyKHN0b3JhZ2VLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVW5zdXBwb3J0ZWQgc3RvcmFnZSB0eXBlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZVN0b3JhZ2VNb2R1bGUodGhpcywgb3B0aW9ucywgcGVyc2lzdGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGluaXRPZmZsaW5lU3RvcmFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLm9mZmxpbmVTdG9yYWdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IGJ1aWxkT2ZmbGluZVN0b3JhZ2VNb2R1bGUuY2FsbCh0aGlzLCBvcHRpb25zLm9mZmxpbmVTdG9yYWdlKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbml0T2ZmbGluZVN0b3JhZ2U6IGluaXRPZmZsaW5lU3RvcmFnZVxyXG4gICAgfVxyXG59KCkpOyIsInZhciBwbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL2V2ZXJsaXZlLnBsYXRmb3JtJyk7XHJcbnZhciBpc05hdGl2ZVNjcmlwdEFwcGxpY2F0aW9uID0gcGxhdGZvcm0uaXNOYXRpdmVTY3JpcHQ7XHJcbnZhciBpc0NvcmRvdmFBcHBsaWNhdGlvbiA9IHBsYXRmb3JtLmlzQ29yZG92YTtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgcGFyc2VVdGlsaXRpZXMgPSByZXF1aXJlKCcuLi91dGlscycpLnBhcnNlVXRpbGl0aWVzO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG5cclxuLyoqXHJcbiAqIENhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB0eXBlczoge0BsaW5rIExvY2FsU3RvcmFnZVBlcnNpc3Rlcn0sXHJcbiAqIHtAbGluayBGaWxlU3lzdGVtUGVyc2lzdGVyfSBvciBhIGN1c3RvbSBiYXNlZCBvbiB7QGxpbmsgQmFzZVBlcnNpc3Rlcn1cclxuICogQG1lbWJlck9mIE9mZmxpbmVNb2R1bGVcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXIge0Jhc2VQZXJzaXN0ZXJ9IGxvY2FsXHJcbiAqL1xyXG5cclxudmFyIEJhc2VQZXJzaXN0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIEJhc2VQZXJzaXN0ZXJcclxuICAgICAqIEBjbGFzc2Rlc2MgQW4gYWJzdHJhY3Rpb24gbGF5ZXIgZm9yIGFsbCBwZXJzaXN0ZXJzLiBFdmVyeSBwZXJzaXN0ZXIgY2FuIHdyaXRlL3JlYWRcclxuICAgICAqIGRhdGEgZnJvbSBhIHNwZWNpZmljIHBsYWNlLiBUaGUgZGF0YSBpcyBzYXZlZCBhcyBrZXktdmFsdWUgcGFpcnMgd2hlcmUgdGhlIGtleXMgYXJlXHJcbiAgICAgKiBjb250ZW50IHR5cGVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCYXNlUGVyc2lzdGVyKCkge1xyXG4gICAgfVxyXG5cclxuICAgIEJhc2VQZXJzaXN0ZXIucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYWxsIHRoZSBzYXZlZCBkYXRhLlxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0QWxsRGF0YVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBCYXNlUGVyc2lzdGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyBBIHN1Y2Nlc3MgY2FsbGJhY2tcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciBBbiBlcnJvciBjYWxsYmFja1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEtleXMgYXJlIHRoZSBjb250ZW50IHR5cGVzIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgY29ycmVzcG9uZGluZyBkYXRhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0QWxsRGF0YTogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgbWV0aG9kIGdldEFsbERhdGEgaXMgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2F2ZWQgZGF0YSBmb3IgYSBzcGVjaWZpYyBjb250ZW50IHR5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGdldERhdGFcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgdHlwZSBmb3Igd2hpY2ggdG8gcmV0cmVpdmUgdGhlIGRhdGFcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEJhc2VQZXJzaXN0ZXJcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmV0cmV2ZWQgZGF0YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldERhdGE6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBtZXRob2QgZ2V0RGF0YSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYXZlcyBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2F2ZURhdGFcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgZm9yIHdoaWNoIHRvIHNhdmUgdGhlIGRhdGFcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgZGF0YSBjb3Jlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZCBjb250ZW50IHR5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEJhc2VQZXJzaXN0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBzYXZlRGF0YTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBkYXRhLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIG1ldGhvZCBzYXZlRGF0YSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIHBlcnNpc3RlZCBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgdHlwZSBmb3Igd2hpY2ggdG8gY2xlYXIgdGhlIGRhdGFcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEJhc2VQZXJzaXN0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIG1ldGhvZCBjbGVhciBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIHBlcnNpc3RlZCBkYXRhIGZvciBhIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJBbGxcclxuICAgICAgICAgKiBAbWVtYmVyb2YgQmFzZVBlcnNpc3RlclxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgQSBzdWNjZXNzIGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgQW4gZXJyb3IgY2FsbGJhY2tcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGVhckFsbDogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgbWV0aG9kIGNsZWFyQWxsIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRLZXk6IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXkgKyAnXycgKyBjb250ZW50VHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBCYXNlUGVyc2lzdGVyO1xyXG59KCkpO1xyXG5cclxudmFyIExvY2FsU3RvcmFnZVBlcnNpc3RlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXJcclxuICAgICAqIEBleHRlbmRzIEJhc2VQZXJzaXN0ZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTG9jYWxTdG9yYWdlUGVyc2lzdGVyKGtleSkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cclxuICAgICAgICBpZiAoaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmxvY2FsU2V0dGluZ3MgPSByZXF1aXJlKCdsb2NhbC1zZXR0aW5ncycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfLmV4dGVuZChMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLCBCYXNlUGVyc2lzdGVyLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGdldEFsbERhdGE6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZXMgPSB0aGlzLl9nZXRDb250ZW50VHlwZXMoKTtcclxuICAgICAgICAgICAgdmFyIGFsbENvbGxlY3Rpb25zID0ge307XHJcbiAgICAgICAgICAgIF8uZWFjaChjb250ZW50VHlwZXMsIGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgYWxsQ29sbGVjdGlvbnNbY29udGVudFR5cGVdID0gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXREYXRhKGNvbnRlbnRUeXBlLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcnN2cC5oYXNoKGFsbENvbGxlY3Rpb25zKS50aGVuKHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXREYXRhOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9nZXRLZXkoY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmVkSXRlbSA9IHRoaXMuX2dldEl0ZW0oa2V5KSB8fCAne30nO1xyXG4gICAgICAgICAgICB2YXIgcmV2aXZlciA9IHBhcnNlVXRpbGl0aWVzLmdldFJldml2ZXIoKTtcclxuICAgICAgICAgICAgdmFyIHN0b3JlZEl0ZW1PYmplY3QgPSBKU09OLnBhcnNlKHN0b3JlZEl0ZW0sIHJldml2ZXIpO1xyXG4gICAgICAgICAgICBzdWNjZXNzKHN0b3JlZEl0ZW1PYmplY3QpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNhdmVEYXRhOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGRhdGEsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGVLZXkgPSB0aGlzLl9nZXRLZXkoY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRJdGVtKGNvbnRlbnRUeXBlS2V5LCBjb2xsZWN0aW9uc1N0cmluZyk7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fZ2V0S2V5KGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xlYXJBbGw6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGVzID0gdGhpcy5fZ2V0Q29udGVudFR5cGVzKCk7XHJcbiAgICAgICAgICAgIF8uZWFjaChjb250ZW50VHlwZXMsIGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlS2V5ID0gc2VsZi5fZ2V0S2V5KGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZUl0ZW0oY29udGVudFR5cGVLZXkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZXNLZXkgPSB0aGlzLl9nZXRDb250ZW50VHlwZXNDb2xsZWN0aW9uS2V5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUl0ZW0oY29udGVudFR5cGVzS2V5KTtcclxuXHJcbiAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0SXRlbTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTZXR0aW5ncy5nZXRTdHJpbmcoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JlbW92ZUl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGlzTmF0aXZlU2NyaXB0QXBwbGljYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU2V0dGluZ3MucmVtb3ZlKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3NldEl0ZW06IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc05hdGl2ZVNjcmlwdEFwcGxpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFNldHRpbmdzLnNldFN0cmluZyhrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRLZXk6IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRUeXBlVG9Db2xsZWN0aW9uc0NhY2hlKGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5ICsgJ18nICsgY29udGVudFR5cGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldENvbnRlbnRUeXBlc0NvbGxlY3Rpb25LZXk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5ICsgJ0BDb250ZW50VHlwZXMnO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRDb250ZW50VHlwZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25LZXkgPSB0aGlzLl9nZXRDb250ZW50VHlwZXNDb2xsZWN0aW9uS2V5KCk7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbFN0b3JhZ2VTdHJpbmcgPSB0aGlzLl9nZXRJdGVtKGNvbGxlY3Rpb25LZXkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlU3RyaW5nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9zZXRDb250ZW50VHlwZXNDb2xsZWN0aW9uOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbktleSA9IHRoaXMuX2dldENvbnRlbnRUeXBlc0NvbGxlY3Rpb25LZXkoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0SXRlbShjb2xsZWN0aW9uS2V5LCBKU09OLnN0cmluZ2lmeShjb2xsZWN0aW9uKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FkZFR5cGVUb0NvbGxlY3Rpb25zQ2FjaGU6IGZ1bmN0aW9uICh0eXBlTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGVzQ29sbGVjdGlvbiA9IHRoaXMuX2dldENvbnRlbnRUeXBlcygpO1xyXG4gICAgICAgICAgICBpZiAoIV8uY29udGFpbnMoY29udGVudFR5cGVzQ29sbGVjdGlvbiwgdHlwZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZXNDb2xsZWN0aW9uLnB1c2godHlwZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudFR5cGVzQ29sbGVjdGlvbihjb250ZW50VHlwZXNDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXI7XHJcbn0oKSk7XHJcblxyXG52YXIgRmlsZVN5c3RlbVBlcnNpc3RlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBGaWxlU3lzdGVtUGVyc2lzdGVyXHJcbiAgICAgKiBAZXh0ZW5kcyBCYXNlUGVyc2lzdGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEZpbGVTeXN0ZW1QZXJzaXN0ZXIoa2V5KSB7XHJcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9ICcvJztcclxuICAgICAgICBpZiAoIWlzQ29yZG92YUFwcGxpY2F0aW9uICYmICFpc05hdGl2ZVNjcmlwdEFwcGxpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdGaWxlU3lzdGVtUGVyc2lzdGVyIGNhbiBiZSB1c2VkIG9ubHkgd2l0aCBDb3Jkb3ZhIGFuZCBOYXRpdmVTY3JpcHQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0NvcmRvdmFBcHBsaWNhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIWNvcmRvdmEgJiYgIWNvcmRvdmEuZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1lvdSBuZWVkIHRvIGVuYWJsZSB0aGUgY29yZG92YSBmaWxlIHBsdWdpbiB0byB1c2UgZmlsZSBvZmZsaW5lIHN0b3JhZ2UuICcgK1xyXG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0byBpbml0aWFsaXplIHlvdXIgRXZlcmxpdmUgaW5zdGFuY2UgYWZ0ZXIgdGhlIFwiZGV2aWNlUmVhZHlcIiBldmVudCBoYXMgZmlyZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YURpcmVjdG9yeVBhdGggPSBjb3Jkb3ZhLmZpbGUuZGF0YURpcmVjdG9yeTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTmF0aXZlU2NyaXB0QXBwbGljYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZpbGUtc3lzdGVtJyk7XHJcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IHRoaXMuZnMucGF0aC5zZXBhcmF0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YURpcmVjdG9yeVBhdGggPSB0aGlzLmZzLmtub3duRm9sZGVycy5jdXJyZW50QXBwKCkucGF0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMuY29udGVudFR5cGVzU3RvcmVLZXkgPSAnQENvbnRlbnRUeXBlcyc7XHJcbiAgICAgICAgdGhpcy5maWxlc0RpcmVjdG9yeVBhdGggPSAnZWxfc3RvcmUnICsgc2VwYXJhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIF8uZXh0ZW5kKEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLCBCYXNlUGVyc2lzdGVyLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGdldEFsbERhdGE6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSB0aGlzLl9maWxlU3lzdGVtRXJyb3JIYW5kbGVyKGVycm9yKTtcclxuICAgICAgICAgICAgdmFyIHByb21pc2VzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuX2dldENvbnRlbnRUeXBlc01ldGFkYXRhKGZ1bmN0aW9uIChjb250ZW50VHlwZXMpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRlbnRUeXBlcykuZm9yRWFjaChmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tjb250ZW50VHlwZV0gPSBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXREYXRhKGNvbnRlbnRUeXBlLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcnN2cC5oYXNoKHByb21pc2VzKS50aGVuKHN1Y2Nlc3MsIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgICAgIH0sIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSB0aGlzLl9maWxlU3lzdGVtRXJyb3JIYW5kbGVyKGVycm9yKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2V0RmlsZUZ1bGwoY29udGVudFR5cGUsIGZ1bmN0aW9uIChmaWxlRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3JlYWRGaWxlQ29udGVudChmaWxlRW50cnksIHN1Y2Nlc3MsIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNhdmVEYXRhOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGRhdGEsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGRhdGFTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IHRoaXMuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRGaWxlRnVsbChjb250ZW50VHlwZSwgZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fd3JpdGVGaWxlQ29udGVudChmaWxlRW50cnksIGRhdGFTdHJpbmcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zYXZlQ29udGVudFR5cGVzTWV0YWRhdGEoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IHRoaXMuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRGaWxlRnVsbChjb250ZW50VHlwZSwgZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlRmlsZShmaWxlRW50cnksIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgfSwgZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjbGVhckFsbDogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IHRoaXMuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGF0YURpcmVjdG9yeShmdW5jdGlvbiAoZGF0YURpckVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9yZW1vdmVGaWxlc0RpcmVjdG9yeShkYXRhRGlyRW50cnksIHN1Y2Nlc3MsIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgICAgIH0sIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldENvbnRlbnRUeXBlc01ldGFkYXRhOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXREYXRhKHRoaXMuY29udGVudFR5cGVzU3RvcmVLZXksIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2F2ZUNvbnRlbnRUeXBlc01ldGFkYXRhOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fZ2V0Q29udGVudFR5cGVzTWV0YWRhdGEoZnVuY3Rpb24gKHNhdmVkQ29udGVudFR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICBzYXZlZENvbnRlbnRUeXBlc1tjb250ZW50VHlwZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fZ2V0RmlsZUZ1bGwoc2VsZi5jb250ZW50VHlwZXNTdG9yZUtleSwgZnVuY3Rpb24gKGNvbnRlbnRUeXBlc0ZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl93cml0ZUZpbGVDb250ZW50KGNvbnRlbnRUeXBlc0ZpbGUsIEpTT04uc3RyaW5naWZ5KHNhdmVkQ29udGVudFR5cGVzKSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RmlsZUZ1bGw6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVGaWxlc0RpcmVjdG9yeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHNlbGYuX2dldEZpbGVQYXRoKGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2dldEZpbGUocGF0aCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICB9LCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JlbW92ZUZpbGVzRGlyZWN0b3J5OiBmdW5jdGlvbiAoZGlyZWN0b3J5RW50cnksIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0NvcmRvdmFBcHBsaWNhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0b3J5RW50cnkuZ2V0RGlyZWN0b3J5KHRoaXMuZmlsZXNEaXJlY3RvcnlQYXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1c2l2ZTogZmFsc2VcclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChmaWxlc0RpckVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZXNEaXJFbnRyeS5yZW1vdmVSZWN1cnNpdmVseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9LCBlcnJvcilcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdEFwcGxpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXNEaXJlY3RvcnlQYXRoID0gdGhpcy5mcy5wYXRoLmpvaW4oZGlyZWN0b3J5RW50cnkucGF0aCwgdGhpcy5maWxlc0RpcmVjdG9yeVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVzRGlyZWN0b3J5ID0gdGhpcy5mcy5Gb2xkZXIuZnJvbVBhdGgoZmlsZXNEaXJlY3RvcnlQYXRoKTtcclxuICAgICAgICAgICAgICAgIGZpbGVzRGlyZWN0b3J5LnJlbW92ZSgpLnRoZW4oc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JlbW92ZUZpbGU6IGZ1bmN0aW9uIChmaWxlRW50cnksIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0NvcmRvdmFBcHBsaWNhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZmlsZUVudHJ5LnJlbW92ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmF0aXZlU2NyaXB0QXBwbGljYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGZpbGVFbnRyeS5yZW1vdmUoKS50aGVuKHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9yZWFkRmlsZUNvbnRlbnQ6IGZ1bmN0aW9uIChmaWxlRW50cnksIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciByZWFkVGV4dFN1Y2Nlc3MgPSBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldml2ZXIgPSBwYXJzZVV0aWxpdGllcy5nZXRSZXZpdmVyKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0T2JqZWN0ID0gSlNPTi5wYXJzZShjb250ZW50IHx8ICd7fScsIHJldml2ZXIpO1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhyZXN1bHRPYmplY3QpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzQ29yZG92YUFwcGxpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBmaWxlRW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRUZXh0U3VjY2Vzcyh0aGlzLnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmF0aXZlU2NyaXB0QXBwbGljYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGZpbGVFbnRyeS5yZWFkVGV4dCgpLnRoZW4ocmVhZFRleHRTdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfd3JpdGVGaWxlQ29udGVudDogZnVuY3Rpb24gKGZpbGVFbnRyeSwgY29udGVudCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKGlzQ29yZG92YUFwcGxpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBmaWxlRW50cnkuY3JlYXRlV3JpdGVyKGZ1bmN0aW9uIChmaWxlV3JpdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVdyaXRlci5vbndyaXRlZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLm9uZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLndyaXRlKGNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmF0aXZlU2NyaXB0QXBwbGljYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGZpbGVFbnRyeS53cml0ZVRleHQoY29udGVudCkudGhlbihzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RmlsZTogZnVuY3Rpb24gKHBhdGgsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVEYXRhRGlyZWN0b3J5KGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29yZG92YUFwcGxpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5RW50cnkuZ2V0RmlsZShwYXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVzaXZlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxsRmlsZVBhdGggPSB0aGlzLmZzLnBhdGguam9pbihkaXJlY3RvcnlFbnRyeS5wYXRoLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZnMuRmlsZS5mcm9tUGF0aChmdWxsRmlsZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZmlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgZXJyb3IpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldEZpbGVQYXRoOiBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXNEaXJlY3RvcnlQYXRoICsgdGhpcy5fZ2V0S2V5KGNvbnRlbnRUeXBlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfcmVzb2x2ZURhdGFEaXJlY3Rvcnk6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoaXNDb3Jkb3ZhQXBwbGljYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVMb2NhbEZpbGVTeXN0ZW1VUkwodGhpcy5kYXRhRGlyZWN0b3J5UGF0aCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmF0aXZlU2NyaXB0QXBwbGljYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhRGlyZWN0b3J5ID0gdGhpcy5mcy5Gb2xkZXIuZnJvbVBhdGgodGhpcy5kYXRhRGlyZWN0b3J5UGF0aCk7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzKGRhdGFEaXJlY3RvcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2Vuc3VyZUZpbGVzRGlyZWN0b3J5OiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGZpbGVzRGlyZWN0b3J5UGF0aCA9IHRoaXMuZmlsZXNEaXJlY3RvcnlQYXRoO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGF0YURpcmVjdG9yeShmdW5jdGlvbiAoZGlyZWN0b3J5RW50cnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NvcmRvdmFBcHBsaWNhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeUVudHJ5LmdldERpcmVjdG9yeShmaWxlc0RpcmVjdG9yeVBhdGgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGNsdXNpdmU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdEFwcGxpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVEaXJlY3RvcnlQYXRoID0gdGhpcy5mcy5wYXRoLmpvaW4oZGlyZWN0b3J5RW50cnkucGF0aCwgZmlsZXNEaXJlY3RvcnlQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZzLkZvbGRlci5mcm9tUGF0aChmaWxlRGlyZWN0b3J5UGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZmlsZVN5c3RlbUVycm9ySGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yc01hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKE9iamVjdC5rZXlzKEZpbGVFcnJvciksIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yc01hcFtGaWxlRXJyb3JbZXJyb3JdXSA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGVycm9yc01hcFtlLmNvZGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvcjogJyArIG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gbXNnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvcjogJyArIEpTT04uc3RyaW5naWZ5KGUpKTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIEZpbGVTeXN0ZW1QZXJzaXN0ZXI7XHJcbn0oKSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEJhc2VQZXJzaXN0ZXI6IEJhc2VQZXJzaXN0ZXIsXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXI6IExvY2FsU3RvcmFnZVBlcnNpc3RlcixcclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXI6IEZpbGVTeXN0ZW1QZXJzaXN0ZXJcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxudmFyIG9mZmxpbmVJdGVtU3RhdGVNYXJrZXIgPSBjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXI7XHJcblxyXG52YXIgb2ZmbGluZVRyYW5zZm9ybWF0aW9ucyA9IHtcclxuICAgIGlkVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXy5tYXAodmFsdWUsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybShpdGVtKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5faWQgJiYgIXZhbHVlLklkKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLklkID0gdmFsdWUuX2lkO1xyXG4gICAgICAgICAgICBkZWxldGUgdmFsdWUuX2lkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSxcclxuICAgIHNpbmdsZUZpZWxkVHJhbnNmb3JtOiBmdW5jdGlvbiAoc2luZ2xlRmllbGRFeHByZXNzaW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtzaW5nbGVGaWVsZEV4cHJlc3Npb25dO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0cmF2ZXJzZUFuZFRyYW5zZm9ybUZpbHRlcklkOiBmdW5jdGlvbiAoZmlsdGVyT2JqKSB7XHJcbiAgICAgICAgaWYgKGZpbHRlck9iaiAmJiBmaWx0ZXJPYmouSWQpIHtcclxuICAgICAgICAgICAgZmlsdGVyT2JqLl9pZCA9IGZpbHRlck9iai5JZDtcclxuICAgICAgICAgICAgZGVsZXRlIGZpbHRlck9iai5JZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZmlsdGVyT2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJPYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmplY3RNZW1iZXIgPSBmaWx0ZXJPYmpbcHJvcF07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdE1lbWJlciA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnRyYXZlcnNlQW5kVHJhbnNmb3JtRmlsdGVySWQob2JqZWN0TWVtYmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW1vdmVNYXJrZXJzVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBkZWxldGUgdmFsdWVbb2ZmbGluZUl0ZW1TdGF0ZU1hcmtlcl07XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zOyIsInZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFRPRE86IFtvZmZsaW5lXSBVcGRhdGUgdGhlIHN0cnVjdHVyZSAtIGZpbHRlciBmaWVsZCBjYW4gYmUgcmVmYWN0b3JlZCBmb3IgZXhhbXBsZSBhbmQgYSBza2lwL2xpbWl0L3NvcnQgcHJvcGVydHkgY2FuIGJlIGFkZGVkXHJcbiAgICB2YXIgRGF0YVF1ZXJ5ID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbk5hbWUgPSBjb25maWcuY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBjb25maWcuZmlsdGVyO1xyXG4gICAgICAgIHRoaXMub25TdWNjZXNzID0gY29uZmlnLm9uU3VjY2VzcztcclxuICAgICAgICB0aGlzLm9uRXJyb3IgPSBjb25maWcub25FcnJvcjtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IGNvbmZpZy5vcGVyYXRpb247XHJcbiAgICAgICAgdGhpcy5wYXJzZSA9IGNvbmZpZy5wYXJzZTtcclxuICAgICAgICB0aGlzLmFkZGl0aW9uYWxPcHRpb25zID0gY29uZmlnLmFkZGl0aW9uYWxPcHRpb25zO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGNvbmZpZy5kYXRhO1xyXG4gICAgICAgIHRoaXMud29ya09mZmxpbmUgPSBjb25maWcud29ya09mZmxpbmU7XHJcbiAgICAgICAgdGhpcy5hcHBseU9mZmxpbmUgPSBjb25maWcuYXBwbHlPZmZsaW5lO1xyXG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRIZWFkZXJzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmlzU3luYyA9IGNvbmZpZy5pc1N5bmM7XHJcbiAgICB9O1xyXG5cclxuICAgIERhdGFRdWVyeS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgZ2V0SGVhZGVyOiBmdW5jdGlvbiAoaGVhZGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGhlYWRlcktleXMgPSBPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ub3JtYWxpemVkSGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplZEhlYWRlcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChoZWFkZXJLZXlzLCBmdW5jdGlvbiAoaGVhZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRLZXkgPSBoZWFkZXJLZXkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyVmFsdWUgPSBzZWxmLmhlYWRlcnNbaGVhZGVyS2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9ub3JtYWxpemVkSGVhZGVyc1tub3JtYWxpemVkS2V5XSA9IGhlYWRlclZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkSGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVkSGVhZGVyc1tub3JtYWxpemVkSGVhZGVyXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRIZWFkZXJBc0pTT046IGZ1bmN0aW9uIChoZWFkZXIpIHtcclxuICAgICAgICAgICAgdmFyIGhlYWRlclZhbHVlID0gdGhpcy5fbm9ybWFsaXplZEhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgICAgICAgICBpZiAoaGVhZGVyVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGhlYWRlclZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIChvcGVyYXRpb25QYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMud29ya09mZmxpbmUgPSBvcGVyYXRpb25QYXJhbWV0ZXJzLndvcmtPZmZsaW5lO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5T2ZmbGluZSA9IG9wZXJhdGlvblBhcmFtZXRlcnMuYXBwbHlPZmZsaW5lO1xyXG4gICAgICAgICAgICB0aGlzLmlzU3luYyA9IG9wZXJhdGlvblBhcmFtZXRlcnMuaXNTeW5jO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMgPSB7XHJcbiAgICAgICAgcmVhZDogJ3JlYWQnLFxyXG4gICAgICAgIGNyZWF0ZTogJ2NyZWF0ZScsXHJcbiAgICAgICAgdXBkYXRlOiAndXBkYXRlJyxcclxuICAgICAgICByZW1vdmU6ICdkZXN0cm95JyxcclxuICAgICAgICByZW1vdmVTaW5nbGU6ICdkZXN0cm95U2luZ2xlJyxcclxuICAgICAgICByZWFkQnlJZDogJ3JlYWRCeUlkJyxcclxuICAgICAgICBjb3VudDogJ2NvdW50JyxcclxuICAgICAgICByYXdVcGRhdGU6ICdyYXdVcGRhdGUnLFxyXG4gICAgICAgIHNldEFjbDogJ3NldEFjbCcsXHJcbiAgICAgICAgc2V0T3duZXI6ICdzZXRPd25lcicsXHJcbiAgICAgICAgdXNlckxvZ2luOiAnbG9naW4nLFxyXG4gICAgICAgIHVzZXJMb2dvdXQ6ICdsb2dvdXQnLFxyXG4gICAgICAgIHVzZXJDaGFuZ2VQYXNzd29yZDogJ2NoYW5nZVBhc3N3b3JkJyxcclxuICAgICAgICB1c2VyTG9naW5XaXRoUHJvdmlkZXI6ICdsb2dpbldpdGgnLFxyXG4gICAgICAgIHVzZXJMaW5rV2l0aFByb3ZpZGVyOiAnbGlua1dpdGgnLFxyXG4gICAgICAgIHVzZXJVbmxpbmtGcm9tUHJvdmlkZXI6ICd1bmxpbmtGcm9tJyxcclxuICAgICAgICBmaWxlc1VwZGF0ZUNvbnRlbnQ6ICd1cGRhdGVDb250ZW50JyxcclxuICAgICAgICBmaWxlc0dldERvd25sb2FkVXJsQnlJZDogJ2Rvd25sb2FkVXJsQnlJZCdcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIERhdGFRdWVyeTtcclxufSgpKTsiLCJ2YXIgRXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4uL0V4cHJlc3Npb24nKTtcclxudmFyIE9wZXJhdG9yVHlwZSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLk9wZXJhdG9yVHlwZTtcclxudmFyIFdoZXJlUXVlcnkgPSByZXF1aXJlKCcuL1doZXJlUXVlcnknKTtcclxudmFyIFF1ZXJ5QnVpbGRlciA9IHJlcXVpcmUoJy4vUXVlcnlCdWlsZGVyJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBRdWVyeVxyXG4gICAgICogQGNsYXNzZGVzYyBBIHF1ZXJ5IGNsYXNzIHVzZWQgdG8gZGVzY3JpYmUgYSByZXF1ZXN0IHRoYXQgd2lsbCBiZSBtYWRlIHRvIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEphdmFTY3JpcHQgQVBJLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtmaWx0ZXJdIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZmllbGRzXSBBIFtmaWVsZHMgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1TdWJzZXQtb2YtZmllbGRzICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtzb3J0XSBBIFtzb3J0IGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctc29ydGluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2tpcF0gTnVtYmVyIG9mIGl0ZW1zIHRvIHNraXAuIFVzZWQgZm9yIHBhZ2luZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGFrZV0gTnVtYmVyIG9mIGl0ZW1zIHRvIHRha2UuIFVzZWQgZm9yIHBhZ2luZy5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZXhwYW5kXSBBbiBbZXhwYW5kIGV4cHJlc3Npb25dKHslIHNsdWcgZmVhdHVyZXMtZGF0YS1yZWxhdGlvbnMtZGVmaW5pbmctZXhwYW5kICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBRdWVyeShmaWx0ZXIsIGZpZWxkcywgc29ydCwgc2tpcCwgdGFrZSwgZXhwYW5kKSB7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XHJcbiAgICAgICAgdGhpcy5zb3J0ID0gc29ydDtcclxuICAgICAgICB0aGlzLnRvc2tpcCA9IHNraXA7XHJcbiAgICAgICAgdGhpcy50b3Rha2UgPSB0YWtlO1xyXG4gICAgICAgIHRoaXMuZXhwYW5kID0gZXhwYW5kO1xyXG4gICAgICAgIHRoaXMuZXhwciA9IG5ldyBFeHByZXNzaW9uKE9wZXJhdG9yVHlwZS5xdWVyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgUXVlcnkucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8qKiBBcHBsaWVzIGEgZmlsdGVyIHRvIHRoZSBjdXJyZW50IHF1ZXJ5LiBUaGlzIGFsbG93cyB5b3UgdG8gcmV0cmlldmUgb25seSBhIHN1YnNldCBvZiB0aGUgaXRlbXMgYmFzZWQgb24gdmFyaW91cyBmaWx0ZXJpbmcgY3JpdGVyaWEuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgd2hlcmVcclxuICAgICAgICAgKiBAbmFtZSB3aGVyZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKiogRGVmaW5lcyBhIGZpbHRlciBkZWZpbml0aW9uIGZvciB0aGUgY3VycmVudCBxdWVyeS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB3aGVyZVxyXG4gICAgICAgICAqIEBuYW1lIHdoZXJlXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2hlcmU6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZmlsdGVyLCBbZmlsdGVyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBBcHBsaWVzIGEgZmllbGRzIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudCBxdWVyeS4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIG9ubHkgYSBzdWJzZXQgb2YgYWxsIGF2YWlsYWJsZSBpdGVtIGZpZWxkcy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZWxlY3RcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmllbGRzRXhwcmVzc2lvbiBBIFtmaWVsZHMgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1TdWJzZXQtb2YtZmllbGRzICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuc2VsZWN0LCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIC8vZXhjbHVkZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmV4Y2x1ZGUsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgLy99LFxyXG4gICAgICAgIC8qKiBTb3J0cyB0aGUgaXRlbXMgaW4gdGhlIGN1cnJlbnQgcXVlcnkgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSBzcGVjaWZpZWQgZmllbGQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgb3JkZXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWUgdG8gb3JkZXIgYnkgaW4gYXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBvcmRlcjogZnVuY3Rpb24gKGZpZWxkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLm9yZGVyLCBbZmllbGRdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBTb3J0cyB0aGUgaXRlbXMgaW4gdGhlIGN1cnJlbnQgcXVlcnkgaW4gZGVzY2VuZGluZyBvcmRlciBieSB0aGUgc3BlY2lmaWVkIGZpZWxkLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIG9yZGVyRGVzY1xyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZSB0byBvcmRlciBieSBpbiBkZXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBvcmRlckRlc2M6IGZ1bmN0aW9uIChmaWVsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5vcmRlcl9kZXNjLCBbZmllbGRdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBTa2lwcyBhIGNlcnRhaW4gbnVtYmVyIG9mIGl0ZW1zIGZyb20gdGhlIGJlZ2lubmluZyBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN0IG9mIHRoZSBpdGVtcy4gVXNlZCBmb3IgcGFnaW5nLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNraXBcclxuICAgICAgICAgKiBAc2VlIFtxdWVyeS50YWtlXXtAbGluayBxdWVyeS50YWtlfVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHNraXAuXHJcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNraXA6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5za2lwLCBbdmFsdWVdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBUYWtlcyBhIHNwZWNpZmllZCBudW1iZXIgb2YgaXRlbXMgZnJvbSB0aGUgcXVlcnkgcmVzdWx0LiBVc2VkIGZvciBwYWdpbmcuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdGFrZVxyXG4gICAgICAgICAqIEBzZWUgW3F1ZXJ5LnNraXBde0BsaW5rIHF1ZXJ5LnNraXB9XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gdGFrZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGFrZTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnRha2UsIFt2YWx1ZV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqIFNldHMgYW4gZXhwYW5kIGV4cHJlc3Npb24gZm9yIHRoZSBjdXJyZW50IHF1ZXJ5LiBUaGlzIGFsbG93cyB5b3UgdG8gcmV0cmlldmUgY29tcGxleCBkYXRhIHNldHMgdXNpbmcgYSBzaW5nbGUgcXVlcnkgYmFzZWQgb24gcmVsYXRpb25zIGJldHdlZW4gZGF0YSB0eXBlcy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBleHBhbmRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZXhwYW5kRXhwcmVzc2lvbiBBbiBbZXhwYW5kIGV4cHJlc3Npb25dKHslIHNsdWcgZmVhdHVyZXMtZGF0YS1yZWxhdGlvbnMtZGVmaW5pbmctZXhwYW5kICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmV4cGFuZCwgW2V4cGFuZEV4cHJlc3Npb25dKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBCdWlsZHMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRpZmZlcmVudCBleHByZXNzaW9ucyB0aGF0IHdpbGwgYmUgc2VudCB0byB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBJdCBiYXNpY2FsbHkgdHJhbnNsYXRlcyBhbnkgcHJldmlvdXNseSBzcGVjaWZpZWQgZXhwcmVzc2lvbnMgaW50byBzdGFuZGFyZCBxdWVyaWVzIHRoYXQge3tzaXRlLmJzfX0gY2FuIHVuZGVyc3RhbmQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgYnVpbGRcclxuICAgICAgICAgKiBAcmV0dXJucyB7eyR3aGVyZSwkc2VsZWN0LCRzb3J0LCRza2lwLCR0YWtlLCRleHBhbmR9fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVlcnlCdWlsZGVyKHRoaXMpLmJ1aWxkKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2ltcGxlOiBmdW5jdGlvbiAob3AsIG9wcnMpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKG9wcnMpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cHIuYWRkT3BlcmFuZChuZXcgRXhwcmVzc2lvbihvcCwgYXJncykpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBRdWVyeTtcclxufSgpKTsiLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBPcGVyYXRvclR5cGUgPSBjb25zdGFudHMuT3BlcmF0b3JUeXBlO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLl87XHJcbnZhciBHZW9Qb2ludCA9IHJlcXVpcmUoJy4uL0dlb1BvaW50Jyk7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBFeHByZXNzaW9uID0gcmVxdWlyZSgnLi4vRXhwcmVzc2lvbicpO1xyXG52YXIgbWF4RGlzdGFuY2VDb25zdHMgPSBjb25zdGFudHMubWF4RGlzdGFuY2VDb25zdHM7XHJcbnZhciByYWRpdXNDb25zdHMgPSBjb25zdGFudHMucmFkaXVzQ29uc3RzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUXVlcnlCdWlsZGVyKHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICAgIHRoaXMuZXhwciA9IHF1ZXJ5LmV4cHI7XHJcbiAgICB9XHJcblxyXG4gICAgUXVlcnlCdWlsZGVyLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvLyBUT0RPIG1lcmdlIHRoZSB0d28gb2JqZWN0cyBiZWZvcmUgcmV0dXJuaW5nIHRoZW1cclxuICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xyXG4gICAgICAgICAgICBpZiAocXVlcnkuZmlsdGVyIHx8IHF1ZXJ5LmZpZWxkcyB8fCBxdWVyeS5zb3J0IHx8IHF1ZXJ5LnRvc2tpcCB8fCBxdWVyeS50b3Rha2UgfHwgcXVlcnkuZXhwYW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICR3aGVyZTogcXVlcnkuZmlsdGVyIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdDogcXVlcnkuZmllbGRzIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgJHNvcnQ6IHF1ZXJ5LnNvcnQgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAkc2tpcDogcXVlcnkudG9za2lwIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRha2U6IHF1ZXJ5LnRvdGFrZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICRleHBhbmQ6IHF1ZXJ5LmV4cGFuZCB8fCBudWxsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAkd2hlcmU6IHRoaXMuX2J1aWxkV2hlcmUoKSxcclxuICAgICAgICAgICAgICAgICRzZWxlY3Q6IHRoaXMuX2J1aWxkU2VsZWN0KCksXHJcbiAgICAgICAgICAgICAgICAkc29ydDogdGhpcy5fYnVpbGRTb3J0KCksXHJcbiAgICAgICAgICAgICAgICAkc2tpcDogdGhpcy5fZ2V0U2tpcCgpLFxyXG4gICAgICAgICAgICAgICAgJHRha2U6IHRoaXMuX2dldFRha2UoKSxcclxuICAgICAgICAgICAgICAgICRleHBhbmQ6IHRoaXMuX2dldEV4cGFuZCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0U2tpcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2tpcEV4cHJlc3Npb24gPSBfLmZpbmQodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5za2lwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNraXBFeHByZXNzaW9uID8gc2tpcEV4cHJlc3Npb24ub3BlcmFuZHNbMF0gOiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFRha2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRha2VFeHByZXNzaW9uID0gXy5maW5kKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUudGFrZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0YWtlRXhwcmVzc2lvbiA/IHRha2VFeHByZXNzaW9uLm9wZXJhbmRzWzBdIDogbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRFeHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGV4cGFuZEV4cHJlc3Npb24gPSBfLmZpbmQodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5leHBhbmQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kRXhwcmVzc2lvbiA/IGV4cGFuZEV4cHJlc3Npb24ub3BlcmFuZHNbMF0gOiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2J1aWxkU2VsZWN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RFeHByZXNzaW9uID0gXy5maW5kKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUuc2VsZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0RXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgXy5yZWR1Y2Uoc2VsZWN0RXhwcmVzc2lvbi5vcGVyYW5kcywgZnVuY3Rpb24gKG1lbW8sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtb1t2YWx1ZV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgICAgICAgICAgICAgfSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2J1aWxkU29ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc29ydEV4cHJlc3Npb25zID0gXy5maWx0ZXIodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5vcmRlciB8fCB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLm9yZGVyX2Rlc2M7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChzb3J0RXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgXy5yZWR1Y2Uoc29ydEV4cHJlc3Npb25zLCBmdW5jdGlvbiAobWVtbywgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1vW3ZhbHVlLm9wZXJhbmRzWzBdXSA9IHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUub3JkZXIgPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICAgICAgICAgICAgICB9LCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYnVpbGRXaGVyZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd2hlcmVFeHByZXNzaW9uID0gXy5maW5kKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUud2hlcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAod2hlcmVFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGQobmV3IEV4cHJlc3Npb24oT3BlcmF0b3JUeXBlLmFuZCwgd2hlcmVFeHByZXNzaW9uLm9wZXJhbmRzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyRXhwcmVzc2lvbiA9IF8uZmluZCh0aGlzLmV4cHIub3BlcmFuZHMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5maWx0ZXI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV4cHJlc3Npb24ub3BlcmFuZHNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2J1aWxkOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaW1wbGUoZXhwcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoZXhwcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZWdleChleHByKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2V4KGV4cHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzR2VvKGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2VvKGV4cHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQW5kKGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5kKGV4cHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzT3IoZXhwcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcihleHByKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc05vdChleHByKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vdChleHByKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzU2ltcGxlOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwci5vcGVyYXRvciA+PSBPcGVyYXRvclR5cGUuZXF1YWwgJiYgZXhwci5vcGVyYXRvciA8PSBPcGVyYXRvclR5cGUuc2l6ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zaW1wbGU6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXJtID0ge30sIGZpZWxkVGVybSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLl90cmFuc2xhdGVvcGVyYXRvcihleHByLm9wZXJhdG9yKTtcclxuICAgICAgICAgICAgaWYgKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtW29wZXJhdG9yXSA9IG9wZXJhbmRzWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGVybSA9IG9wZXJhbmRzWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtvcGVyYW5kc1swXV0gPSB0ZXJtO1xyXG4gICAgICAgICAgICByZXR1cm4gZmllbGRUZXJtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzUmVnZXg6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID49IE9wZXJhdG9yVHlwZS5yZWdleCAmJiBleHByLm9wZXJhdG9yIDw9IE9wZXJhdG9yVHlwZS5lbmRzV2l0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZWdleDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkVGVybSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgcmVnZXggPSB0aGlzLl9nZXRSZWdleChleHByKTtcclxuICAgICAgICAgICAgdmFyIHJlZ2V4VmFsdWUgPSB0aGlzLl9nZXRSZWdleFZhbHVlKHJlZ2V4KTtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgZmllbGRUZXJtW29wZXJhbmRzWzBdXSA9IHJlZ2V4VmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFRlcm07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0UmVnZXg6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gZXhwci5vcGVyYW5kc1sxXTtcclxuICAgICAgICAgICAgdmFyIGZsYWdzID0gZXhwci5vcGVyYW5kc1syXSA/IGV4cHIub3BlcmFuZHNbMl0gOiAnJztcclxuICAgICAgICAgICAgc3dpdGNoIChleHByLm9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5yZWdleDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCA/IHBhdHRlcm4gOiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLnN0YXJ0c1dpdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeXCIgKyBwYXR0ZXJuLCBmbGFncyk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5lbmRzV2l0aDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuICsgXCIkXCIsIGZsYWdzKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vua25vd24gb3BlcmF0b3IgdHlwZS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFJlZ2V4VmFsdWU6IGZ1bmN0aW9uIChyZWdleCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9ICcnO1xyXG4gICAgICAgICAgICBpZiAocmVnZXguZ2xvYmFsKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zICs9ICdnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVnZXgubXVsdGlsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zICs9ICdtJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVnZXguaWdub3JlQ2FzZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyArPSAnaSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHskcmVnZXg6IHJlZ2V4LnNvdXJjZSwgJG9wdGlvbnM6IG9wdGlvbnN9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzR2VvOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwci5vcGVyYXRvciA+PSBPcGVyYXRvclR5cGUubmVhclNocGVyZSAmJiBleHByLm9wZXJhdG9yIDw9IE9wZXJhdG9yVHlwZS53aXRoaW5TaHBlcmU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2VvOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtvcGVyYW5kc1swXV0gPSB0aGlzLl9nZXRHZW9UZXJtKGV4cHIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmllbGRUZXJtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldEdlb1Rlcm06IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwci5vcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUubmVhclNocGVyZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TmVhclNwaGVyZVRlcm0oZXhwcik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS53aXRoaW5Cb3g6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdpdGhpbkJveChleHByKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLndpdGhpblBvbHlnb246XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdpdGhpblBvbHlnb24oZXhwcik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS53aXRoaW5TaHBlcmU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdpdGhpbkNlbnRlclNwaGVyZShleHByKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vua25vd24gb3BlcmF0b3IgdHlwZS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldE5lYXJTcGhlcmVUZXJtOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fZ2V0R2VvUG9pbnQob3BlcmFuZHNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgbWF4RGlzdGFuY2UgPSBvcGVyYW5kc1syXTtcclxuICAgICAgICAgICAgdmFyIG1ldHJpY3MgPSBvcGVyYW5kc1szXTtcclxuICAgICAgICAgICAgdmFyIG1heERpc3RhbmNlQ29uc3Q7XHJcbiAgICAgICAgICAgIHZhciB0ZXJtID0ge1xyXG4gICAgICAgICAgICAgICAgJyRuZWFyU3BoZXJlJzogY2VudGVyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF4RGlzdGFuY2UgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZUNvbnN0ID0gbWF4RGlzdGFuY2VDb25zdHNbbWV0cmljc10gfHwgbWF4RGlzdGFuY2VDb25zdHMucmFkaWFucztcclxuICAgICAgICAgICAgICAgIHRlcm1bbWF4RGlzdGFuY2VDb25zdF0gPSBtYXhEaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRXaXRoaW5Cb3g6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIHZhciBib3R0b21MZWZ0ID0gdGhpcy5fZ2V0R2VvUG9pbnQob3BlcmFuZHNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgdXBwZXJSaWdodCA9IHRoaXMuX2dldEdlb1BvaW50KG9wZXJhbmRzWzJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICckd2l0aGluJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICckYm94JzogW2JvdHRvbUxlZnQsIHVwcGVyUmlnaHRdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0V2l0aGluUG9seWdvbjogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX2dldEdlb1BvaW50cyhvcGVyYW5kc1sxXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnJHdpdGhpbic6IHtcclxuICAgICAgICAgICAgICAgICAgICAnJHBvbHlnb24nOiBwb2ludHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRXaXRoaW5DZW50ZXJTcGhlcmU6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9nZXRHZW9Qb2ludChvcGVyYW5kc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBvcGVyYW5kc1syXTtcclxuICAgICAgICAgICAgdmFyIG1ldHJpY3MgPSBvcGVyYW5kc1szXTtcclxuICAgICAgICAgICAgdmFyIHJhZGl1c0NvbnN0ID0gcmFkaXVzQ29uc3RzW21ldHJpY3NdIHx8IHJhZGl1c0NvbnN0cy5yYWRpYW5zO1xyXG4gICAgICAgICAgICB2YXIgc3BoZXJlSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgICdjZW50ZXInOiBjZW50ZXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc3BoZXJlSW5mb1tyYWRpdXNDb25zdF0gPSByYWRpdXM7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnJHdpdGhpbic6IHtcclxuICAgICAgICAgICAgICAgICAgICAnJGNlbnRlclNwaGVyZSc6IHNwaGVyZUluZm9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRHZW9Qb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdlb1BvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldEdlb1BvaW50czogZnVuY3Rpb24gKHBvaW50cykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfLm1hcChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldEdlb1BvaW50KHBvaW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNBbmQ6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUuYW5kO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FuZDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIHRlcm0sIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3BlcmFuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtID0gdGhpcy5fYnVpbGQob3BlcmFuZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fYW5kQXBwZW5kKHJlc3VsdCwgdGVybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hbmRBcHBlbmQ6IGZ1bmN0aW9uIChhbmRPYmosIG5ld09iaikge1xyXG4gICAgICAgICAgICB2YXIgaSwgbCwga2V5LCB2YWx1ZSwgbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gXy5rZXlzKG5ld09iaik7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gYW5kT2JqW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZE9ialtrZXldID0gbmV3T2JqW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld09ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfLmV4dGVuZCh2YWx1ZSwgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFuZE9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFuZE9iajtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc09yOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwci5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLm9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX29yOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgaSwgbCwgdGVybSwgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBvcGVyYW5kcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRlcm0gPSB0aGlzLl9idWlsZChvcGVyYW5kc1tpXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0ZXJtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyRvcjogcmVzdWx0fTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc05vdDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5ub3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfbm90OiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4geyRub3Q6IHRoaXMuX2J1aWxkKGV4cHIub3BlcmFuZHNbMF0pfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF90cmFuc2xhdGVvcGVyYXRvcjogZnVuY3Rpb24gKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmVxdWFsOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUubm90X2VxdWFsOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJG5lJztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmd0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGd0JztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGx0JztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmd0ZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRndGUnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUubHRlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGx0ZSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5pc2luOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGluJztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLm5vdGluOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJG5pbic7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5hbGw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckYWxsJztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLnNpemU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckc2l6ZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vua25vd24gb3BlcmF0b3IgdHlwZS4nKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBRdWVyeUJ1aWxkZXI7XHJcbn0oKSk7IiwidmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4vRGF0YVF1ZXJ5Jyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLl87XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgUmVxdWVzdE9wdGlvbnNCdWlsZGVyID0ge307XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEVuZHBvaW50VXJsID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBlbmRwb2ludCA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICBpZiAoZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zICYmIGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZCkge1xyXG4gICAgICAgICAgICBlbmRwb2ludCArPSAnLycgKyBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZW5kcG9pbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRCYXNlT2JqZWN0ID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBkZWZhdWx0T2JqZWN0ID0ge1xyXG4gICAgICAgICAgICBlbmRwb2ludDogUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEVuZHBvaW50VXJsKGRhdGFRdWVyeSksXHJcbiAgICAgICAgICAgIGZpbHRlcjogZGF0YVF1ZXJ5LmZpbHRlcixcclxuICAgICAgICAgICAgc3VjY2VzczogZGF0YVF1ZXJ5Lm9uU3VjY2VzcyxcclxuICAgICAgICAgICAgZXJyb3I6IGRhdGFRdWVyeS5vbkVycm9yLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhUXVlcnkuZGF0YSxcclxuICAgICAgICAgICAgaGVhZGVyczogZGF0YVF1ZXJ5LmhlYWRlcnNcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoZGF0YVF1ZXJ5LnBhcnNlKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRPYmplY3QucGFyc2UgPSBkYXRhUXVlcnkucGFyc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGVmYXVsdE9iamVjdDtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZCA9IGZ1bmN0aW9uIChkYXRhUXVlcnksIGFkZGl0aW9uYWxPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRCYXNlT2JqZWN0KGRhdGFRdWVyeSksIGFkZGl0aW9uYWxPcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkQnlJZF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLmNvdW50XSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSArICcvX2NvdW50J1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJhd1VwZGF0ZV0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBkYXRhUXVlcnkuZmlsdGVyO1xyXG4gICAgICAgIHZhciBvZmlsdGVyID0gbnVsbDsgLy8gcmVxdWVzdCBvcHRpb25zIGZpbHRlclxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyOyAvLyBzZW5kIHRoZSBmaWx0ZXIgdGhyb3VnaCBxdWVyeSBzdHJpbmdcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIG9maWx0ZXIgPSBmaWx0ZXI7IC8vIHNlbmQgdGhlIGZpbHRlciBhcyBmaWx0ZXIgaGVhZGVyc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBlbmRwb2ludCxcclxuICAgICAgICAgICAgZmlsdGVyOiBvZmlsdGVyXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGVdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBfLmV4dGVuZChSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkQmFzZU9iamVjdChkYXRhUXVlcnkpLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURSdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZVNpbmdsZV0gPSBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlXTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0QWNsXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgZW5kcG9pbnQgPSBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGRhdGFRdWVyeS5maWx0ZXI7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJykgeyAvLyBpZiBmaWx0ZXIgaXMgc3RyaW5nIHRoYW4gd2lsbCB1cGRhdGUgYSBzaW5nbGUgaXRlbSB1c2luZyB0aGUgZmlsdGVyIGFzIGFuIGlkZW50aWZpZXJcclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcpIHsgLy8gZWxzZSBpZiBpdCBpcyBhbiBvYmplY3QgdGhhbiB3ZSB3aWxsIHVzZSBpdCdzIGlkIHByb3BlcnR5XHJcbiAgICAgICAgICAgIGVuZHBvaW50ICs9ICcvJyArIGZpbHRlcltpZEZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5kcG9pbnQgKz0gJy9fYWNsJztcclxuICAgICAgICB2YXIgbWV0aG9kLCBkYXRhO1xyXG4gICAgICAgIGlmIChkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuYWNsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZCA9ICdERUxFVEUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQVVQnO1xyXG4gICAgICAgICAgICBkYXRhID0gZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmFjbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50LFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5zZXRPd25lcl0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBkYXRhUXVlcnkuZmlsdGVyO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJykgeyAvLyBpZiBmaWx0ZXIgaXMgc3RyaW5nIHRoYW4gd2lsbCB1cGRhdGUgYSBzaW5nbGUgaXRlbSB1c2luZyB0aGUgZmlsdGVyIGFzIGFuIGlkZW50aWZpZXJcclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcpIHsgLy8gZWxzZSBpZiBpdCBpcyBhbiBvYmplY3QgdGhhbiB3ZSB3aWxsIHVzZSBpdCdzIGlkIHByb3BlcnR5XHJcbiAgICAgICAgICAgIGVuZHBvaW50ICs9ICcvJyArIGZpbHRlcltpZEZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5kcG9pbnQgKz0gJy9fb3duZXInO1xyXG5cclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5dID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6ICdvYXV0aC90b2tlbicsXHJcbiAgICAgICAgICAgIGF1dGhIZWFkZXJzOiBmYWxzZSxcclxuICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGVcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dvdXRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogJ29hdXRoL2xvZ291dCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJDaGFuZ2VQYXNzd29yZF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGtlZXBUb2tlbnMgPSBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMua2VlcFRva2VucztcclxuICAgICAgICB2YXIgZW5kcG9pbnQgPSAnVXNlcnMvY2hhbmdlcGFzc3dvcmQnO1xyXG4gICAgICAgIGlmIChrZWVwVG9rZW5zKSB7XHJcbiAgICAgICAgICAgIGVuZHBvaW50ICs9ICc/a2VlcFRva2Vucz10cnVlJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50LFxyXG4gICAgICAgICAgICBhdXRoSGVhZGVyczogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5XaXRoUHJvdmlkZXJdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgYXV0aEhlYWRlcnM6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTGlua1dpdGhQcm92aWRlcl0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEVuZHBvaW50VXJsKGRhdGFRdWVyeSkgKyAnL2xpbmsnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyVW5saW5rRnJvbVByb3ZpZGVyXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkRW5kcG9pbnRVcmwoZGF0YVF1ZXJ5KSArICcvdW5saW5rJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNVcGRhdGVDb250ZW50XSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRFbmRwb2ludFVybChkYXRhUXVlcnkpICsgJy9Db250ZW50J1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNHZXREb3dubG9hZFVybEJ5SWRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXI7XHJcbn0oKSk7IiwidmFyIEV4cHJlc3Npb24gPSByZXF1aXJlKCcuLi9FeHByZXNzaW9uJyk7XHJcbnZhciBPcGVyYXRvclR5cGUgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5PcGVyYXRvclR5cGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBmbHVlbnQgQVBJIG9wZXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBmaWx0ZXIgZm9yIGEgcXVlcnkgYnkgY2hhaW5pbmcgZGlmZmVyZW50IHJ1bGVzLlxyXG4gICAgICogQGNsYXNzIFdoZXJlUXVlcnlcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjZXEgYXMgV2hlcmVRdWVyeSNlcXVhbFxyXG4gICAgICogQGJvcnJvd3MgV2hlcmVRdWVyeSNuZSBhcyBXaGVyZVF1ZXJ5I25vdEVxdWFsXHJcbiAgICAgKiBAYm9ycm93cyBXaGVyZVF1ZXJ5I2d0IGFzIFdoZXJlUXVlcnkjZ3JlYXRlclRoYW5cclxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjZ3RlIGFzIFdoZXJlUXVlcnkjZ3JlYXRlclRoYW5FcXVhbFxyXG4gICAgICogQGJvcnJvd3MgV2hlcmVRdWVyeSNsdCBhcyBXaGVyZVF1ZXJ5I2xlc3NUaGFuXHJcbiAgICAgKiBAYm9ycm93cyBXaGVyZVF1ZXJ5I2x0ZSBhcyBXaGVyZVF1ZXJ5I2xlc3NUaGFuRXF1YWxcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gV2hlcmVRdWVyeShwYXJlbnRRdWVyeSwgZXhwck9wLCBzaW5nbGVPcGVyYW5kKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRRdWVyeTtcclxuICAgICAgICB0aGlzLnNpbmdsZSA9IHNpbmdsZU9wZXJhbmQ7XHJcbiAgICAgICAgdGhpcy5leHByID0gbmV3IEV4cHJlc3Npb24oZXhwck9wIHx8IE9wZXJhdG9yVHlwZS53aGVyZSk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuZXhwci5hZGRPcGVyYW5kKHRoaXMuZXhwcik7XHJcbiAgICB9XHJcblxyXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbiBgYW5kYCBjbGF1c2UgdG8gdGhlIGN1cnJlbnQgY29uZGl0aW9uIGFuZCByZXR1cm5zIGl0IGZvciBmdXJ0aGVyIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2QgYW5kXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVRdWVyeSh0aGlzLCBPcGVyYXRvclR5cGUuYW5kKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW4gYG9yYCBjbGF1c2UgdG8gdGhlIGN1cnJlbnQgY29uZGl0aW9uIGFuZCByZXR1cm5zIGl0IGZvciBmdXJ0aGVyIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2Qgb3JcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcywgT3BlcmF0b3JUeXBlLm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBgbm90YCBjbGF1c2UgdG8gdGhlIGN1cnJlbnQgY29uZGl0aW9uIGFuZCByZXR1cm5zIGl0IGZvciBmdXJ0aGVyIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2Qgbm90XHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbm90OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVRdWVyeSh0aGlzLCBPcGVyYXRvclR5cGUubm90LCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zaW1wbGU6IGZ1bmN0aW9uIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgdGhpcy5leHByLmFkZE9wZXJhbmQobmV3IEV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3MpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvbmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgZXF1YWwgdG8gYSBzcGVjaWZpYyB2YWx1ZS5cclxuICAgICAgICAgKiBAbWV0aG9kIGVxXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0byB3aGljaCB0aGUgZmllbGRzIG11c3QgYmUgZXF1YWwpLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVxOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmVxdWFsLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCAqbm90KiBiZSBlcXVhbCB0byBhIHNwZWNpZmljIHZhbHVlLlxyXG4gICAgICAgICAqIEBtZXRob2QgbmVcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRvIHdoaWNoIHRoZSBmaWVsZCBtdXN0IG5vdCBiZSBlcXVhbCkuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbmU6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUubm90X2VxdWFsLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCBiZSBgZ3JlYXRlciB0aGFuYCBhIGNlcnRhaW4gdmFsdWUuIEFwcGxpY2FibGUgdG8gTnVtYmVyLCBTdHJpbmcsIGFuZCBEYXRlIGZpZWxkcy5cclxuICAgICAgICAgKiBAbWV0aG9kIGd0XHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0aGF0IHRoZSBmaWVsZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuKS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBndDogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5ndCwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgYGdyZWF0ZXIgdGhhbiBvciBlcXVhbGAgdG8gYSBjZXJ0YWluIHZhbHVlLiBBcHBsaWNhYmxlIHRvIE51bWJlciwgU3RyaW5nLCBhbmQgRGF0ZSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBndGVcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8pLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGd0ZTogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5ndGUsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGJlIGBsZXNzIHRoYW5gIGEgY2VydGFpbiB2YWx1ZS4gQXBwbGljYWJsZSB0byBOdW1iZXIsIFN0cmluZywgYW5kIERhdGUgZmllbGRzLlxyXG4gICAgICAgICAqIEBtZXRob2QgbHRcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBsZXNzIHRoYW4pLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx0OiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmx0LCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCBiZSBgbGVzcyB0aGFuIG9yIGVxdWFsYCB0byBhIGNlcnRhaW4gdmFsdWUuIEFwcGxpY2FibGUgdG8gTnVtYmVyLCBTdHJpbmcsIGFuZCBEYXRlIGZpZWxkcy5cclxuICAgICAgICAgKiBAbWV0aG9kIGx0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQ29tcGFyaXNvbiB2YWx1ZSAodGhhdCB0aGUgZmllbGQgc2hvdWxkIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0bykuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbHRlOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmx0ZSwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgaW4gYSBzZXQgb2YgdmFsdWVzLlxyXG4gICAgICAgICAqIEBtZXRob2QgaXNpblxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIEFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgdGhhdCB0aGUgZmllbGQgc2hvdWxkIGJlIGluLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzaW46IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuaXNpbiwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgKm5vdCogYmUgaW4gYSBzZXQgb2YgdmFsdWVzLlxyXG4gICAgICAgICAqIEBtZXRob2Qgbm90aW5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBBbiBhcnJheSBvZiB2YWx1ZXMgdGhhdCB0aGUgZmllbGQgc2hvdWxkIG5vdCBiZSBpbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBub3RpbjogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5ub3RpbiwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgaW5jbHVkZSAqYWxsKiBvZiB0aGUgc3BlY2lmaWVkIHZhbHVlcy4gQXBwbGljYWJsZSB0byBBcnJheSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBhbGxcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBBbiBhcnJheSBvZiB2YWx1ZXMgdGhhdCB0aGUgZmllbGQgbXVzdCBpbmNsdWRlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFsbDogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5hbGwsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGNvbnRhaW4gYW4gYXJyYXkgd2hvc2UgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIGEgc3BlY2lmaWVkIHZhbHVlLiBBcHBsaWNhYmxlIHRvIEFycmF5IGZpZWxkcy5cclxuICAgICAgICAgKiBAbWV0aG9kIHNpemVcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHNpemUgdGhhdCB0aGUgYXJyYXkgbXVzdCBiZSBiaWdnZXIgdGhhbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzaXplOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnNpemUsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IHNhdGlzZnkgYSBzcGVjaWZpZWQgcmVnZXguXHJcbiAgICAgICAgICogQG1ldGhvZCByZWdleFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWd1bGFyRXhwcmVzc2lvbiBSZWd1bGFyIGV4cHJlc3Npb24gaW4gUENSRSBmb3JtYXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zXSBBIHN0cmluZyBvZiByZWdleCBvcHRpb25zIHRvIHVzZS4gU2VlIFtzcGVjc10oe2h0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvcmVnZXgvI29wLl9TX29wdGlvbnN9KSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBhdmFpbGFibGUgb3B0aW9ucy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWdleDogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSwgZmxhZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUucmVnZXgsIGZpZWxkLCB2YWx1ZSwgZmxhZ3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgdmFsdWUgbXVzdCAqc3RhcnQqIHdpdGggYSBzcGVjaWZpZWQgc3RyaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2Qgc3RhcnRzV2l0aFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3RyaW5nIHRoYXQgdGhlIGZpZWxkIHNob3VsZCBzdGFydCB3aXRoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9uc10gQSBzdHJpbmcgb2YgcmVnZXggb3B0aW9ucyB0byB1c2UuIFNlZSBbc3BlY3NdKHtodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L3JlZ2V4LyNvcC5fU19vcHRpb25zfSkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYXZhaWxhYmxlIG9wdGlvbnMuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhcnRzV2l0aDogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSwgZmxhZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuc3RhcnRzV2l0aCwgZmllbGQsIHZhbHVlLCBmbGFncyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCB2YWx1ZSBtdXN0ICplbmQqIHdpdGggYSBzcGVjaWZpZWQgc3RyaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2QgZW5kc1dpdGhcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHN0cmluZyB0aGF0IHRoZSBmaWVsZCBzaG91bGQgZW5kIHdpdGguXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zXSBBIHN0cmluZyBvZiAgcmVnZXggb3B0aW9ucyB0byB1c2UuIFNlZSBbc3BlY3NdKHtodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L3JlZ2V4LyNvcC5fU19vcHRpb25zfSkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYXZhaWxhYmxlIG9wdGlvbnMuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW5kc1dpdGg6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIGZsYWdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmVuZHNXaXRoLCBmaWVsZCwgdmFsdWUsIGZsYWdzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBHZW9zcGF0aWFsIGNvbmRpdGlvbiB0aGF0IGEgc3BlY2lmaWVkIGdlb3BvaW50IG11c3QgYmUgd2l0aGluIGEgY2VydGFpbiBkaXN0YW5jZSBmcm9tIGFub3RoZXIgZ2VvcG9pbnQuIEFwcGxpY2FibGUgdG8gR2VvUG9pbnQgZmllbGRzIG9ubHkuXHJcbiAgICAgICAgICogQG1ldGhvZCBuZWFyU3BoZXJlXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUgY29udGFpbmluZyBhIHtHZW9Qb2ludH0gaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGAoZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlLGRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUpYCwgd2hlcmUgKmRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSogcmFuZ2VzIGZyb20gLTkwIHRvIDkwIGFuZCAqZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSogcmFuZ2VzIGZyb20gLTE4MCB0byAxODAuIEV4YW1wbGU6IGAoNDIuNjk1NDMyMiwxMjMuMzIzOTQ2NylgXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludH0gcG9pbnQgQ29tcGFyaXNvbiBnZW9wb2ludCB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgRGlzdGFuY2UgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRyaWNzPXJhZGlhbnNdIEEgc3RyaW5nIHJlcHJlc2VudGluZyB3aGF0IHVuaXQgb2YgbWVhc3VyZW1lbnQgaXMgdXNlZCBmb3IgZGlzdGFuY2UuIFBvc3NpYmxlIHZhbHVlczogcmFkaWFucywga20sIG1pbGVzLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5lYXJTcGhlcmU6IGZ1bmN0aW9uIChmaWVsZCwgcG9pbnQsIGRpc3RhbmNlLCBtZXRyaWNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLm5lYXJTaHBlcmUsIGZpZWxkLCBwb2ludCwgZGlzdGFuY2UsIG1ldHJpY3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIEdlb3NwYXRpYWwgY29uZGl0aW9uIHRoYXQgYSBzcGVjaWZpZWQgZ2VvcG9pbnQgbXVzdCBiZSB3aXRoaW4gYSBzcGVjaWZpZWQgY29vcmRpbmF0ZSByZWN0YW5nbGUuIEFwcGxpY2FibGUgdG8gR2VvUG9pbnQgZmllbGRzIG9ubHkuXHJcbiAgICAgICAgICogQG1ldGhvZCB3aXRoaW5Cb3hcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZSBjb250YWluaW5nIGEge0dlb1BvaW50fSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogYChkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUsZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSlgLCB3aGVyZSAqZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlKiByYW5nZXMgZnJvbSAtOTAgdG8gOTAgYW5kICpkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKiByYW5nZXMgZnJvbSAtMTgwIHRvIDE4MC4gRXhhbXBsZTogYCg0Mi42OTU0MzIyLDEyMy4zMjM5NDY3KWBcclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZXJsaXZlLkdlb1BvaW50fSBwb2ludEJvdHRvbUxlZnQgVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGJveC5cclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZXJsaXZlLkdlb1BvaW50fSBwb2ludFVwcGVyUmlnaHQgVmFsdWUgcmVwcmVzZW50aW5nIHRoZSB1cHBlciByaWdodCBjb3JuZXIgb2YgdGhlIGJveC5cclxuICAgICAgICAgKiBAZXhhbXBsZSBgYGBqc1xyXG4gICAgICAgICB2YXIgcXVlcnkgPSBuZXcgRXZlcmxpdmUuUXVlcnkoKTtcclxuICAgICAgICAgcXVlcnkud2hlcmUoKS53aXRoaW5Cb3goJ0xvY2F0aW9uJyxcclxuICAgICAgICAgbmV3IEV2ZXJsaXZlLkdlb1BvaW50KDIzLjMxNzg3MSwgNDIuNjg3NzA5KSxcclxuICAgICAgICAgbmV3IEV2ZXJsaXZlLkdlb1BvaW50KDIzLjMzMTM0NiwgNDIuNzA3MDc1KSk7XHJcbiAgICAgICAgIGBgYFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpdGhpbkJveDogZnVuY3Rpb24gKGZpZWxkLCBwb2ludEJvdHRvbUxlZnQsIHBvaW50VXBwZXJSaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS53aXRoaW5Cb3gsIGZpZWxkLCBwb2ludEJvdHRvbUxlZnQsIHBvaW50VXBwZXJSaWdodCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgR2Vvc3BhdGlhbCBjb25kaXRpb24gdGhhdCBhIHNwZWNpZmllZCBnZW9wb2ludCBtdXN0IGJlIHdpdGhpbiBhIHNwZWNpZmllZCBjb29yZGluYXRlIHBvbHlnb24uIFRoZSBwb2x5Z29uIGlzIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBnZW9wb2ludHMuIFRoZSBsYXN0IHBvaW50IGluIHRoZSBhcnJheSBpcyBpbXBsaWNpdGx5IGNvbm5lY3RlZCB0byB0aGUgZmlyc3QgcG9pbnQgdGh1cyBjbG9zaW5nIHRoZSBzaGFwZS4gQXBwbGljYWJsZSB0byBHZW9Qb2ludCBmaWVsZHMgb25seS5cclxuICAgICAgICAgKiBAbWV0aG9kIHdpdGhpblBvbHlnb25cclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZSBjb250YWluaW5nIGEge0dlb1BvaW50fSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogYChkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUsZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSlgLCB3aGVyZSAqZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlKiByYW5nZXMgZnJvbSAtOTAgdG8gOTAgYW5kICpkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKiByYW5nZXMgZnJvbSAtMTgwIHRvIDE4MC4gRXhhbXBsZTogYCg0Mi42OTU0MzIyLDEyMy4zMjM5NDY3KWBcclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZXJsaXZlLkdlb1BvaW50W119IHBvaW50cyBDb21wYXJpc29uIHZhbHVlIGluIHRoZSBmb3JtIG9mIGFuIGFycmF5IG9mIGdlb3BvaW50cyBkZWZpbmluZyB0aGUgcG9seWdvbi5cclxuICAgICAgICAgKiBAZXhhbXBsZSBgYGBqc1xyXG4gICAgICAgICB2YXIgcG9pbnQxID0gbmV3IEV2ZXJsaXZlLkdlb1BvaW50KDIzLjMxNzg3MSwgNDIuNjg3NzA5KTtcclxuICAgICAgICAgdmFyIHBvaW50MiA9IG5ldyBFdmVybGl2ZS5HZW9Qb2ludCg0Mi42OTg3NDksIDQyLjY5ODc0OSk7XHJcbiAgICAgICAgIHZhciBwb2ludDMgPSBuZXcgRXZlcmxpdmUuR2VvUG9pbnQoMjMuMzMxMzQ2LCA0Mi43MDIyODIpO1xyXG5cclxuICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IEV2ZXJsaXZlLlF1ZXJ5KCk7XHJcbiAgICAgICAgIHF1ZXJ5LndoZXJlKCkud2l0aGluUG9seWdvbihcImxvY2F0aW9uXCIsIFtwb2ludDEsIHBvaW50MiwgcG9pbnQzXSk7XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2l0aGluUG9seWdvbjogZnVuY3Rpb24gKGZpZWxkLCBwb2ludHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUud2l0aGluUG9seWdvbiwgZmllbGQsIHBvaW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgR2Vvc3BhdGlhbCBjb25kaXRpb24gdGhhdCBhIHNwZWNpZmllZCBnZW9wb2ludCBtdXN0IGJlIHdpdGhpbiBhIGNvb3JkaW5hdGUgY2lyY2xlLiBBcHBsaWNhYmxlIHRvIEdlb1BvaW50IGZpZWxkcyBvbmx5LlxyXG4gICAgICAgICAqIEBtZXRob2Qgd2l0aGluQ2VudGVyU3BoZXJlXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUgY29udGFpbmluZyBhIHtHZW9Qb2ludH0gaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGAoZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlLGRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUpYCwgd2hlcmUgKmRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSogcmFuZ2VzIGZyb20gLTkwIHRvIDkwIGFuZCAqZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSogcmFuZ2VzIGZyb20gLTE4MCB0byAxODAuIEV4YW1wbGU6IGAoNDIuNjk1NDMyMiwxMjMuMzIzOTQ2NylgXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludH0gY2VudGVyIENvbXBhcmlzb24gdmFsdWUgc3BlY2lmeWluZyB0aGUgY2VudGVyIG9mIHRoZSBjb29yZGluYXRlIGNpcmNsZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFZhbHVlIHNwZWNpZnlpbmcgdGhlIHJhZGl1cyBsZW5ndGguXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRyaWNzPXJhZGlhbnNdIEEgc3RyaW5nIHJlcHJlc2VudGluZyB3aGF0IHVuaXQgb2YgbWVhc3VyZW1lbnQgaXMgdXNlZCBmb3IgcmFkaXVzIGxlbmd0aC4gUG9zc2libGUgdmFsdWVzOiByYWRpYW5zLCBrbSwgbWlsZXMuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2l0aGluQ2VudGVyU3BoZXJlOiBmdW5jdGlvbiAoZmllbGQsIGNlbnRlciwgcmFkaXVzLCBtZXRyaWNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLndpdGhpblNocGVyZSwgZmllbGQsIGNlbnRlciwgcmFkaXVzLCBtZXRyaWNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuZHMgdGhlIGRlZmluaXRpb24gb2YgdGhlIGN1cnJlbnQgV2hlcmVRdWVyeS4gWW91IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBpbiBvcmRlciB0byBjb250aW51ZSB3aXRoIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBwYXJlbnQgYFF1ZXJ5YC4gQWxsIG90aGVyIGBXaGVyZVF1ZXJ5YCBtZXRob2RzIHJldHVybiB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiBgV2hlcmVRdWVyeWAgdG8gYWxsb3cgY2hhaW5pbmcuXHJcbiAgICAgICAgICogQG1ldGhvZCBkb25lXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgV2hlcmVRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Ll9kb25lKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9kb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpbmdsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlLmVxdWFsID0gV2hlcmVRdWVyeS5wcm90b3R5cGUuZXE7XHJcbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5ub3RFcXVhbCA9IFdoZXJlUXVlcnkucHJvdG90eXBlLm5lO1xyXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5ndDtcclxuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlLmdyZWF0ZXJUaGFuRXF1YWwgPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5ndGU7XHJcbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5sZXNzVGhhbiA9IFdoZXJlUXVlcnkucHJvdG90eXBlLmx0O1xyXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUubGVzc1RoYW5FcXVhbCA9IFdoZXJlUXVlcnkucHJvdG90eXBlLmx0ZTtcclxuXHJcbiAgICByZXR1cm4gV2hlcmVRdWVyeTtcclxufSgpKTsiLCJ2YXIgYnVpbGRQcm9taXNlID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5idWlsZFByb21pc2U7XHJcbnZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9EYXRhUXVlcnknKTtcclxudmFyIFJlcXVlc3RPcHRpb25zQnVpbGRlciA9IHJlcXVpcmUoJy4uL3F1ZXJ5L1JlcXVlc3RPcHRpb25zQnVpbGRlcicpO1xyXG52YXIgcnN2cCA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLnJzdnA7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgaWRGaWVsZCA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLmlkRmllbGQ7XHJcbnZhciBFdmVybGl2ZSA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlJyk7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIG1lcmdlUmVzdWx0RGF0YShkYXRhLCBzdWNjZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXMsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHJlcy5yZXN1bHQ7XHJcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIGtlbmRvIG9ic2VydmFibGUgYXJyYXlcclxuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShkYXRhKSB8fCB0eXBlb2YgZGF0YS5sZW5ndGggPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goZGF0YSwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXy5leHRlbmQoaXRlbSwgYXR0cnNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgXy5leHRlbmQoZGF0YSwgYXR0cnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdWNjZXNzKHJlcywgcmVzcG9uc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWVyZ2VVcGRhdGVSZXN1bHREYXRhKGRhdGEsIHN1Y2Nlc3MpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRBdCA9IHJlcy5Nb2RpZmllZEF0O1xyXG4gICAgICAgICAgICBkYXRhLk1vZGlmaWVkQXQgPSBtb2RpZmllZEF0O1xyXG4gICAgICAgICAgICBzdWNjZXNzKHJlcyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBEYXRhXHJcbiAgICAgKiBAY2xhc3NkZXNjIEEgY2xhc3MgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciBhbGwgQ1JVRCBvcGVyYXRpb25zIHRvIGEgZ2l2ZW4ge3tzaXRlLmJzfX0gZGF0YSB0eXBlLiBDb3ZlcnMgYWR2YW5jZWQgc2NlbmFyaW9zIHdpdGggY3VzdG9tIGhlYWRlcnMgYW5kIHNwZWNpYWwgc2VydmVyLXNpZGUgZnVuY3Rpb25hbGl0eS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR1cFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25OYW1lXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIERhdGEoc2V0dXAsIGNvbGxlY3Rpb25OYW1lLCBvZmZsaW5lU3RvcmFnZSkge1xyXG4gICAgICAgIHRoaXMuc2V0dXAgPSBzZXR1cDtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9mZmxpbmVTdG9yYWdlID0gb2ZmbGluZVN0b3JhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgRGF0YS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX2lzT25saW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZmxpbmVTdG9yYWdlID8gdGhpcy5vZmZsaW5lU3RvcmFnZS5pc09ubGluZSgpIDogdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRPZmZsaW5lQ3JlYXRlRGF0YTogZnVuY3Rpb24gKHF1ZXJ5LCByZXF1ZXN0UmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdmFyIGNyZWF0ZURhdGE7XHJcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocXVlcnkuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZURhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnkuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RUb0NyZWF0ZSA9IF8uZXh0ZW5kKHF1ZXJ5LmRhdGFbaV0sIHJlcXVlc3RSZXNwb25zZS5yZXN1bHRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZURhdGEucHVzaChvYmplY3RUb0NyZWF0ZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZURhdGEgPSBfLmV4dGVuZChxdWVyeS5kYXRhLCByZXF1ZXN0UmVzcG9uc2UucmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZURhdGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0T3BlcmF0aW9uUGFyYW1ldGVyczogZnVuY3Rpb24gX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJncykge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdW5kZWZpbmVkLCAvL18uZGVmYXVsdHMgZmlsbHMgaW4gb25seSB1bmRlZmluZWQgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgd29ya09mZmxpbmU6ICF0aGlzLl9pc09ubGluZSgpLFxyXG4gICAgICAgICAgICAgICAgYXBwbHlPZmZsaW5lOiB0cnVlXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvL3RoZSBjYXNlIHdoZW4gd2UgaGF2ZSBvbmUgb3IgdHdvIGNhbGxiYWNrcyBpbiB0aGUgYXJndW1lbnRzOlxyXG4gICAgICAgICAgICAvL1t7fSwgZnVuY3Rpb24gc3VjY2Vzc3t9XTsgW3t9LCBmdW5jdGlvbiBzdWNjZXNze30sIGZ1bmN0aW9uIGVycm9ye31dO1xyXG4gICAgICAgICAgICB2YXIgbGFzdEFyZ3VtZW50cyA9IF8ubGFzdChhcmdzLCAyKTtcclxuICAgICAgICAgICAgdmFyIGZpcnN0QXJnID0gbGFzdEFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgdmFyIGxhc3RBcmcgPSBsYXN0QXJndW1lbnRzWzFdIHx8IGZpcnN0QXJnO1xyXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGxhc3RBcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGZpcnN0QXJnKSkgeyAvL3dlIGhhdmUgdHdvIGNhbGxiYWNrcyAtIHN1Y2Nlc3MgYW5kIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnN1Y2Nlc3MgPSBmaXJzdEFyZztcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXJyb3IgPSBsYXN0QXJnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy93ZSBoYXZlIG9ubHkgb25lIGNhbGxiYWNrIC0gc3VjY2VzcywgZXJyb3Igc2hvdWxkIGJlIHtub29wfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zdWNjZXNzID0gbGFzdEFyZztcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXJyb3IgPSBfLm5vb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChsYXN0QXJnKSAmJiBhcmdzLmxlbmd0aCA+IDEpIHsgLy93ZSBoYXZlIGEgY29uZmlndXJhdGlvbiBvYmplY3QgaW4gdGhlIGZvcm1hdCBvZiB7cGFyYW1zfVxyXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gXy5leHRlbmQocGFyYW1zLCBsYXN0QXJnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hcHBseU9mZmxpbmU6IGZ1bmN0aW9uIChxdWVyeSwgcmVxdWVzdFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBhdXRvU3luY0VuYWJsZWQgPSB0aGlzLm9mZmxpbmVTdG9yYWdlICYmIHRoaXMub2ZmbGluZVN0b3JhZ2Uuc2V0dGluZ3MuYXV0b1N5bmM7XHJcbiAgICAgICAgICAgIGlmIChhdXRvU3luY0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocXVlcnkub3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZEJ5SWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW5jUmVhZFF1ZXJ5ID0gbmV3IERhdGFRdWVyeShfLmRlZmF1bHRzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlcXVlc3RSZXNwb25zZS5yZXN1bHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N5bmM6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcXVlcnkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmbGluZVN0b3JhZ2UuY3JlYXRlKHN5bmNSZWFkUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlRGF0YSA9IHRoaXMuX2dldE9mZmxpbmVDcmVhdGVEYXRhKHF1ZXJ5LCByZXF1ZXN0UmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KF8uZGVmYXVsdHMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3JlYXRlRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3luYzogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBxdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5jcmVhdGUoY3JlYXRlUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LmlzU3luYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZmxpbmVTdG9yYWdlLnByb2Nlc3NRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGFkZGl0aW9uYWwgbm9uLXN0YW5kYXJkIEhUVFAgaGVhZGVycyBpbiB0aGUgY3VycmVudCBkYXRhIHJlcXVlc3QuIFNlZSBbTGlzdCBvZiBOb24tU3RhbmRhcmQgSFRUUCBIZWFkZXJzXXt7JSBzbHVnIHJlc3QtYXBpLWhlYWRlcnN9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGhlYWRlcnMgQWRkaXRpb25hbCBoZWFkZXJzIHRvIGJlIHNlbnQgd2l0aCB0aGUgZGF0YSByZXF1ZXN0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtEYXRhfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpdGhIZWFkZXJzOiBmdW5jdGlvbiAoaGVhZGVycykge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gXy5leHRlbmQob3B0aW9ucy5oZWFkZXJzIHx8IHt9LCBoZWFkZXJzKTtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGFuIGV4cGFuZCBleHByZXNzaW9uIHRvIGJlIHVzZWQgaW4gdGhlIGRhdGEgcmVxdWVzdC4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIGNvbXBsZXggZGF0YSBzZXRzIHVzaW5nIGEgc2luZ2xlIHF1ZXJ5IGJhc2VkIG9uIHJlbGF0aW9ucyBiZXR3ZWVuIGRhdGEgdHlwZXMuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBleHBhbmRFeHByZXNzaW9uIEFuIFtleHBhbmQgZXhwcmVzc2lvbl0oeyUgc2x1ZyBmZWF0dXJlcy1kYXRhLXJlbGF0aW9ucy1kZWZpbmluZy1leHBhbmQgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICB2YXIgZXhwYW5kSGVhZGVyID0ge1xyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtRXhwYW5kJzogSlNPTi5zdHJpbmdpZnkoZXhwYW5kRXhwcmVzc2lvbilcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2l0aEhlYWRlcnMoZXhwYW5kSGVhZGVyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9jZXNzZXMgYSBxdWVyeSB3aXRoIGFsbCBvZiBpdHMgb3B0aW9ucy4gQXBwbGllcyB0aGUgb3BlcmF0aW9uIG9ubGluZS9vZmZsaW5lXHJcbiAgICAgICAgICogQHBhcmFtIHtEYXRhUXVlcnl9IHF1ZXJ5IFRoZSBxdWVyeSB0byBwcm9jZXNzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJvY2Vzc0RhdGFRdWVyeTogZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5LmhlYWRlcnMgPSB0aGlzLm9wdGlvbnMuaGVhZGVycztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGlmICgoIXF1ZXJ5LmlzU3luYyAmJiB0aGlzLm9mZmxpbmVTdG9yYWdlICYmIHRoaXMub2ZmbGluZVN0b3JhZ2UuaXNTeW5jaHJvbml6aW5nKCkpIHx8IHF1ZXJ5LnNraXBTeW5jQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5Lm9uRXJyb3IuY2FsbCh0aGlzLCByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcnMuc3luY0luUHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFxdWVyeS53b3JrT2ZmbGluZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsU3VjY2VzcyA9IHF1ZXJ5Lm9uU3VjY2VzcztcclxuICAgICAgICAgICAgICAgIHF1ZXJ5Lm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmFwcGx5T2ZmbGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fYXBwbHlPZmZsaW5lKHF1ZXJ5LCBkYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3VjY2Vzcy5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vbkVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxTdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGdldFJlcXVlc3RPcHRpb25zRnJvbVF1ZXJ5ID0gUmVxdWVzdE9wdGlvbnNCdWlsZGVyW3F1ZXJ5Lm9wZXJhdGlvbl07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSBnZXRSZXF1ZXN0T3B0aW9uc0Zyb21RdWVyeShxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHRoaXMuc2V0dXAsIHJlcXVlc3RPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeS5hcHBseU9mZmxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnkub25FcnJvci5jYWxsKHRoaXMsIG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgYXBwbHlPZmZsaW5lIG11c3QgYmUgZmFsc2Ugd2hlbiB3b3JraW5nIG9mZmxpbmUuJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYub2ZmbGluZVN0b3JhZ2UucHJvY2Vzc1F1ZXJ5KHF1ZXJ5KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeS5vblN1Y2Nlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeS5vbkVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgb3B0aW9uczogeyByZXF1ZXN0U2V0dGluZ3M6IHsgZXhlY3V0ZVNlcnZlckNvZGU6IGZhbHNlIH0gfS4gcG93ZXIgZmllbGRzIHF1ZXJpZXMgY291bGQgYmUgYWRkZWQgdG8gdGhhdCBvcHRpb25zIGFyZ3VtZW50XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbGwgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBhIHN1YnNldCBvZiB0aGUgaXRlbXMgYmFzZWQgb24gdmFyaW91cyBmaWx0ZXJpbmcgY3JpdGVyaWEuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRcclxuICAgICAgICAgKiBAbmFtZSBnZXRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbGwgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBhIHN1YnNldCBvZiB0aGUgaXRlbXMgYmFzZWQgb24gdmFyaW91cyBmaWx0ZXJpbmcgY3JpdGVyaWEuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRcclxuICAgICAgICAgKiBAbmFtZSBnZXRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb25QYXJhbWV0ZXJzIEFuIG9iamVjdCB3aGljaCBhY2NlcHRzIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLndvcmtPZmZsaW5lXSBXaGV0aGVyIHRvIGludm9rZSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBvZmZsaW5lIHN0b3JhZ2UuIERlZmF1bHQgaXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgbW9kZSBvZiB0aGUgRXZlcmxpdmUgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5hcHBseU9mZmxpbmU9dHJ1ZV0gSWYgd29ya2luZyBvbmxpbmUsIHdoZXRoZXIgdG8gYWxzbyBhcHBseSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBsb2NhbCBzdG9yYWdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGZpbHRlciwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzQ2IsIGVycm9yQ2IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzQ2IsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JDYlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhUXVlcnkuc2V0T3B0aW9ucyhvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIH0sIG9wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzcywgb3BlcmF0aW9uUGFyYW1ldGVycy5lcnJvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBUT0RPIGhhbmRsZSBvcHRpb25zXHJcbiAgICAgICAgLy8gVE9ETyB0aGluayB0byBwYXNzIHRoZSBpZCBhcyBhIGZpbHRlclxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgZGF0YSBpdGVtIGJ5IElELlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0QnlJZFxyXG4gICAgICAgICAqIEBuYW1lIGdldEJ5SWRcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGFuIGl0ZW0gYnkgSUQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRCeUlkXHJcbiAgICAgICAgICogQG5hbWUgZ2V0QnlJZFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0aW9uUGFyYW1ldGVycyBBbiBvYmplY3Qgd2hpY2ggYWNjZXB0cyBvcGVyYXRpb24gcGFyYW1ldGVyc1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5lcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy53b3JrT2ZmbGluZV0gV2hldGhlciB0byBpbnZva2UgdGhlIG9wZXJhdGlvbiBvbiB0aGUgb2ZmbGluZSBzdG9yYWdlLiBEZWZhdWx0IGlzIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIEV2ZXJsaXZlIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuYXBwbHlPZmZsaW5lPXRydWVdIElmIHdvcmtpbmcgb25saW5lLCB3aGV0aGVyIHRvIGFsc28gYXBwbHkgdGhlIG9wZXJhdGlvbiBvbiB0aGUgbG9jYWwgc3RvcmFnZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRCeUlkOiBmdW5jdGlvbiAoaWQsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkQnlJZCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2Vzc0NiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yQ2JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGRhdGFRdWVyeS5zZXRPcHRpb25zKG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzLCBvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjb3VudCBvZiB0aGUgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBjb3VudFxyXG4gICAgICAgICAqIEBuYW1lIGNvdW50XHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNvdW50IG9mIHRoZSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBjb3VudFxyXG4gICAgICAgICAqIEBuYW1lIGNvdW50XHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0aW9uUGFyYW1ldGVycyBBbiBvYmplY3Qgd2hpY2ggYWNjZXB0cyBvcGVyYXRpb24gcGFyYW1ldGVyc1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5lcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy53b3JrT2ZmbGluZV0gV2hldGhlciB0byBpbnZva2UgdGhlIG9wZXJhdGlvbiBvbiB0aGUgb2ZmbGluZSBzdG9yYWdlLiBEZWZhdWx0IGlzIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIEV2ZXJsaXZlIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuYXBwbHlPZmZsaW5lPXRydWVdIElmIHdvcmtpbmcgb25saW5lLCB3aGV0aGVyIHRvIGFsc28gYXBwbHkgdGhlIG9wZXJhdGlvbiBvbiB0aGUgbG9jYWwgc3RvcmFnZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb3VudDogZnVuY3Rpb24gKGZpbHRlciwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNlc3NDYiwgZXJyb3JDYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNlc3NDYixcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvckNiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRhdGFRdWVyeS5zZXRPcHRpb25zKG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3MsIG9wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAgICAgKiBAbmFtZSBjcmVhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gZGF0YSBJdGVtIG9yIGl0ZW1zIHRoYXQgd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgICAgICogQG5hbWUgY3JlYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGRhdGEgVGhlIGl0ZW0gb3IgaXRlbXMgdGhhdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvblBhcmFtZXRlcnMgQW4gb2JqZWN0IHdoaWNoIGFjY2VwdHMgb3BlcmF0aW9uIHBhcmFtZXRlcnNcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMud29ya09mZmxpbmVdIFdoZXRoZXIgdG8gaW52b2tlIHRoZSBvcGVyYXRpb24gb24gdGhlIG9mZmxpbmUgc3RvcmFnZS4gRGVmYXVsdCBpcyBiYXNlZCBvbiB0aGUgY3VycmVudCBtb2RlIG9mIHRoZSBFdmVybGl2ZSBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmFwcGx5T2ZmbGluZT10cnVlXSBJZiB3b3JraW5nIG9ubGluZSwgd2hldGhlciB0byBhbHNvIGFwcGx5IHRoZSBvcGVyYXRpb24gb24gdGhlIGxvY2FsIHN0b3JhZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoZGF0YSwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBtZXJnZVJlc3VsdERhdGEoZGF0YSwgc3VjY2VzcyksXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGRhdGFRdWVyeS5zZXRPcHRpb25zKG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzLCBvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIG9iamVjdHMgdGhhdCBtYXRjaCBhIGZpbHRlciB3aXRoIHRoZSBzcGVjaWZpZWQgdXBkYXRlIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByYXdVcGRhdGVcclxuICAgICAgICAgKiBAbmFtZSByYXdVcGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlT2JqZWN0IFVwZGF0ZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHZhbHVlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBhbGwgb2JqZWN0cyB0aGF0IG1hdGNoIGEgZmlsdGVyIHdpdGggdGhlIHNwZWNpZmllZCB1cGRhdGUgZXhwcmVzc2lvbi5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHJhd1VwZGF0ZVxyXG4gICAgICAgICAqIEBuYW1lIHJhd1VwZGF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1cGRhdGVPYmplY3QgVXBkYXRlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgdmFsdWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvblBhcmFtZXRlcnMgQW4gb2JqZWN0IHdoaWNoIGFjY2VwdHMgb3BlcmF0aW9uIHBhcmFtZXRlcnNcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMud29ya09mZmxpbmVdIFdoZXRoZXIgdG8gaW52b2tlIHRoZSBvcGVyYXRpb24gb24gdGhlIG9mZmxpbmUgc3RvcmFnZS4gRGVmYXVsdCBpcyBiYXNlZCBvbiB0aGUgY3VycmVudCBtb2RlIG9mIHRoZSBFdmVybGl2ZSBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmFwcGx5T2ZmbGluZT10cnVlXSBJZiB3b3JraW5nIG9ubGluZSwgd2hldGhlciB0byBhbHNvIGFwcGx5IHRoZSBvcGVyYXRpb24gb24gdGhlIGxvY2FsIHN0b3JhZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBhbiBvYmplY3QgYnkgSUQgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBleHByZXNzaW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgcmF3VXBkYXRlXHJcbiAgICAgICAgICogQG5hbWUgcmF3VXBkYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHVwZGF0ZWRPYmplY3QgVXBkYXRlZCBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHZhbHVlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSBpdGVtLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBhbiBvYmplY3QgYnkgSUQgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBleHByZXNzaW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgcmF3VXBkYXRlXHJcbiAgICAgICAgICogQG5hbWUgcmF3VXBkYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHVwZGF0ZU9iamVjdCBVcGRhdGVkIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgdmFsdWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvblBhcmFtZXRlcnMgQW4gb2JqZWN0IHdoaWNoIGFjY2VwdHMgb3BlcmF0aW9uIHBhcmFtZXRlcnNcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMud29ya09mZmxpbmVdIFdoZXRoZXIgdG8gaW52b2tlIHRoZSBvcGVyYXRpb24gb24gdGhlIG9mZmxpbmUgc3RvcmFnZS4gRGVmYXVsdCBpcyBiYXNlZCBvbiB0aGUgY3VycmVudCBtb2RlIG9mIHRoZSBFdmVybGl2ZSBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmFwcGx5T2ZmbGluZT10cnVlXSBJZiB3b3JraW5nIG9ubGluZSwgd2hldGhlciB0byBhbHNvIGFwcGx5IHRoZSBvcGVyYXRpb24gb24gdGhlIGxvY2FsIHN0b3JhZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmF3VXBkYXRlOiBmdW5jdGlvbiAoYXR0cnMsIGZpbHRlciwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmF3VXBkYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGF0dHJzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhUXVlcnkuc2V0T3B0aW9ucyhvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzLCBvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoZXJlIGlzIGEgY2FzZSBpbiB3aGljaCByZXBsYWNlID0gdHJ1ZSBpcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvblxyXG4gICAgICAgIF91cGRhdGU6IGZ1bmN0aW9uIChhdHRycywgZmlsdGVyLCBzaW5nbGUsIHJlcGxhY2UsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge307XHJcbiAgICAgICAgICAgICAgICBkYXRhW3JlcGxhY2UgPyAnJHJlcGxhY2UnIDogJyRzZXQnXSA9IGF0dHJzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB1cGRhdGUgaXMgZm9yIGEgc2luZ2xlIGl0ZW0gLSBtZXJnZSB0aGUgdXBkYXRlIHJlc3VsdCBhbmQgYWRkIHRoZSBNb2RpZmllZEF0IGZpZWxkIHRvIHRoZSByZXN1bHRcclxuICAgICAgICAgICAgICAgIHZhciBvblN1Y2Nlc3MgPSBzaW5nbGUgPyBtZXJnZVVwZGF0ZVJlc3VsdERhdGEoYXR0cnMsIHN1Y2Nlc3MpIDogc3VjY2VzcztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy51cGRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogc2luZ2xlID8gYXR0cnNbaWRGaWVsZF0gOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogb25TdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRhdGFRdWVyeS5zZXRPcHRpb25zKG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3MsIG9wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYSBzaW5nbGUgZGF0YSBpdGVtLiBUaGlzIG9wZXJhdGlvbiB0YWtlcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYm90aCB0aGUgZGF0YSBpdGVtIHRvIGJlIHVwZGF0ZWQgYW5kIHRoZSB1cGRhdGVkIHZhbHVlcy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVNpbmdsZVxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVNpbmdsZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgd2lsbCBiZSB1cGRhdGVkLiBOb3RlOiB0aGUgSUQgcHJvcGVydHkgb2YgdGhlIGl0ZW0gd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBpdGVtIHdpbGwgYmUgdXBkYXRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHByb3ZpZGVkIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVTaW5nbGVcclxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVTaW5nbGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbW9kZWwgVGhlIGl0ZW0gdGhhdCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSB1cGRhdGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb25QYXJhbWV0ZXJzIEFuIG9iamVjdCB3aGljaCBhY2NlcHRzIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLndvcmtPZmZsaW5lXSBXaGV0aGVyIHRvIGludm9rZSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBvZmZsaW5lIHN0b3JhZ2UuIERlZmF1bHQgaXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgbW9kZSBvZiB0aGUgRXZlcmxpdmUgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5hcHBseU9mZmxpbmU9dHJ1ZV0gSWYgd29ya2luZyBvbmxpbmUsIHdoZXRoZXIgdG8gYWxzbyBhcHBseSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBsb2NhbCBzdG9yYWdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZVNpbmdsZTogZnVuY3Rpb24gKG1vZGVsLCBvcGVyYXRpb25QYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUobW9kZWwsIG51bGwsIHRydWUsIGZhbHNlLCBvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGFsbCBpdGVtcyB0aGF0IG1hdGNoIGEgZmlsdGVyIHdpdGggdGhlIHNwZWNpZmllZCB1cGRhdGUgb2JqZWN0LlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHVwZGF0ZU9iamVjdCBUaGUgdXBkYXRlIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBhbGwgaXRlbXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyIHdpdGggdGhlIHNwZWNpZmllZCB1cGRhdGUgb2JqZWN0LlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsIFRoZSB1cGRhdGUgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvblBhcmFtZXRlcnMgQW4gb2JqZWN0IHdoaWNoIGFjY2VwdHMgb3BlcmF0aW9uIHBhcmFtZXRlcnNcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMud29ya09mZmxpbmVdIFdoZXRoZXIgdG8gaW52b2tlIHRoZSBvcGVyYXRpb24gb24gdGhlIG9mZmxpbmUgc3RvcmFnZS4gRGVmYXVsdCBpcyBiYXNlZCBvbiB0aGUgY3VycmVudCBtb2RlIG9mIHRoZSBFdmVybGl2ZSBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmFwcGx5T2ZmbGluZT10cnVlXSBJZiB3b3JraW5nIG9ubGluZSwgd2hldGhlciB0byBhbHNvIGFwcGx5IHRoZSBvcGVyYXRpb24gb24gdGhlIGxvY2FsIHN0b3JhZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobW9kZWwsIGZpbHRlciwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKG1vZGVsLCBmaWx0ZXIsIGZhbHNlLCBmYWxzZSwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZGVzdHJveTogZnVuY3Rpb24gKGF0dHJzLCBmaWx0ZXIsIHNpbmdsZSwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogc2luZ2xlID8gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlIDogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvcixcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogc2luZ2xlID8gYXR0cnNbaWRGaWVsZF0gOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRhdGFRdWVyeS5zZXRPcHRpb25zKG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3MsIG9wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZXMgYSBzaW5nbGUgZGF0YSBpdGVtIGJ5IElELlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVNpbmdsZVxyXG4gICAgICAgICAqIEBuYW1lIGRlc3Ryb3lTaW5nbGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBPYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSBJRCB0byBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIHNpbmdsZSBkYXRhIGl0ZW0gYnkgSUQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBkZXN0cm95U2luZ2xlXHJcbiAgICAgICAgICogQG5hbWUgZGVzdHJveVNpbmdsZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCBPYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSBJRCB0byBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb25QYXJhbWV0ZXJzIEFuIG9iamVjdCB3aGljaCBhY2NlcHRzIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLndvcmtPZmZsaW5lXSBXaGV0aGVyIHRvIGludm9rZSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBvZmZsaW5lIHN0b3JhZ2UuIERlZmF1bHQgaXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgbW9kZSBvZiB0aGUgRXZlcmxpdmUgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5hcHBseU9mZmxpbmU9dHJ1ZV0gSWYgd29ya2luZyBvbmxpbmUsIHdoZXRoZXIgdG8gYWxzbyBhcHBseSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBsb2NhbCBzdG9yYWdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlc3Ryb3lTaW5nbGU6IGZ1bmN0aW9uIChtb2RlbCwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzdHJveShtb2RlbCwgbnVsbCwgdHJ1ZSwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhbGwgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIGEgZmlsdGVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICAgICAqIEBuYW1lIGRlc3Ryb3lcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhbGwgaXRlbXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICAgICAqIEBuYW1lIGRlc3Ryb3lcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb25QYXJhbWV0ZXJzIEFuIG9iamVjdCB3aGljaCBhY2NlcHRzIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLndvcmtPZmZsaW5lXSBXaGV0aGVyIHRvIGludm9rZSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBvZmZsaW5lIHN0b3JhZ2UuIERlZmF1bHQgaXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgbW9kZSBvZiB0aGUgRXZlcmxpdmUgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5hcHBseU9mZmxpbmU9dHJ1ZV0gSWYgd29ya2luZyBvbmxpbmUsIHdoZXRoZXIgdG8gYWxzbyBhcHBseSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBsb2NhbCBzdG9yYWdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChmaWx0ZXIsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycyA9IHRoaXMuX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3kobnVsbCwgZmlsdGVyLCBmYWxzZSwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcclxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNsIFRoZSBhY2wgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIEFDTCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcclxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNsIFRoZSBhY2wgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIEFDTCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb25QYXJhbWV0ZXJzIEFuIG9iamVjdCB3aGljaCBhY2NlcHRzIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLndvcmtPZmZsaW5lXSBXaGV0aGVyIHRvIGludm9rZSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBvZmZsaW5lIHN0b3JhZ2UuIERlZmF1bHQgaXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgbW9kZSBvZiB0aGUgRXZlcmxpdmUgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5hcHBseU9mZmxpbmU9dHJ1ZV0gSWYgd29ya2luZyBvbmxpbmUsIHdoZXRoZXIgdG8gYWxzbyBhcHBseSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBsb2NhbCBzdG9yYWdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIEFjY2VzcyBDb250cm9sIExpc3QgKEFDTCkgb2YgYSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QWNsXHJcbiAgICAgICAgICogQG5hbWUgc2V0QWNsXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFjbCBUaGUgYWNsIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSBpdGVtLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhbiBpdGVtIHdpdGggYSBzcGVjaWZpZWQgSUQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcclxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNsIFRoZSBhY2wgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvblBhcmFtZXRlcnMgQW4gb2JqZWN0IHdoaWNoIGFjY2VwdHMgb3BlcmF0aW9uIHBhcmFtZXRlcnNcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMud29ya09mZmxpbmVdIFdoZXRoZXIgdG8gaW52b2tlIHRoZSBvcGVyYXRpb24gb24gdGhlIG9mZmxpbmUgc3RvcmFnZS4gRGVmYXVsdCBpcyBiYXNlZCBvbiB0aGUgY3VycmVudCBtb2RlIG9mIHRoZSBFdmVybGl2ZSBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmFwcGx5T2ZmbGluZT10cnVlXSBJZiB3b3JraW5nIG9ubGluZSwgd2hldGhlciB0byBhbHNvIGFwcGx5IHRoZSBvcGVyYXRpb24gb24gdGhlIGxvY2FsIHN0b3JhZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0QWNsOiBmdW5jdGlvbiAoYWNsLCBmaWx0ZXIsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnNldEFjbCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2w6IGFjbFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBkYXRhUXVlcnkuc2V0T3B0aW9ucyhvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzLCBvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBvd25lciBvZiB0aGUgc3BlY2lmaWVkIGRhdGEgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNldE93bmVyXHJcbiAgICAgICAgICogQG5hbWUgc2V0T3duZXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNsIFRoZSBuZXcgb3duZXIgSUQuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gVGhlIGl0ZW0gd2hvc2Ugb3duZXIgd2lsbCBiZSB1cGRhdGVkLiBOb3RlOiB0aGUgSUQgcHJvcGVydHkgb2YgdGhlIGl0ZW0gd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBpdGVtIHdpbGwgYmUgZGVsZXRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIG93bmVyIG9mIHRoZSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0T3duZXJcclxuICAgICAgICAgKiBAbmFtZSBzZXRPd25lclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2wgVGhlIG5ldyBvd25lciBJRC5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBUaGUgaXRlbSB3aG9zZSBvd25lciB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb25QYXJhbWV0ZXJzIEFuIG9iamVjdCB3aGljaCBhY2NlcHRzIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLndvcmtPZmZsaW5lXSBXaGV0aGVyIHRvIGludm9rZSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBvZmZsaW5lIHN0b3JhZ2UuIERlZmF1bHQgaXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgbW9kZSBvZiB0aGUgRXZlcmxpdmUgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5hcHBseU9mZmxpbmU9dHJ1ZV0gSWYgd29ya2luZyBvbmxpbmUsIHdoZXRoZXIgdG8gYWxzbyBhcHBseSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBsb2NhbCBzdG9yYWdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIG93bmVyIG9mIHRoZSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0T3duZXJcclxuICAgICAgICAgKiBAbmFtZSBzZXRPd25lclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvd25lcklkIFRoZSBuZXcgb3duZXIgSUQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIG93bmVyIG9mIHRoZSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0T3duZXJcclxuICAgICAgICAgKiBAbmFtZSBzZXRPd25lclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvd25lcklkIFRoZSBuZXcgb3duZXIgSUQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0aW9uUGFyYW1ldGVycyBBbiBvYmplY3Qgd2hpY2ggYWNjZXB0cyBvcGVyYXRpb24gcGFyYW1ldGVyc1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5lcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy53b3JrT2ZmbGluZV0gV2hldGhlciB0byBpbnZva2UgdGhlIG9wZXJhdGlvbiBvbiB0aGUgb2ZmbGluZSBzdG9yYWdlLiBEZWZhdWx0IGlzIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIEV2ZXJsaXZlIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuYXBwbHlPZmZsaW5lPXRydWVdIElmIHdvcmtpbmcgb25saW5lLCB3aGV0aGVyIHRvIGFsc28gYXBwbHkgdGhlIG9wZXJhdGlvbiBvbiB0aGUgbG9jYWwgc3RvcmFnZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRPd25lcjogZnVuY3Rpb24gKG93bmVySWQsIGZpbHRlciwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0T3duZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPd25lcjogb3duZXJJZFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRhdGFRdWVyeS5zZXRPcHRpb25zKG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3MsIG9wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2F2ZXMgdGhlIHByb3ZpZGVkIGRhdGEgaXRlbS4gVGhpcyBvcGVyYXRpb24gd2lsbCBjcmVhdGUgb3IgdXBkYXRlIHRoZSBpdGVtIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzIG5ldyBvciBleGlzdGluZy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNhdmVcclxuICAgICAgICAgKiBAbmFtZSBzYXZlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBzYXZlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNhdmVzIHRoZSBwcm92aWRlZCBkYXRhIGl0ZW0uIFRoaXMgb3BlcmF0aW9uIHdpbGwgY3JlYXRlIG9yIHVwZGF0ZSB0aGUgaXRlbSBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBuZXcgb3IgZXhpc3RpbmcuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzYXZlXHJcbiAgICAgICAgICogQG5hbWUgc2F2ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSB0aGF0IGlzIGJlaW5nIHNhdmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb25QYXJhbWV0ZXJzIEFuIG9iamVjdCB3aGljaCBhY2NlcHRzIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLndvcmtPZmZsaW5lXSBXaGV0aGVyIHRvIGludm9rZSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBvZmZsaW5lIHN0b3JhZ2UuIERlZmF1bHQgaXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgbW9kZSBvZiB0aGUgRXZlcmxpdmUgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5hcHBseU9mZmxpbmU9dHJ1ZV0gSWYgd29ya2luZyBvbmxpbmUsIHdoZXRoZXIgdG8gYWxzbyBhcHBseSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBsb2NhbCBzdG9yYWdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uIChtb2RlbCwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBpc05ldyA9IHRoaXMuaXNOZXcobW9kZWwpO1xyXG4gICAgICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNhdmVTdWNjZXNzKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy50eXBlID0gaXNOZXcgPyAnY3JlYXRlJyA6ICd1cGRhdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MocmVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzYXZlRXJyb3IoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyLnR5cGUgPSBpc05ldyA/ICdjcmVhdGUnIDogJ3VwZGF0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlUGFyYW1zID0gXy5jbG9uZShvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZVBhcmFtcy5zdWNjZXNzID0gc2F2ZVN1Y2Nlc3M7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVQYXJhbXMuZXJyb3IgPSBzYXZlRXJyb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY3JlYXRlKG1vZGVsLCBjcmVhdGVQYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi51cGRhdGVTaW5nbGUobW9kZWwsIGNyZWF0ZVBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIG9wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzcywgb3BlcmF0aW9uUGFyYW1ldGVycy5lcnJvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBkYXRhIGl0ZW0gaXMgbmV3IG9yIG5vdC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIG1vZGVsIEl0ZW0gdG8gY2hlY2suXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNOZXc6IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG1vZGVsW2lkRmllbGRdID09PSAndW5kZWZpbmVkJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBEYXRhO1xyXG59KCkpO1xyXG4iLCIvKipcclxuICogQGNsYXNzIEZpbGVzXHJcbiAqIEBwcm90ZWN0ZWRcclxuICogQGV4dGVuZHMgRGF0YVxyXG4gKi9cclxuXHJcbnZhciBidWlsZFByb21pc2UgPSByZXF1aXJlKCcuLi91dGlscycpLmJ1aWxkUHJvbWlzZTtcclxudmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L0RhdGFRdWVyeScpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLmFkZEZpbGVzRnVuY3Rpb25zID0gZnVuY3Rpb24gYWRkRmlsZXNGdW5jdGlvbnMobnMpIHtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgVVJMIHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gZW5kcG9pbnQgZm9yIHVwbG9hZGluZyBhIGZpbGUuIEl0IGlzIHNwZWNpZmljIHRvIGVhY2gge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBhcHAuXHJcbiAgICAgKiBAbWVtYmVyb2YgRmlsZXMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGdldFVwbG9hZFVybFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgbnMuZ2V0VXBsb2FkVXJsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBFdmVybGl2ZS5idWlsZFVybCh0aGlzLnNldHVwKSArIHRoaXMuY29sbGVjdGlvbk5hbWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkb3dubG9hZCBVUkwgZm9yIGEgZmlsZS5cclxuICAgICAqIEBtZW1iZXJvZiBGaWxlcy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgZ2V0RG93bmxvYWRVcmxcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHVybCBUaGUgZG93bmxvYWQgVVJMLlxyXG4gICAgICovXHJcbiAgICBucy5nZXREb3dubG9hZFVybCA9IGZ1bmN0aW9uIChmaWxlSWQpIHtcclxuICAgICAgICByZXR1cm4gRXZlcmxpdmUuYnVpbGRVcmwodGhpcy5zZXR1cCkgKyB0aGlzLmNvbGxlY3Rpb25OYW1lICsgJy8nICsgZmlsZUlkICsgJy9Eb3dubG9hZCc7XHJcbiAgICB9O1xyXG5cclxuICAgIG5zLl9nZXRVcGRhdGVVcmwgPSBmdW5jdGlvbiAoZmlsZUlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbk5hbWUgKyAnLycgKyBmaWxlSWQgKyAnL0NvbnRlbnQnO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIFVSTCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGVuZHBvaW50IGZvciB1cGRhdGluZyBhIGZpbGUuIEl0IGlzIHNwZWNpZmljIHRvIGVhY2gge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBhcHAuXHJcbiAgICAgKiBAbWVtYmVyb2YgRmlsZXMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGdldFVwZGF0ZVVybFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZCBUaGUgSUQgb2YgdGhlIGZpbGUuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB1cmwgVGhlIHVwZGF0ZSBVUkwuXHJcbiAgICAgKi9cclxuICAgIG5zLmdldFVwZGF0ZVVybCA9IGZ1bmN0aW9uIChmaWxlSWQpIHtcclxuICAgICAgICByZXR1cm4gRXZlcmxpdmUuYnVpbGRVcmwodGhpcy5zZXR1cCkgKyB0aGlzLl9nZXRVcGRhdGVVcmwoZmlsZUlkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGEgZmlsZSdzIGNvbnRlbnRcclxuICAgICAqIEBtZW1iZXJvZiBGaWxlcy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdXBkYXRlQ29udGVudFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZCBGaWxlIElELlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUgRmlsZSBjb250ZW50cyBpbiBiYXNlNjQgZW5jb2RpbmcuXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uUGFyYW1ldGVyc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBucy51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gKGZpbGVJZCwgZmlsZSwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNVcGRhdGVDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhc3NlZCBmaWxlIGNvbnRlbnQgaXMgYmFzZTY0IGVuY29kZWRcclxuICAgICAgICAgICAgICAgIGRhdGE6IGZpbGUsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVJZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZGF0YVF1ZXJ5LnNldE9wdGlvbnMob3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICB9LCBvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3MsIG9wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRvd25sb2FkIFVSTCBmb3IgYSBmaWxlIGJ5IElELlxyXG4gICAgICogQG1lbWJlcm9mIEZpbGVzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBnZXREb3dubG9hZFVybEJ5SWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgRmlsZSBJRC5cclxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25QYXJhbWV0ZXJzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIG5zLmdldERvd25sb2FkVXJsQnlJZCA9IGZ1bmN0aW9uIChmaWxlSWQsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycyA9IHRoaXMuX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLmZpbGVzR2V0RG93bmxvYWRVcmxCeUlkLFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBmaWxlSWRcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcclxuICAgICAgICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGRhdGEucmVzdWx0LlVyaSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBkYXRhUXVlcnkuc2V0T3B0aW9ucyhvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgIH0sIG9wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzcywgb3BlcmF0aW9uUGFyYW1ldGVycy5lcnJvcik7XHJcbiAgICB9O1xyXG59OyIsIi8qKlxyXG4gKiBAY2xhc3MgVXNlcnNcclxuICogQGV4dGVuZHMgRGF0YVxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqL1xyXG5cclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIGJ1aWxkUHJvbWlzZSA9IHV0aWxzLmJ1aWxkUHJvbWlzZTtcclxudmFyIGd1YXJkVW5zZXQgPSB1dGlscy5ndWFyZFVuc2V0O1xyXG52YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgZ2V0QXV0aEluZm8gPSB1dGlscy5nZXRBdXRoSW5mbztcclxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuYWRkVXNlcnNGdW5jdGlvbnMgPSBmdW5jdGlvbiBhZGRVc2Vyc0Z1bmN0aW9ucyhucykge1xyXG4gICAgbnMuX2xvZ2luU3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGEucmVzdWx0O1xyXG4gICAgICAgIHRoaXMuc2V0QXV0aG9yaXphdGlvbihyZXN1bHQuYWNjZXNzX3Rva2VuLCByZXN1bHQudG9rZW5fdHlwZSk7XHJcbiAgICB9O1xyXG4gICAgbnMuX2xvZ291dFN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckF1dGhvcml6YXRpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgdXNlciB3aXRoIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcclxuICAgICAqIEBuYW1lIHJlZ2lzdGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIG5ldyB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIG5ldyB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdXNlckluZm8gQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgdGhlIHVzZXIgKGV4LiBEaXNwbGF5TmFtZSwgRW1haWwsIGV0Yy4pXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyB1c2VyIHVzaW5nIGEgdXNlcm5hbWUgYW5kIGEgcGFzc3dvcmQuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgKiBAbmFtZSByZWdpc3RlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSBuZXcgdXNlcidzIHVzZXJuYW1lLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBuZXcgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIGF0dHJzXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uUGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBucy5yZWdpc3RlciA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIGF0dHJzLCBvcGVyYXRpb25QYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgZ3VhcmRVbnNldCh1c2VybmFtZSwgJ3VzZXJuYW1lJyk7XHJcbiAgICAgICAgZ3VhcmRVbnNldChwYXNzd29yZCwgJ3Bhc3N3b3JkJyk7XHJcbiAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycyA9IHRoaXMuX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJndW1lbnRzKTtcclxuICAgICAgICB2YXIgdXNlciA9IHtcclxuICAgICAgICAgICAgVXNlcm5hbWU6IHVzZXJuYW1lLFxyXG4gICAgICAgICAgICBQYXNzd29yZDogcGFzc3dvcmRcclxuICAgICAgICB9O1xyXG4gICAgICAgIF8uZXh0ZW5kKHVzZXIsIGF0dHJzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodXNlciwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIExvZ3MgaW4gYSB1c2VyIHVzaW5nIGEgdXNlcm5hbWUgYW5kIGEgcGFzc3dvcmQgdG8gdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuIEFsbCByZXF1ZXN0cyBpbml0aWF0ZWQgYnkgdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2Ugd2lsbCBiZSBhdXRoZW50aWNhdGVkIHdpdGggdGhhdCB1c2VyJ3MgY3JlZGVudGlhbHMuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luXHJcbiAgICAgKiBAbmFtZSBsb2dpblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBpbiBhIHVzZXIgdXNpbmcgYSB1c2VybmFtZSBhbmQgYSBwYXNzd29yZCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gQWxsIHJlcXVlc3RzIGluaXRpYXRlZCBieSB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZSB3aWxsIGJlIGF1dGhlbnRpY2F0ZWQgd2l0aCB0aGF0IHVzZXIncyBjcmVkZW50aWFscy5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5cclxuICAgICAqIEBuYW1lIGxvZ2luXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIG9wZXJhdGlvblBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgbnMubG9naW4gPSBmdW5jdGlvbiAodXNlcm5hbWUsIHBhc3N3b3JkLCBvcGVyYXRpb25QYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fbG9naW5TdWNjZXNzLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbixcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ3Bhc3N3b3JkJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2Vzc0Z1bmMsXHJcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGRhdGFRdWVyeS5zZXRPcHRpb25zKG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgIH0sIG9wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzcywgb3BlcmF0aW9uUGFyYW1ldGVycy5lcnJvcik7XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETzogW29mZmxpbmVdIHRoaXMgbmVlZHMgdG8gYmUgc3VwcG9ydGVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSB1c2VyIHRoYXQgaXMgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdG8gdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBjdXJyZW50VXNlclxyXG4gICAgICogQG5hbWUgY3VycmVudFVzZXJcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlciB0aGF0IGlzIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHRvIHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESy5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgY3VycmVudFVzZXJcclxuICAgICAqIEBuYW1lIGN1cnJlbnRVc2VyXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMuY3VycmVudFVzZXIgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgZ2V0QXV0aEluZm8oc2VsZi5zZXR1cCwgXy5iaW5kKHNlbGYuZ2V0QnlJZCwgc2VsZiwgJ21lJykpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMudXNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiByZXMudXNlcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiBudWxsfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgcGFzc3dvcmQgb2YgYSB1c2VyLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBjaGFuZ2VQYXNzd29yZFxyXG4gICAgICogQG5hbWUgY2hhbmdlUGFzc3dvcmRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBUaGUgdXNlcidzIHVzZXJuYW1lLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3UGFzc3dvcmQgVGhlIHVzZXIncyBuZXcgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBUb2tlbnMgSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIHRva2VucyB3aWxsIGJlIHByZXNlcnZlZCBldmVuIGFmdGVyIHRoZSBwYXNzd29yZCBjaGFuZ2UuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIHBhc3N3b3JkIG9mIGEgdXNlci5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgY2hhbmdlUGFzc3dvcmRcclxuICAgICAqIEBuYW1lIGNoYW5nZVBhc3N3b3JkXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1Bhc3N3b3JkIFRoZSB1c2VyJ3MgbmV3IHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBrZWVwVG9rZW5zIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciB0b2tlbnMgd2lsbCBiZSBwcmVzZXJ2ZWQgZXZlbiBhZnRlciB0aGUgcGFzc3dvcmQgY2hhbmdlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmNoYW5nZVBhc3N3b3JkID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBwYXNzd29yZCwgbmV3UGFzc3dvcmQsIGtlZXBUb2tlbnMsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycyA9IHRoaXMuX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJDaGFuZ2VQYXNzd29yZCxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIFVzZXJuYW1lOiB1c2VybmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBQYXNzd29yZDogcGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgTmV3UGFzc3dvcmQ6IG5ld1Bhc3N3b3JkXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBrZWVwVG9rZW5zOiBrZWVwVG9rZW5zXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRhdGFRdWVyeS5zZXRPcHRpb25zKG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgfSwgb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzLCBvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgb3V0IHRoZSB1c2VyIHdobyBpcyBjdXJyZW50bHkgbG9nZ2VkIGluLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dvdXRcclxuICAgICAqIEBuYW1lIGxvZ291dFxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgb3V0IHRoZSB1c2VyIHdobyBpcyBjdXJyZW50bHkgbG9nZ2VkIGluLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dvdXRcclxuICAgICAqIEBuYW1lIGxvZ291dFxyXG4gICAgICogQHBhcmFtIG9wZXJhdGlvblBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgbnMubG9nb3V0ID0gZnVuY3Rpb24gKG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycyA9IHRoaXMuX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc3VjY2Vzc0Z1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9sb2dvdXRTdWNjZXNzLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgZXJyb3JGdW5jID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAzMDEpIHsgLy9pbnZhbGlkIHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhckF1dGhvcml6YXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9nb3V0LFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3NGdW5jLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JGdW5jXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkYXRhUXVlcnkuc2V0T3B0aW9ucyhvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICB9LCBvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3MsIG9wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBucy5fbG9naW5XaXRoUHJvdmlkZXIgPSBmdW5jdGlvbiAoaWRlbnRpdHksIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICB2YXIgdXNlciA9IHtcclxuICAgICAgICAgICAgSWRlbnRpdHk6IGlkZW50aXR5XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycyA9IHRoaXMuX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJndW1lbnRzKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fbG9naW5TdWNjZXNzLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbldpdGhQcm92aWRlcixcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogdXNlcixcclxuICAgICAgICAgICAgICAgIGF1dGhIZWFkZXJzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzRnVuYyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkYXRhUXVlcnkuc2V0T3B0aW9ucyhvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgfSwgb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzLCBvcGVyYXRpb25QYXJhbWV0ZXJzLmVycm9yKTtcclxuICAgIH07XHJcbiAgICBucy5fbGlua1dpdGhQcm92aWRlciA9IGZ1bmN0aW9uIChpZGVudGl0eSwgdXNlcklkLCBvcGVyYXRpb25QYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogdXNlcklkXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTGlua1dpdGhQcm92aWRlcixcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogaWRlbnRpdHksXHJcbiAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZGF0YVF1ZXJ5LnNldE9wdGlvbnMob3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICB9LCBvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3MsIG9wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3IpO1xyXG4gICAgfTtcclxuICAgIG5zLl91bmxpbmtGcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXJOYW1lLCB1c2VySWQsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycyA9IHRoaXMuX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogcHJvdmlkZXJOYW1lXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJZDogdXNlcklkXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyVW5saW5rRnJvbVByb3ZpZGVyLFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBpZGVudGl0eSxcclxuICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBkYXRhUXVlcnkuc2V0T3B0aW9ucyhvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgIH0sIG9wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzcywgb3BlcmF0aW9uUGFyYW1ldGVycy5lcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhGYWNlYm9va1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhGYWNlYm9va1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25QYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIG5zLmxvZ2luV2l0aEZhY2Vib29rID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBvcGVyYXRpb25QYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycyA9IHRoaXMuX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJndW1lbnRzKTtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnRmFjZWJvb2snLFxyXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBucy5fbG9naW5XaXRoUHJvdmlkZXIoaWRlbnRpdHksIG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYSBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoRmFjZWJvb2tcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgRmFjZWJvb2sgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSBCYWNrZW5kIFNlcnZpY2VzIHVzZXIgd2l0aCBhIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhGYWNlYm9va1xyXG4gICAgICogQG5hbWUgbGlua1dpdGhGYWNlYm9va1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSBGYWNlYm9vayBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIGEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25QYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIG5zLmxpbmtXaXRoRmFjZWJvb2sgPSBmdW5jdGlvbiAodXNlcklkLCBhY2Nlc3NUb2tlbiwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ0ZhY2Vib29rJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbnMuX2xpbmtXaXRoUHJvdmlkZXIoaWRlbnRpdHksIHVzZXJJZCwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIEZhY2Vib29rIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21GYWNlYm9va1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgRmFjZWJvb2sgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21GYWNlYm9va1xyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUZhY2Vib29rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uUGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBucy51bmxpbmtGcm9tRmFjZWJvb2sgPSBmdW5jdGlvbiAodXNlcklkLCBvcGVyYXRpb25QYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycyA9IHRoaXMuX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5zLl91bmxpbmtGcm9tUHJvdmlkZXIoJ0ZhY2Vib29rJywgdXNlcklkLCBvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEFERlMgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhBREZTXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhBREZTXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEFERlNcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEFERlNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25QYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIG5zLmxvZ2luV2l0aEFERlMgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnQURGUycsXHJcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG5zLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhBREZTXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEFERlNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgQURGUyBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IHRvIGFuIEFERlMgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aEFERlNcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoQURGU1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSBBREZTIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uUGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBucy5saW5rV2l0aEFERlMgPSBmdW5jdGlvbiAodXNlcklkLCBhY2Nlc3NUb2tlbiwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdBREZTJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbnMuX2xpbmtXaXRoUHJvdmlkZXIoaWRlbnRpdHksIHVzZXJJZCwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIEFERlMgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21BREZTXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tQURGU1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgQURGUyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUFERlNcclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21BREZTXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uUGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBucy51bmxpbmtGcm9tQURGUyA9IGZ1bmN0aW9uICh1c2VySWQsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICByZXR1cm4gbnMuX3VubGlua0Zyb21Qcm92aWRlcignQURGUycsIHVzZXJJZCwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIExpdmVJRCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aExpdmVJRFxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoTGl2ZUlEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gTGl2ZUlEIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIExpdmVJRCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aExpdmVJRFxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoTGl2ZUlEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gTGl2ZUlEIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25QYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIG5zLmxvZ2luV2l0aExpdmVJRCA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdMaXZlSUQnLFxyXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBucy5fbG9naW5XaXRoUHJvdmlkZXIoaWRlbnRpdHksIG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYSBMaXZlSWQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aExpdmVJRFxyXG4gICAgICogQG5hbWUgbGlua1dpdGhMaXZlSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgTGl2ZUlEIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYSBMaXZlSWQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aExpdmVJRFxyXG4gICAgICogQG5hbWUgbGlua1dpdGhMaXZlSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgTGl2ZUlEIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uUGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBucy5saW5rV2l0aExpdmVJRCA9IGZ1bmN0aW9uICh1c2VySWQsIGFjY2Vzc1Rva2VuLCBvcGVyYXRpb25QYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycyA9IHRoaXMuX2dldE9wZXJhdGlvblBhcmFtZXRlcnMoYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ0xpdmVJRCcsXHJcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG5zLl9saW5rV2l0aFByb3ZpZGVyKGlkZW50aXR5LCB1c2VySWQsIG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBMaXZlSUQgYWNjZXNzIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tTGl2ZUlEXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tTGl2ZUlEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBMaXZlSUQgYWNjZXNzIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tTGl2ZUlEXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tTGl2ZUlEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uUGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBucy51bmxpbmtGcm9tTGl2ZUlEID0gZnVuY3Rpb24gKHVzZXJJZCwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdMaXZlSUQnLCB1c2VySWQsIG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhHb29nbGVcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEdvb2dsZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhHb29nbGVcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEdvb2dsZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uUGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBucy5sb2dpbldpdGhHb29nbGUgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnR29vZ2xlJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5zLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoR29vZ2xlXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEdvb2dsZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSBHb29nbGUgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoR29vZ2xlXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEdvb2dsZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSBHb29nbGUgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cclxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25QYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIG5zLmxpbmtXaXRoR29vZ2xlID0gZnVuY3Rpb24gKHVzZXJJZCwgYWNjZXNzVG9rZW4sIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnR29vZ2xlJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5zLl9saW5rV2l0aFByb3ZpZGVyKGlkZW50aXR5LCB1c2VySWQsIG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBHb29nbGUgYWNjZXNzIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tR29vZ2xlXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tR29vZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBHb29nbGUgYWNjZXNzIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tR29vZ2xlXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tR29vZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uUGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBucy51bmxpbmtGcm9tR29vZ2xlID0gZnVuY3Rpb24gKHVzZXJJZCwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdHb29nbGUnLCB1c2VySWQsIG9wZXJhdGlvblBhcmFtZXRlcnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVHdpdHRlciB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblNlY3JldCBUd2l0dGVyIHNlY3JldCB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB3aXRoIGEgVHdpdHRlciB0b2tlbi4gQSBzZWNyZXQgdG9rZW4gbmVlZHMgdG8gYmUgcHJvdmlkZWQuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aFR3aXR0ZXJcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aFR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUd2l0dGVyIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuU2VjcmV0IFR3aXR0ZXIgc2VjcmV0IHRva2VuLlxyXG4gICAgICogQHBhcmFtIG9wZXJhdGlvblBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgbnMubG9naW5XaXRoVHdpdHRlciA9IGZ1bmN0aW9uICh0b2tlbiwgdG9rZW5TZWNyZXQsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcclxuICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzID0gdGhpcy5fZ2V0T3BlcmF0aW9uUGFyYW1ldGVycyhhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnVHdpdHRlcicsXHJcbiAgICAgICAgICAgIFRva2VuOiB0b2tlbixcclxuICAgICAgICAgICAgVG9rZW5TZWNyZXQ6IHRva2VuU2VjcmV0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5zLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgdG8gYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhUd2l0dGVyXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aFR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgVHdpdHRlciBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuU2VjcmV0IFRoZSBUd2l0dGVyIHNlY3JldCB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgdG8gYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC4gICAgICAgICAqIExpbmtzIGEgQmFja2VuZCBTZXJ2aWNlcyB1c2VyIHdpdGggYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhUd2l0dGVyXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aFR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgVHdpdHRlciBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuU2VjcmV0IFRoZSBUd2l0dGVyIHNlY3JldCB0b2tlbi5cclxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25QYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIG5zLmxpbmtXaXRoVHdpdHRlciA9IGZ1bmN0aW9uICh1c2VySWQsIHRva2VuLCB0b2tlblNlY3JldCwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdUd2l0dGVyJyxcclxuICAgICAgICAgICAgVG9rZW46IHRva2VuLFxyXG4gICAgICAgICAgICBUb2tlblNlY3JldDogdG9rZW5TZWNyZXRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gbnMuX2xpbmtXaXRoUHJvdmlkZXIoaWRlbnRpdHksIHVzZXJJZCwgb3BlcmF0aW9uUGFyYW1ldGVycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIFR3aXR0ZXIgYWNjZXNzIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tVHdpdHRlclxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbVR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIFR3aXR0ZXIgYWNjZXNzIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tVHdpdHRlclxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbVR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25QYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIG5zLnVubGlua0Zyb21Ud2l0dGVyID0gZnVuY3Rpb24gKHVzZXJJZCwgb3BlcmF0aW9uUGFyYW1ldGVycykge1xyXG4gICAgICAgIG9wZXJhdGlvblBhcmFtZXRlcnMgPSB0aGlzLl9nZXRPcGVyYXRpb25QYXJhbWV0ZXJzKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdUd2l0dGVyJywgdXNlcklkLCBvcGVyYXRpb25QYXJhbWV0ZXJzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB0b2tlbiBhbmQgdG9rZW4gdHlwZSB0aGF0IHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEphdmFTY3JpcHQgU0RLIHdpbGwgdXNlIGZvciBhdXRob3JpemF0aW9uLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBzZXRBdXRob3JpemF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVG9rZW4gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGF1dGhvcml6YXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge0V2ZXJsaXZlLlRva2VuVHlwZX0gdG9rZW5UeXBlIFRva2VuIHR5cGUuIEN1cnJlbnRseSBvbmx5ICdiZWFyZXInIHRva2VuIGlzIHN1cHBvcnRlZC5cclxuICAgICAqL1xyXG4gICAgbnMuc2V0QXV0aG9yaXphdGlvbiA9IGZ1bmN0aW9uIHNldEF1dGhvcml6YXRpb24odG9rZW4sIHRva2VuVHlwZSkge1xyXG4gICAgICAgIHRoaXMuc2V0dXAudG9rZW4gPSB0b2tlbjtcclxuICAgICAgICB0aGlzLnNldHVwLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIHRoYXQgdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGN1cnJlbnRseSB1c2VzLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgdGhhbiBsb2dnaW5nIG91dCwgYmVjYXVzZSB0aGUgY3VycmVudCBhdXRob3JpemF0aW9uIHRva2VuIGlzIG5vdCBpbnZhbGlkYXRlZC5cclxuICAgICAqIEBtZXRob2QgY2xlYXJBdXRob3JpemF0aW9uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKi9cclxuICAgIG5zLmNsZWFyQXV0aG9yaXphdGlvbiA9IGZ1bmN0aW9uIGNsZWFyQXV0aG9yaXphdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldEF1dGhvcml6YXRpb24obnVsbCwgbnVsbCk7XHJcbiAgICB9O1xyXG59OyIsInZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIEF1dGhTdGF0dXMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLkF1dGhTdGF0dXM7XHJcbnZhciBfID0gcmVxdWlyZSgnLi9jb21tb24nKS5fO1xyXG52YXIgdXRpbHMgPSB7fTtcclxuXHJcbnV0aWxzLmd1YXJkVW5zZXQgPSBmdW5jdGlvbiBndWFyZFVuc2V0KHZhbHVlLCBuYW1lLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIW1lc3NhZ2UpIHtcclxuICAgICAgICBtZXNzYWdlID0gJ1RoZSAnICsgbmFtZSArICcgaXMgcmVxdWlyZWQnO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxufTtcclxuXHJcbnV0aWxzLnBhcnNlVXRpbGl0aWVzID0ge1xyXG4gICAgZ2V0UmV2aXZlcjogZnVuY3Rpb24gKHBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmcpIHtcclxuICAgICAgICB2YXIgZGF0ZVBhcnNlcjtcclxuICAgICAgICBpZiAocGFyc2VPbmx5Q29tcGxldGVEYXRlVGltZVN0cmluZykge1xyXG4gICAgICAgICAgICBkYXRlUGFyc2VyID0gdXRpbHMucGFyc2VVdGlsaXRpZXMucGFyc2VJc29EYXRlU3RyaW5nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGVQYXJzZXIgPSB1dGlscy5wYXJzZVV0aWxpdGllcy5wYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IGRhdGVQYXJzZXIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlSXNvRGF0ZVN0cmluZzogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oXFxkezR9KSgtKFxcZHsyfSkoLShcXGR7Mn0pKFQoXFxkezJ9KTooXFxkezJ9KSg6KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoXFwrfC0pKFxcZHsyfSk6KFxcZHsyfSkpKSk/KSkkLykpIHtcclxuICAgICAgICAgICAgLy8gRGF0ZVRpbWVcclxuICAgICAgICAgICAgdmFyIHNlY29uZFBhcnRzID0gbWF0Y2hbMTJdO1xyXG4gICAgICAgICAgICBpZiAoc2Vjb25kUGFydHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWNvbmRQYXJ0cy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGFydHMgPSBNYXRoLnJvdW5kKE51bWJlcihzZWNvbmRQYXJ0cy5zdWJzdHIoMCwgMykgKyAnLicgKyBzZWNvbmRQYXJ0cy5zdWJzdHIoMykpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlY29uZFBhcnRzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2Vjb25kUGFydHMgYXJlIG9uZSBvciB0d28gY2hhcmFjdGVycyB0aGVuIHR3byBvciBvbmUgemVyb3Mgc2hvdWxkIGJlIGFwcGVuZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gaGF2ZSB0aGUgY29ycmVjdCBudW1iZXIgZm9yIG1pbGxpc2Vjb25kcyAoJy42NycgbWVhbnMgNjcwbXMgbm90IDY3bXMpXHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGFydHMgKz0gc2Vjb25kUGFydHMubGVuZ3RoID09PSAyID8gJzAnIDogJzAwJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKFxyXG4gICAgICAgICAgICAgICAgRGF0ZS5VVEMoXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1hdGNoWzFdKSwgLy8geWVhclxyXG4gICAgICAgICAgICAgICAgICAgIChOdW1iZXIobWF0Y2hbM10pIC0gMSkgfHwgMCwgLy8gbW9udGhcclxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobWF0Y2hbNV0pIHx8IDAsIC8vIGRheVxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtYXRjaFs3XSkgfHwgMCwgLy8gaG91clxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtYXRjaFs4XSkgfHwgMCwgLy8gbWludXRlXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1hdGNoWzEwXSkgfHwgMCwgLy8gc2Vjb25kXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKHNlY29uZFBhcnRzKSB8fCAwXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBpZiAobWF0Y2hbMTNdICYmIG1hdGNoWzEzXSAhPT0gXCJaXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoID0gTnVtYmVyKG1hdGNoWzE2XSkgfHwgMCxcclxuICAgICAgICAgICAgICAgICAgICBtID0gTnVtYmVyKG1hdGNoWzE3XSkgfHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICBoICo9IDM2MDAwMDA7XHJcbiAgICAgICAgICAgICAgICBtICo9IDYwMDAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBoICsgbTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxNV0gPT09IFwiK1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUudmFsdWVPZigpICsgb2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLy50ZXN0KHN0cmluZykpIHtcclxuICAgICAgICAgICAgLy8gRGF0ZVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgvXihcXGR7Mn0pOihcXGR7Mn0pKDooXFxkezJ9KShcXC4oXFxkKykpPyk/KFp8KChcXCt8LSkoXFxkezJ9KTooXFxkezJ9KSkpPyQvLnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgICAgICAvLyBUaW1lXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLnBhcnNlVXRpbGl0aWVzLnBhcnNlSXNvRGF0ZVN0cmluZyhzdHJpbmcpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKG9iaiwgZnVuYykge1xyXG4gICAgICAgIHZhciBrZXksIHZhbHVlLCBuZXdWYWx1ZTtcclxuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBmdW5jKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmV3VmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLnBhcnNlVXRpbGl0aWVzLnRyYXZlcnNlKHZhbHVlLCBmdW5jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdHJhdmVyc2VBbmRSZXZpdmU6IGZ1bmN0aW9uIChkYXRhLCByZXZpdmVyKSB7XHJcbiAgICAgICAgaWYgKCFyZXZpdmVyKSB7XHJcbiAgICAgICAgICAgIHJldml2ZXIgPSB1dGlscy5wYXJzZVV0aWxpdGllcy5nZXRSZXZpdmVyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB1dGlscy5wYXJzZVV0aWxpdGllcy50cmF2ZXJzZShkYXRhLCByZXZpdmVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gKHJldml2ZXIsIGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgJiYgZXJyb3IubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7bWVzc2FnZTogZXJyb3IubWVzc2FnZSwgY29kZTogZXJyb3IuZXJyb3JDb2RlfTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX3BhcnNlSW50ZXJuYWw6IGZ1bmN0aW9uIChyZXZpdmVyLCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSwgcmV2aXZlcik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdXRpbHMucGFyc2VVdGlsaXRpZXMudHJhdmVyc2VBbmRSZXZpdmUoZGF0YSwgcmV2aXZlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgX3RyYW5zZm9ybVJlc3VsdDogZnVuY3Rpb24gKGRhdGEsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtyZXN1bHQ6IGRhdGEuUmVzdWx0fTtcclxuICAgICAgICAgICAgXy5leHRlbmQocmVzdWx0LCBhZGRpdGlvbmFsUHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZVJlc3VsdDogZnVuY3Rpb24gKHJldml2ZXIsIGRhdGEpIHtcclxuICAgICAgICBkYXRhID0gdXRpbHMucGFyc2VVdGlsaXRpZXMuX3BhcnNlSW50ZXJuYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gdXRpbHMucGFyc2VVdGlsaXRpZXMuX3RyYW5zZm9ybVJlc3VsdChkYXRhLCB7Y291bnQ6IGRhdGEuQ291bnR9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VTaW5nbGVSZXN1bHQ6IGZ1bmN0aW9uIChyZXZpdmVyLCBkYXRhKSB7XHJcbiAgICAgICAgZGF0YSA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLl9wYXJzZUludGVybmFsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLnBhcnNlVXRpbGl0aWVzLl90cmFuc2Zvcm1SZXN1bHQoZGF0YSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlVXBkYXRlUmVzdWx0OiBmdW5jdGlvbiAocmV2aXZlciwgZGF0YSkge1xyXG4gICAgICAgIGRhdGEgPSB1dGlscy5wYXJzZVV0aWxpdGllcy5fcGFyc2VJbnRlcm5hbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy5fdHJhbnNmb3JtUmVzdWx0KGRhdGEsIHtNb2RpZmllZEF0OiBkYXRhLk1vZGlmaWVkQXR9KTtcclxuICAgIH1cclxufTtcclxuXHJcbnV0aWxzLmJ1aWxkUHJvbWlzZSA9IGZ1bmN0aW9uIGJ1aWxkUHJvbWlzZShvcGVyYXRpb24sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICB2YXIgY2FsbGJhY2tzID0gRXZlcmxpdmUuZ2V0Q2FsbGJhY2tzKHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIG9wZXJhdGlvbihjYWxsYmFja3Muc3VjY2VzcywgY2FsbGJhY2tzLmVycm9yKTtcclxuICAgIHJldHVybiBjYWxsYmFja3MucHJvbWlzZTtcclxufTtcclxuXHJcbnV0aWxzLmJ1aWxkQXV0aEhlYWRlciA9IGZ1bmN0aW9uIGJ1aWxkQXV0aEhlYWRlcihzZXR1cCwgb3B0aW9ucykge1xyXG4gICAgdmFyIGF1dGhIZWFkZXJWYWx1ZSA9IG51bGw7XHJcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmF1dGhIZWFkZXJzID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBhdXRoSGVhZGVyVmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAoc2V0dXAudG9rZW4pIHtcclxuICAgICAgICBhdXRoSGVhZGVyVmFsdWUgPSAoc2V0dXAudG9rZW5UeXBlIHx8ICdiZWFyZXInKSArICcgJyArIHNldHVwLnRva2VuO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2V0dXAubWFzdGVyS2V5KSB7XHJcbiAgICAgICAgYXV0aEhlYWRlclZhbHVlID0gJ21hc3RlcmtleSAnICsgc2V0dXAubWFzdGVyS2V5O1xyXG4gICAgfVxyXG4gICAgaWYgKGF1dGhIZWFkZXJWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7QXV0aG9yaXphdGlvbjogYXV0aEhlYWRlclZhbHVlfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG51dGlscy5nZXRBdXRoSW5mbyA9IGZ1bmN0aW9uIGdldEF1dGhJbmZvKHNldHVwLCBnZXRVc2VyLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgaWYgKHNldHVwLm1hc3RlcktleSkge1xyXG4gICAgICAgIHJldHVybiB1dGlscy5idWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3Moe3N0YXR1czogQXV0aFN0YXR1cy5tYXN0ZXJLZXl9KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICBpZiAoIXNldHVwLnRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgc3VjY2Vzcyh7c3RhdHVzOiBBdXRoU3RhdHVzLnVuYXV0aGVudGljYXRlZH0pO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXJyb3JjYiA9IG51bGw7XHJcbiAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgIGVycm9yY2IgPSBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09IDYwMSkgeyAvLyBpbnZhbGlkIHJlcXVlc3QsIGkuZS4gdGhlIGFjY2VzcyB0b2tlbiBpcyBpbnZhbGlkIG9yIG1pc3NpbmdcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3Moe3N0YXR1czogQXV0aFN0YXR1cy5pbnZhbGlkQXV0aGVudGljYXRpb259KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVycm9yKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHByb21pc2UgPSBnZXRVc2VyKHN1Y2Nlc3MsIGVycm9yY2IpO1xyXG4gICAgaWYgKHByb21pc2UpIHtcclxuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXM6IEF1dGhTdGF0dXMuYXV0aGVudGljYXRlZCwgdXNlcjogcmVzLnJlc3VsdH07XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSA2MDEpIHsgLy8gaW52YWxpZCByZXF1ZXN0LCBpLmUuIHRoZSBhY2Nlc3MgdG9rZW4gaXMgaW52YWxpZCBvciBtaXNzaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge3N0YXR1czogQXV0aFN0YXR1cy5pbnZhbGlkQXV0aGVudGljYXRpb259O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvbWlzZTtcclxufTtcclxuXHJcbnV0aWxzLkRldmljZVJlZ2lzdHJhdGlvblJlc3VsdCA9IGZ1bmN0aW9uIERldmljZVJlZ2lzdHJhdGlvblJlc3VsdCh0b2tlbikge1xyXG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG59O1xyXG5cclxudXRpbHMuY2xvbmVEYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcclxufTtcclxuXHJcbnV0aWxzLmJ1aWxkVXJsID0gZnVuY3Rpb24gKHNldHVwKSB7XHJcbiAgICB2YXIgdXJsID0gJyc7XHJcbiAgICBpZiAodHlwZW9mIHNldHVwLnNjaGVtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB1cmwgKz0gc2V0dXAuc2NoZW1lICsgJzonO1xyXG4gICAgfVxyXG4gICAgdXJsICs9IHNldHVwLnVybDtcclxuICAgIGlmIChzZXR1cC5hcGlLZXkpIHtcclxuICAgICAgICB1cmwgKz0gc2V0dXAuYXBpS2V5ICsgJy8nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVybDtcclxufTtcclxuXHJcbnV0aWxzLmdldERiT3BlcmF0b3JzID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIHNoYWxsb3cpIHtcclxuICAgIHZhciBkYk9wZXJhdG9ycyA9IFtdO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZGJPcGVyYXRvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1vZGlmaWVyS2V5cyA9IE9iamVjdC5rZXlzKGV4cHJlc3Npb24pO1xyXG4gICAgXy5lYWNoKG1vZGlmaWVyS2V5cywgZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignJCcpID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRiT3BlcmF0b3JzLnB1c2goa2V5KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByZXNzaW9uW2tleV0gPT09ICdvYmplY3QnICYmICFzaGFsbG93KSB7XHJcbiAgICAgICAgICAgIGRiT3BlcmF0b3JzID0gZGJPcGVyYXRvcnMuY29uY2F0KHV0aWxzLmdldERiT3BlcmF0b3JzKGV4cHJlc3Npb25ba2V5XSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBkYk9wZXJhdG9ycztcclxufTtcclxuXHJcblxyXG52YXIgdW5zdXBwb3J0ZWREYk9wZXJhdG9ycyA9IFtcclxuICAgICckZ2VvV2l0aGluJyxcclxuICAgICckZ2VvSW50ZXJzZWN0cycsXHJcbiAgICAnJG5lYXInLFxyXG4gICAgJyR3aXRoaW4nLFxyXG4gICAgJyRuZWFyU3BoZXJlJ1xyXG5dO1xyXG5cclxudXRpbHMuZ2V0VW5zdXBwb3J0ZWRPcGVyYXRvcnMgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICB2YXIgZGJPcGVyYXRvcnMgPSB1dGlscy5nZXREYk9wZXJhdG9ycyhmaWx0ZXIpO1xyXG4gICAgcmV0dXJuIF8uaW50ZXJzZWN0aW9uKGRiT3BlcmF0b3JzLCB1bnN1cHBvcnRlZERiT3BlcmF0b3JzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdXRpbHM7XHJcbiJdfQ==
if (typeof module === "object" && typeof exports === "object") { module.exports = Everlive; }